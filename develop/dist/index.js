/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./develop/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./develop/src/exampleCode.js":
/*!************************************!*\
  !*** ./develop/src/exampleCode.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var normal = \"\\n@data{\\n    @name 'x0' /// string \\u540D\\u79F0\\n    @age 16 /// number \\u5E74\\u9F84\\n    @goodsList(66)[\\n        @title '\\u5546\\u54C1666' /// string \\u5546\\u54C1\\u540D\\u79F0\\n        @price '12.12' /// string \\u5546\\u54C1\\u4EF7\\u683C\\n    ]\\n}\\n\";\nvar WRAPPER = \"\\n@aaaaaaaaaa{\\n    @bbbbbbb(100)[\\n        @aaaaaaaaaa 1111111111\\n        @bbbbbbbbbb 2222222222\\n        @cccccccccc 3333333333\\n        @dddddddddd 4444444444\\n        @eeeeeeeeee 5555555555 + 6666666666\\n    ]\\n    ######PLACEHOLDER######\\n}\\n\"; // 巨型数据生成\n\nvar large = WRAPPER;\nvar count = 100;\n\nfor (var i = 0; i < count; i++) {\n  large = large.replace('######PLACEHOLDER######', WRAPPER);\n}\n\nlarge = large.replace('######PLACEHOLDER######', '');\nvar mock = \"\\n@json{\\n    @success true /// string \\u662F\\u5426\\u6210\\u529F\\n    @kkk(10)[\\n        @l @success\\n        @xx $param.page\\n    ]\\n    @kk(:\\n        let a = []\\n        for(let i = 0; i < 10;i++){\\n            a.push(i)\\n        }    \\n        @ a + 1\\n    :)\\n}\\n\\nlet kk  =12\\n\\n\\n\";\nmodule.exports = {\n  normal: normal,\n  large: large,\n  mock: mock\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZXZlbG9wL3NyYy9leGFtcGxlQ29kZS5qcz8wMTNhIl0sIm5hbWVzIjpbIm5vcm1hbCIsIldSQVBQRVIiLCJsYXJnZSIsImNvdW50IiwiaSIsInJlcGxhY2UiLCJtb2NrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBTUEsTUFBTSw2UEFBWjtBQVdBLElBQU1DLE9BQU8sNlBBQWIsQyxDQWFBOztBQUNBLElBQUlDLEtBQUssR0FBR0QsT0FBWjtBQUNBLElBQU1FLEtBQUssR0FBRyxHQUFkOztBQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBcEIsRUFBMkJDLENBQUMsRUFBNUIsRUFBZ0M7QUFDNUJGLE9BQUssR0FBR0EsS0FBSyxDQUFDRyxPQUFOLENBQWMseUJBQWQsRUFBeUNKLE9BQXpDLENBQVI7QUFDSDs7QUFDREMsS0FBSyxHQUFHQSxLQUFLLENBQUNHLE9BQU4sQ0FBYyx5QkFBZCxFQUF5QyxFQUF6QyxDQUFSO0FBR0EsSUFBTUMsSUFBSSxtU0FBVjtBQXFCQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2JSLFFBQU0sRUFBTkEsTUFEYTtBQUViRSxPQUFLLEVBQUxBLEtBRmE7QUFHYkksTUFBSSxFQUFKQTtBQUhhLENBQWpCIiwiZmlsZSI6Ii4vZGV2ZWxvcC9zcmMvZXhhbXBsZUNvZGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBub3JtYWwgPSBgXG5AZGF0YXtcbiAgICBAbmFtZSAneDAnIC8vLyBzdHJpbmcg5ZCN56ewXG4gICAgQGFnZSAxNiAvLy8gbnVtYmVyIOW5tOm+hFxuICAgIEBnb29kc0xpc3QoNjYpW1xuICAgICAgICBAdGl0bGUgJ+WVhuWTgTY2NicgLy8vIHN0cmluZyDllYblk4HlkI3np7BcbiAgICAgICAgQHByaWNlICcxMi4xMicgLy8vIHN0cmluZyDllYblk4Hku7fmoLxcbiAgICBdXG59XG5gXG5cbmNvbnN0IFdSQVBQRVIgPSBgXG5AYWFhYWFhYWFhYXtcbiAgICBAYmJiYmJiYigxMDApW1xuICAgICAgICBAYWFhYWFhYWFhYSAxMTExMTExMTExXG4gICAgICAgIEBiYmJiYmJiYmJiIDIyMjIyMjIyMjJcbiAgICAgICAgQGNjY2NjY2NjY2MgMzMzMzMzMzMzM1xuICAgICAgICBAZGRkZGRkZGRkZCA0NDQ0NDQ0NDQ0XG4gICAgICAgIEBlZWVlZWVlZWVlIDU1NTU1NTU1NTUgKyA2NjY2NjY2NjY2XG4gICAgXVxuICAgICMjIyMjI1BMQUNFSE9MREVSIyMjIyMjXG59XG5gXG5cbi8vIOW3qOWei+aVsOaNrueUn+aIkFxubGV0IGxhcmdlID0gV1JBUFBFUlxuY29uc3QgY291bnQgPSAxMDBcbmZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGxhcmdlID0gbGFyZ2UucmVwbGFjZSgnIyMjIyMjUExBQ0VIT0xERVIjIyMjIyMnLCBXUkFQUEVSKVxufVxubGFyZ2UgPSBsYXJnZS5yZXBsYWNlKCcjIyMjIyNQTEFDRUhPTERFUiMjIyMjIycsICcnKVxuXG5cbmNvbnN0IG1vY2sgPSBgXG5AanNvbntcbiAgICBAc3VjY2VzcyB0cnVlIC8vLyBzdHJpbmcg5piv5ZCm5oiQ5YqfXG4gICAgQGtraygxMClbXG4gICAgICAgIEBsIEBzdWNjZXNzXG4gICAgICAgIEB4eCAkcGFyYW0ucGFnZVxuICAgIF1cbiAgICBAa2soOlxuICAgICAgICBsZXQgYSA9IFtdXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMDtpKyspe1xuICAgICAgICAgICAgYS5wdXNoKGkpXG4gICAgICAgIH0gICAgXG4gICAgICAgIEAgYSArIDFcbiAgICA6KVxufVxuXG5sZXQga2sgID0xMlxuXG5cbmBcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbm9ybWFsLFxuICAgIGxhcmdlLFxuICAgIG1vY2ssXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./develop/src/exampleCode.js\n");

/***/ }),

/***/ "./develop/src/index.js":
/*!******************************!*\
  !*** ./develop/src/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var jsonsql = __webpack_require__(/*! ../../lib/index */ \"./lib/index.js\");\n\nvar beautifyJs = __webpack_require__(/*! js-beautify */ \"./node_modules/js-beautify/js/index.js\").js;\n\nvar exampleCode = __webpack_require__(/*! ./exampleCode */ \"./develop/src/exampleCode.js\");\n\nconsole.time('compile');\nvar interpreter = jsonsql.compile(exampleCode.mock);\nconsole.timeEnd('compile');\n\nif (typeof document !== 'undefined' && interpreter.code) {\n  document.body.innerHTML = \"<textarea style=\\\"width:100%; height:1000px\\\" autocomplete=\\\"off\\\">\".concat(beautifyJs(interpreter.code), \"</textarea>\");\n}\n\ninterpreter.execute({\n  $param: {\n    page: 1,\n    pageSize: 10\n  }\n}).then(function (res) {\n  console.info(res);\n})[\"catch\"](function (err) {\n  console.info(err);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZXZlbG9wL3NyYy9pbmRleC5qcz83M2Y2Il0sIm5hbWVzIjpbImpzb25zcWwiLCJyZXF1aXJlIiwiYmVhdXRpZnlKcyIsImpzIiwiZXhhbXBsZUNvZGUiLCJjb25zb2xlIiwidGltZSIsImludGVycHJldGVyIiwiY29tcGlsZSIsIm1vY2siLCJ0aW1lRW5kIiwiZG9jdW1lbnQiLCJjb2RlIiwiYm9keSIsImlubmVySFRNTCIsImV4ZWN1dGUiLCIkcGFyYW0iLCJwYWdlIiwicGFnZVNpemUiLCJ0aGVuIiwicmVzIiwiaW5mbyIsImVyciJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBTUEsT0FBTyxHQUFHQyxtQkFBTyxDQUFDLHVDQUFELENBQXZCOztBQUNBLElBQU1DLFVBQVUsR0FBR0QsbUJBQU8sQ0FBQywyREFBRCxDQUFQLENBQXVCRSxFQUExQzs7QUFFQSxJQUFNQyxXQUFXLEdBQUdILG1CQUFPLENBQUMsbURBQUQsQ0FBM0I7O0FBRUFJLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLFNBQWI7QUFDQSxJQUFNQyxXQUFXLEdBQUdQLE9BQU8sQ0FBQ1EsT0FBUixDQUFnQkosV0FBVyxDQUFDSyxJQUE1QixDQUFwQjtBQUNBSixPQUFPLENBQUNLLE9BQVIsQ0FBZ0IsU0FBaEI7O0FBR0EsSUFBSSxPQUFPQyxRQUFQLEtBQW9CLFdBQXBCLElBQW1DSixXQUFXLENBQUNLLElBQW5ELEVBQXlEO0FBQ3JERCxVQUFRLENBQUNFLElBQVQsQ0FBY0MsU0FBZCxnRkFBNEZaLFVBQVUsQ0FBQ0ssV0FBVyxDQUFDSyxJQUFiLENBQXRHO0FBQ0g7O0FBR0RMLFdBQVcsQ0FBQ1EsT0FBWixDQUFvQjtBQUNoQkMsUUFBTSxFQUFFO0FBQ0pDLFFBQUksRUFBRSxDQURGO0FBRUpDLFlBQVEsRUFBRTtBQUZOO0FBRFEsQ0FBcEIsRUFLR0MsSUFMSCxDQUtRLFVBQUFDLEdBQUcsRUFBSTtBQUNYZixTQUFPLENBQUNnQixJQUFSLENBQWFELEdBQWI7QUFDSCxDQVBELFdBT1MsVUFBQUUsR0FBRyxFQUFJO0FBQ1pqQixTQUFPLENBQUNnQixJQUFSLENBQWFDLEdBQWI7QUFDSCxDQVREIiwiZmlsZSI6Ii4vZGV2ZWxvcC9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBqc29uc3FsID0gcmVxdWlyZSgnLi4vLi4vbGliL2luZGV4JylcbmNvbnN0IGJlYXV0aWZ5SnMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmpzXG5cbmNvbnN0IGV4YW1wbGVDb2RlID0gcmVxdWlyZSgnLi9leGFtcGxlQ29kZScpXG5cbmNvbnNvbGUudGltZSgnY29tcGlsZScpXG5jb25zdCBpbnRlcnByZXRlciA9IGpzb25zcWwuY29tcGlsZShleGFtcGxlQ29kZS5tb2NrKVxuY29uc29sZS50aW1lRW5kKCdjb21waWxlJylcblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbnRlcnByZXRlci5jb2RlKSB7XG4gICAgZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSBgPHRleHRhcmVhIHN0eWxlPVwid2lkdGg6MTAwJTsgaGVpZ2h0OjEwMDBweFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiPiR7YmVhdXRpZnlKcyhpbnRlcnByZXRlci5jb2RlKX08L3RleHRhcmVhPmBcbn1cblxuXG5pbnRlcnByZXRlci5leGVjdXRlKHtcbiAgICAkcGFyYW06IHtcbiAgICAgICAgcGFnZTogMSxcbiAgICAgICAgcGFnZVNpemU6IDEwLFxuICAgIH0sXG59KS50aGVuKHJlcyA9PiB7XG4gICAgY29uc29sZS5pbmZvKHJlcylcbn0pLmNhdGNoKGVyciA9PiB7XG4gICAgY29uc29sZS5pbmZvKGVycilcbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./develop/src/index.js\n");

/***/ }),

/***/ "./lib/Compiler/Matchers.js":
/*!**********************************!*\
  !*** ./lib/Compiler/Matchers.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\");\n\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar logger = __webpack_require__(/*! ./logger */ \"./lib/Compiler/logger.js\");\n\nvar matchers = {};\nvar PID = 0;\n\nvar Matcher =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Matcher() {\n    var _this = this;\n\n    _classCallCheck(this, Matcher);\n\n    this.PID = PID++;\n    var originScan = this.scan;\n\n    this.scan = function (parentRuntime) {\n      logger.scaning(parentRuntime, _this);\n      originScan.call(_this, parentRuntime);\n    };\n\n    logger.matcherCreated(this);\n  }\n\n  _createClass(Matcher, [{\n    key: \"suffixNum\",\n    value: function suffixNum(m, n) {\n      // 匹配次数\n      // ? = {0,1}\n      // * = {0,Infinity}\n      // + = {1,Infinity}\n      // {m,n} = {m,n}\n      this.m = m;\n      this.n = n;\n    } // 执行扫描操作\n\n  }, {\n    key: \"scan\",\n    value: function scan() {\n      throw Error(\"Matcher.scan must be override by \".concat(this.constructor.name, \".scan\"));\n    }\n  }, {\n    key: \"match\",\n    value: function match() {\n      throw Error(\"Matcher.match must be override by \".concat(this.constructor.name, \".match\"));\n    }\n  }, {\n    key: \"matchSuccess\",\n    value: function matchSuccess() {\n      throw Error(\"Matcher.matchSuccess must be override by \".concat(this.constructor.name, \".matchSuccess\"));\n    }\n  }, {\n    key: \"matchFailure\",\n    value: function matchFailure() {\n      throw Error(\"Matcher.matchFailure must be override by \".concat(this.constructor.name, \".matchFailure\"));\n    }\n  }]);\n\n  return Matcher;\n}();\n\nMatcher.prototype.m = Matcher.prototype.n = 1;\nMatcher.prototype.stop = false; // 是否阻止进入下一个分支的扫描\n\nvar RootMatcher =\n/*#__PURE__*/\nfunction (_Matcher) {\n  \"use strict\";\n\n  _inherits(RootMatcher, _Matcher);\n\n  function RootMatcher(resolve, reject) {\n    var _this2;\n\n    _classCallCheck(this, RootMatcher);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(RootMatcher).call(this));\n    _this2.resolve = resolve;\n    _this2.reject = reject;\n    return _this2;\n  }\n\n  _createClass(RootMatcher, [{\n    key: \"matchFailure\",\n    value: function matchFailure(childRuntime, error) {\n      this.reject(childRuntime, error);\n    }\n  }, {\n    key: \"matchSuccess\",\n    value: function matchSuccess(childRuntime) {\n      this.resolve(childRuntime);\n    }\n  }]);\n\n  return RootMatcher;\n}(Matcher);\n\nvar HookMatcher =\n/*#__PURE__*/\nfunction (_Matcher2) {\n  \"use strict\";\n\n  _inherits(HookMatcher, _Matcher2);\n\n  function HookMatcher(id, _ref) {\n    var _this3;\n\n    var before = _ref.before,\n        done = _ref.done,\n        document = _ref.document,\n        source = _ref.source;\n\n    _classCallCheck(this, HookMatcher);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(HookMatcher).call(this));\n    _this3._id = id;\n    _this3._hooks = {\n      before: before,\n      done: done,\n      document: document\n    };\n    _this3._source = source;\n    _this3._child = _this3._parseSource(id, source);\n    matchers[id] = _assertThisInitialized(_this3);\n    return _this3;\n  }\n\n  _createClass(HookMatcher, [{\n    key: \"scan\",\n    value: function scan(parentRuntime) {\n      this._child.scan(parentRuntime.createChild(this));\n    }\n  }, {\n    key: \"matchSuccess\",\n    value: function matchSuccess(childRuntime) {\n      var thisRuntime = childRuntime.parent;\n      thisRuntime.appendChild(childRuntime);\n      thisRuntime.matchs++;\n\n      if (thisRuntime.matchs < this.n) {\n        // 继续下一个分量的扫描\n        this._child.scan(thisRuntime);\n      } else {\n        // 完成扫描\n        thisRuntime.resolve();\n      }\n    }\n  }, {\n    key: \"matchFailure\",\n    value: function matchFailure(childRuntime, error) {\n      var thisRuntime = childRuntime.parent;\n\n      if (thisRuntime.matchs < this.m) {\n        // 当前必选项匹配不足，则匹配失败\n        thisRuntime.reject(error);\n      } else {\n        thisRuntime.resolve();\n      }\n    }\n  }, {\n    key: \"_parseSource\",\n    value: function _parseSource(id, source) {\n      var curMatcher;\n\n      if (typeof source === 'function') {\n        curMatcher = new GroupMatcher(id);\n        curMatcher.putChild(new RuleMatcher(id, source));\n        curMatcher.putEnd();\n        return curMatcher;\n      }\n\n      var groupStack = [];\n      var groupParserRegExp = RegExp([/'((?:[^']|\\\\\\\\|\\\\')+)'/, // 匹配字符串\n      /<(\\w+|.)>/, // 匹配link\n      /(\\()/, /(\\))/, // 匹配分组\n      /([?*+]|\\{\\d+\\}|\\{\\d+,(?:\\d+)?\\}|\\{,\\d+\\})/, // \"?\", \"*\", \"+\", \"{n}\", \"{m,}\", \"{m,n}\", \"{,n}\"\n      /(&)/, // \"&\" 失败则阻止进入或分支，直接reject\n      /(\\|)/ // \"|\"\n      ].map(function (item) {\n        return item.source;\n      }).join('|'), 'g');\n\n      var groupStackTop = function groupStackTop() {\n        return groupStack[groupStack.length - 1].matcher;\n      };\n\n      var groupParser = function groupParser(all, matchString, matchLinkName, matchGroupOpen, matchGroupClose, matchSuffixNum, matchStop, matchOr, index) {\n        switch (false) {\n          case !matchString:\n            {\n              curMatcher = groupStackTop();\n              var newMatcher = new StringMatcher(matchString);\n              curMatcher.putChild(newMatcher);\n              curMatcher = newMatcher;\n              break;\n            }\n\n          case !matchLinkName:\n            {\n              curMatcher = groupStackTop();\n\n              var _newMatcher = new LinkMatcher(matchLinkName);\n\n              curMatcher.putChild(_newMatcher);\n              curMatcher = _newMatcher;\n              break;\n            }\n\n          case !matchGroupOpen:\n            {\n              curMatcher = groupStackTop();\n\n              var _newMatcher2 = new GroupMatcher();\n\n              curMatcher.putChild(_newMatcher2);\n              curMatcher = _newMatcher2;\n              groupStack.push({\n                matcher: curMatcher,\n                index: index\n              });\n              break;\n            }\n\n          case !matchGroupClose:\n            {\n              var groupStackPop = groupStack.pop();\n              curMatcher = groupStackPop.matcher;\n              curMatcher.putEnd(source.slice(groupStackPop.index, index + 1));\n              break;\n            }\n\n          case !matchSuffixNum:\n            {\n              switch (matchSuffixNum) {\n                case '?':\n                  {\n                    curMatcher.suffixNum(0, 1);\n                    break;\n                  }\n\n                case '*':\n                  {\n                    curMatcher.suffixNum(0, Infinity);\n                    break;\n                  }\n\n                case '+':\n                  {\n                    curMatcher.suffixNum(1, Infinity);\n                    break;\n                  }\n\n                default:\n                  {\n                    matchSuffixNum = matchSuffixNum.slice(1, -1).split(',');\n\n                    if (matchSuffixNum.length === 1) {\n                      curMatcher.suffixNum(+matchSuffixNum[0], +matchSuffixNum[0]);\n                    } else {\n                      curMatcher.suffixNum(+matchSuffixNum[0] || 0, +matchSuffixNum[1] || Infinity);\n                    }\n                  }\n              }\n\n              break;\n            }\n\n          case !matchStop:\n            {\n              curMatcher.stop = true;\n              break;\n            }\n\n          case !matchOr:\n            {\n              curMatcher = groupStackTop();\n              curMatcher.putOr();\n              break;\n            }\n        }\n      };\n\n      if (typeof source === 'string') {\n        curMatcher = new GroupMatcher();\n        groupStack.push({\n          matcher: curMatcher\n        });\n        source.replace(/\\/\\/\\/|\\/\\*[\\w\\W]*\\*\\//g, '').replace(groupParserRegExp, groupParser);\n        curMatcher = groupStack.pop().matcher;\n        curMatcher.putEnd(source);\n        return curMatcher;\n      }\n\n      throw Error(\"Compiler.option.mathcers.\".concat(this.key, \".source must be a function or string\"));\n    }\n  }]);\n\n  return HookMatcher;\n}(Matcher);\n\nvar GroupMatcher =\n/*#__PURE__*/\nfunction (_Matcher3) {\n  \"use strict\";\n\n  _inherits(GroupMatcher, _Matcher3);\n\n  function GroupMatcher(source) {\n    var _this4;\n\n    _classCallCheck(this, GroupMatcher);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(GroupMatcher).call(this));\n    _this4._source = source;\n    _this4._tempOr = null;\n    _this4._tempAnd = null;\n    _this4._orFirstChild = null;\n    return _this4;\n  } // 插入子级\n\n\n  _createClass(GroupMatcher, [{\n    key: \"putChild\",\n    value: function putChild(matcher) {\n      var _tempOr = this._tempOr,\n          _tempAnd = this._tempAnd;\n\n      if (_tempOr) {\n        // 已经存在or节点\n        // 继续添加and节点\n        if (_tempAnd) {\n          _tempAnd.nextSibling = matcher;\n          matcher.previousSibling = _tempAnd;\n          this._tempAnd = matcher;\n        } else {\n          this._tempOr = _tempOr.nextSibling = {\n            andFirstChild: this._tempAnd = matcher\n          };\n        }\n      } else {\n        this._orFirstChild = this._tempOr = {\n          andFirstChild: this._tempAnd = matcher\n        };\n      }\n\n      matcher.parentNode = this;\n      this._tempAnd.groupParent = this._tempOr; // 子级链回父级分组or，回溯的使用使用\n    } // 插入新的or分支\n\n  }, {\n    key: \"putOr\",\n    value: function putOr() {\n      this._tempAnd = null;\n    } // 完成节点创建\n\n  }, {\n    key: \"putEnd\",\n    value: function putEnd(source) {\n      this._source = source;\n      delete this._tempOr;\n      delete this._tempAnd;\n    }\n  }, {\n    key: \"scan\",\n    value: function scan(parentRuntime) {\n      var orChild = this._orFirstChild;\n      var andChild = orChild.andFirstChild;\n      andChild.scan(parentRuntime.createChild(this, {\n        orChild: orChild,\n        andChild: andChild,\n        tempChilds: []\n      }));\n    }\n  }, {\n    key: \"matchSuccess\",\n    value: function matchSuccess(childRuntime) {\n      // (A{3} B{1,2} | A{2} B{2})\n      // 子项扫描成功，则判断是否是最后项，是则进行下一个分量扫描，否则继续下一个子项扫描\n      var thisRuntime = childRuntime.parent;\n      var andChild = thisRuntime.andChild;\n\n      if (thisRuntime.tempLastChild) {\n        thisRuntime.tempLastChild.nextSibling = childRuntime;\n        childRuntime.previousSibling = thisRuntime.tempLastChild;\n        thisRuntime.tempLastChild = childRuntime;\n      } else {\n        thisRuntime.tempLastChild = thisRuntime.tempFirstChild = childRuntime;\n      } // 存在下一个子项\n\n\n      if (andChild.nextSibling) {\n        andChild = thisRuntime.andChild = andChild.nextSibling;\n        andChild.scan(thisRuntime);\n      } else {\n        thisRuntime.tempChilds.push({\n          firstChild: thisRuntime.tempFirstChild,\n          lastChild: thisRuntime.tempLastChild\n        });\n        thisRuntime.tempFirstChild = thisRuntime.tempLastChild = null;\n        thisRuntime.matchs++;\n\n        if (thisRuntime.matchs < this.n) {\n          // 继续下一个分量的扫描\n          thisRuntime.orChild = this._orFirstChild;\n          thisRuntime.andChild = thisRuntime.orChild.andFirstChild;\n          thisRuntime.andChild.scan(thisRuntime);\n        } else {\n          // 已经完成了所有的扫描\n          this._resolve(thisRuntime);\n        }\n      }\n    }\n  }, {\n    key: \"matchFailure\",\n    value: function matchFailure(childRuntime, error) {\n      var thisRuntime = childRuntime.parent; // 子项匹配失败\n      // 部分匹配成功了，用于判断是否停止扫描\n\n      var someMatched = thisRuntime.tempFirstChild && thisRuntime.tempFirstChild.bIndex < thisRuntime.tempLastChild.eIndex; // 回退当前扫描结果\n\n      if (thisRuntime.tempFirstChild) {\n        thisRuntime.sr.moveTo(thisRuntime.tempFirstChild.bIndex);\n        thisRuntime.tempFirstChild = thisRuntime.tempLastChild = null;\n      }\n\n      if (thisRuntime.orChild.nextSibling && !error.stop) {\n        // 假如新的错误扫描的更远，则更新错误\n        thisRuntime.error = thisRuntime.error && thisRuntime.error.bIndex >= error.bIndex ? thisRuntime.error : error;\n        thisRuntime.orChild = thisRuntime.orChild.nextSibling;\n        thisRuntime.andChild = thisRuntime.orChild.andFirstChild;\n        thisRuntime.andChild.scan(thisRuntime);\n      } else {\n        // 必选项分量不足，则此次匹配失败\n        // 假如可选集已经存在部分匹配，并且不允许回退，则会触发reject\n        if (thisRuntime.matchs < this.m || someMatched && error.stop) {\n          thisRuntime.error = thisRuntime.error && thisRuntime.error.bIndex >= error.bIndex ? thisRuntime.error : error;\n          thisRuntime.error.someMatched = someMatched;\n          thisRuntime.reject(thisRuntime.error);\n        } else {\n          this._resolve(thisRuntime);\n        }\n      }\n    }\n  }, {\n    key: \"_resolve\",\n    value: function _resolve(thisRuntime) {\n      var nowLastChild;\n\n      for (var i = 0; i < thisRuntime.tempChilds.length; i++) {\n        var _thisRuntime$tempChil = thisRuntime.tempChilds[i],\n            firstChild = _thisRuntime$tempChil.firstChild,\n            lastChild = _thisRuntime$tempChil.lastChild;\n\n        if (nowLastChild) {\n          nowLastChild.nextSibling = firstChild;\n          nowLastChild = thisRuntime.lastChild = lastChild;\n        } else {\n          thisRuntime.firstChild = firstChild;\n          nowLastChild = thisRuntime.lastChild = lastChild;\n        }\n      }\n\n      delete thisRuntime.tempChilds;\n      delete thisRuntime.tempFirstChild;\n      delete thisRuntime.tempLastChild;\n      delete thisRuntime.error;\n      thisRuntime.resolve();\n    }\n  }]);\n\n  return GroupMatcher;\n}(Matcher);\n\nvar LinkMatcher =\n/*#__PURE__*/\nfunction (_Matcher4) {\n  \"use strict\";\n\n  _inherits(LinkMatcher, _Matcher4);\n\n  function LinkMatcher(id) {\n    var _this5;\n\n    _classCallCheck(this, LinkMatcher);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(LinkMatcher).call(this));\n    _this5._id = id;\n    return _this5;\n  }\n\n  _createClass(LinkMatcher, [{\n    key: \"scan\",\n    value: function scan(parentRuntime) {\n      matchers[this._id].scan(parentRuntime.createChild(this));\n    }\n  }, {\n    key: \"matchSuccess\",\n    value: function matchSuccess(childRuntime) {\n      var thisRuntime = childRuntime.parent;\n      thisRuntime.appendChild(childRuntime);\n      thisRuntime.matchs++;\n\n      if (thisRuntime.matchs < this.n) {\n        // 继续下一个分量的扫描\n        matchers[this._id].scan(thisRuntime);\n      } else {\n        // 完成扫描\n        thisRuntime.resolve();\n      }\n    }\n  }, {\n    key: \"matchFailure\",\n    value: function matchFailure(childRuntime, error) {\n      var thisRuntime = childRuntime.parent;\n\n      if (thisRuntime.matchs < this.m || error.someMatched && this.stop) {\n        // 当前必选项匹配不足，则匹配失败\n        thisRuntime.reject(error);\n      } else {\n        thisRuntime.resolve();\n      }\n    }\n  }]);\n\n  return LinkMatcher;\n}(Matcher);\n\nvar RuleMatcher =\n/*#__PURE__*/\nfunction (_Matcher5) {\n  \"use strict\";\n\n  _inherits(RuleMatcher, _Matcher5);\n\n  function RuleMatcher(id, match) {\n    var _this6;\n\n    _classCallCheck(this, RuleMatcher);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(RuleMatcher).call(this));\n    _this6._id = id;\n    _this6._match = match;\n    matchers[id] = _assertThisInitialized(_this6);\n    return _this6;\n  }\n\n  _createClass(RuleMatcher, [{\n    key: \"scan\",\n    value: function scan(parentRuntime) {\n      var sr = parentRuntime.sr;\n      var bIndex = sr.chIndex;\n      var thisRuntime = parentRuntime.createChild(this);\n      sr.createRecord();\n\n      if (this._match(sr)) {\n        sr.removeRecord();\n        thisRuntime.resolve(bIndex, sr.chIndex);\n      } else {\n        sr.rollback();\n        thisRuntime.reject({\n          bIndex: bIndex\n        });\n      }\n    }\n  }]);\n\n  return RuleMatcher;\n}(Matcher);\n\nvar StringMatcher =\n/*#__PURE__*/\nfunction (_Matcher6) {\n  \"use strict\";\n\n  _inherits(StringMatcher, _Matcher6);\n\n  function StringMatcher(source) {\n    var _this7;\n\n    _classCallCheck(this, StringMatcher);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(StringMatcher).call(this));\n    _this7._source = source;\n    return _this7;\n  }\n\n  _createClass(StringMatcher, [{\n    key: \"scan\",\n    value: function scan(parentRuntime) {\n      var sr = parentRuntime.sr;\n      var thisRuntime = parentRuntime.createChild(this);\n      var bIndex = sr.chIndex;\n      var matchedEndIndex; // 发生错误的下标\n\n      var m = this.m,\n          n = this.n;\n      var isSuccess = true; // 必选集\n\n      sr.createRecord();\n\n      for (var i = 0; i < m; i++) {\n        if (!this._match(sr)) {\n          isSuccess = false;\n          sr.rollback();\n          break;\n        } else {\n          matchedEndIndex = sr.chIndex;\n        }\n      }\n\n      if (isSuccess) {\n        sr.removeRecord(); // 可选集\n\n        for (var _i = m; _i < n; _i++) {\n          sr.createRecord();\n\n          if (!this._match(sr)) {\n            sr.rollback();\n            break;\n          } else {\n            sr.removeRecord();\n          }\n        }\n\n        thisRuntime.resolve(bIndex, sr.chIndex);\n      } else {\n        thisRuntime.reject({\n          bIndex: bIndex,\n          matchedEndIndex: matchedEndIndex,\n          someMatched: matchedEndIndex > bIndex\n        });\n      }\n    }\n  }, {\n    key: \"_match\",\n    value: function _match(sr) {\n      var source = this._source;\n\n      for (var i = 0, lg = source.length; i < lg; i++) {\n        if (sr.read() !== source[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return StringMatcher;\n}(Matcher);\n\nmodule.exports = {\n  RootMatcher: RootMatcher,\n  RuleMatcher: RuleMatcher,\n  HookMatcher: HookMatcher\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvTWF0Y2hlcnMuanM/MjEzOSJdLCJuYW1lcyI6WyJsb2dnZXIiLCJyZXF1aXJlIiwibWF0Y2hlcnMiLCJQSUQiLCJNYXRjaGVyIiwib3JpZ2luU2NhbiIsInNjYW4iLCJwYXJlbnRSdW50aW1lIiwic2NhbmluZyIsImNhbGwiLCJtYXRjaGVyQ3JlYXRlZCIsIm0iLCJuIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJwcm90b3R5cGUiLCJzdG9wIiwiUm9vdE1hdGNoZXIiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2hpbGRSdW50aW1lIiwiZXJyb3IiLCJIb29rTWF0Y2hlciIsImlkIiwiYmVmb3JlIiwiZG9uZSIsImRvY3VtZW50Iiwic291cmNlIiwiX2lkIiwiX2hvb2tzIiwiX3NvdXJjZSIsIl9jaGlsZCIsIl9wYXJzZVNvdXJjZSIsImNyZWF0ZUNoaWxkIiwidGhpc1J1bnRpbWUiLCJwYXJlbnQiLCJhcHBlbmRDaGlsZCIsIm1hdGNocyIsImN1ck1hdGNoZXIiLCJHcm91cE1hdGNoZXIiLCJwdXRDaGlsZCIsIlJ1bGVNYXRjaGVyIiwicHV0RW5kIiwiZ3JvdXBTdGFjayIsImdyb3VwUGFyc2VyUmVnRXhwIiwiUmVnRXhwIiwibWFwIiwiaXRlbSIsImpvaW4iLCJncm91cFN0YWNrVG9wIiwibGVuZ3RoIiwibWF0Y2hlciIsImdyb3VwUGFyc2VyIiwiYWxsIiwibWF0Y2hTdHJpbmciLCJtYXRjaExpbmtOYW1lIiwibWF0Y2hHcm91cE9wZW4iLCJtYXRjaEdyb3VwQ2xvc2UiLCJtYXRjaFN1ZmZpeE51bSIsIm1hdGNoU3RvcCIsIm1hdGNoT3IiLCJpbmRleCIsIm5ld01hdGNoZXIiLCJTdHJpbmdNYXRjaGVyIiwiTGlua01hdGNoZXIiLCJwdXNoIiwiZ3JvdXBTdGFja1BvcCIsInBvcCIsInNsaWNlIiwic3VmZml4TnVtIiwiSW5maW5pdHkiLCJzcGxpdCIsInB1dE9yIiwicmVwbGFjZSIsImtleSIsIl90ZW1wT3IiLCJfdGVtcEFuZCIsIl9vckZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInByZXZpb3VzU2libGluZyIsImFuZEZpcnN0Q2hpbGQiLCJwYXJlbnROb2RlIiwiZ3JvdXBQYXJlbnQiLCJvckNoaWxkIiwiYW5kQ2hpbGQiLCJ0ZW1wQ2hpbGRzIiwidGVtcExhc3RDaGlsZCIsInRlbXBGaXJzdENoaWxkIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsIl9yZXNvbHZlIiwic29tZU1hdGNoZWQiLCJiSW5kZXgiLCJlSW5kZXgiLCJzciIsIm1vdmVUbyIsIm5vd0xhc3RDaGlsZCIsImkiLCJtYXRjaCIsIl9tYXRjaCIsImNoSW5kZXgiLCJjcmVhdGVSZWNvcmQiLCJyZW1vdmVSZWNvcmQiLCJyb2xsYmFjayIsIm1hdGNoZWRFbmRJbmRleCIsImlzU3VjY2VzcyIsImxnIiwicmVhZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNBLElBQU1BLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQywwQ0FBRCxDQUF0Qjs7QUFDQSxJQUFNQyxRQUFRLEdBQUcsRUFBakI7QUFDQSxJQUFJQyxHQUFHLEdBQUcsQ0FBVjs7SUFDTUMsTzs7Ozs7QUFDRixxQkFBZTtBQUFBOztBQUFBOztBQUNYLFNBQUtELEdBQUwsR0FBV0EsR0FBRyxFQUFkO0FBQ0EsUUFBTUUsVUFBVSxHQUFHLEtBQUtDLElBQXhCOztBQUNBLFNBQUtBLElBQUwsR0FBWSxVQUFDQyxhQUFELEVBQW1CO0FBQzNCUCxZQUFNLENBQUNRLE9BQVAsQ0FBZUQsYUFBZixFQUE4QixLQUE5QjtBQUNBRixnQkFBVSxDQUFDSSxJQUFYLENBQWdCLEtBQWhCLEVBQXNCRixhQUF0QjtBQUNILEtBSEQ7O0FBSUFQLFVBQU0sQ0FBQ1UsY0FBUCxDQUFzQixJQUF0QjtBQUNIOzs7OzhCQUVVQyxDLEVBQUdDLEMsRUFBRztBQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLRCxDQUFMLEdBQVNBLENBQVQ7QUFDQSxXQUFL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TCxFQUFDLEdBQUd2RixDQUFiLEVBQWdCdUYsRUFBQyxHQUFHdEYsQ0FBcEIsRUFBdUJzRixFQUFDLEVBQXhCLEVBQTRCO0FBQ3hCSCxZQUFFLENBQUNPLFlBQUg7O0FBQ0EsY0FBSSxDQUFDLEtBQUtGLE1BQUwsQ0FBWUwsRUFBWixDQUFMLEVBQXNCO0FBQ2xCQSxjQUFFLENBQUNTLFFBQUg7QUFDQTtBQUNILFdBSEQsTUFHTztBQUNIVCxjQUFFLENBQUNRLFlBQUg7QUFDSDtBQUNKOztBQUNEcEUsbUJBQVcsQ0FBQ2hCLE9BQVosQ0FBb0IwRSxNQUFwQixFQUE0QkUsRUFBRSxDQUFDTSxPQUEvQjtBQUNILE9BYkQsTUFhTztBQUNIbEUsbUJBQVcsQ0FBQ2YsTUFBWixDQUFtQjtBQUFFeUUsZ0JBQU0sRUFBTkEsTUFBRjtBQUFVWSx5QkFBZSxFQUFmQSxlQUFWO0FBQTJCYixxQkFBVyxFQUFFYSxlQUFlLEdBQUdaO0FBQTFELFNBQW5CO0FBQ0g7QUFDSjs7OzJCQUVPRSxFLEVBQUk7QUFDUixVQUFNbkUsTUFBTSxHQUFHLEtBQUtHLE9BQXBCOztBQUNBLFdBQUssSUFBSW1FLENBQUMsR0FBRyxDQUFSLEVBQVdTLEVBQUUsR0FBRy9FLE1BQU0sQ0FBQ3VCLE1BQTVCLEVBQW9DK0MsQ0FBQyxHQUFHUyxFQUF4QyxFQUE0Q1QsQ0FBQyxFQUE3QyxFQUFpRDtBQUM3QyxZQUFJSCxFQUFFLENBQUNhLElBQUgsT0FBY2hGLE1BQU0sQ0FBQ3NFLENBQUQsQ0FBeEIsRUFBNkI7QUFDekIsaUJBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7Ozs7RUFyRHVCOUYsTzs7QUF3RDVCeUcsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2I1RixhQUFXLEVBQVhBLFdBRGE7QUFDQXdCLGFBQVcsRUFBWEEsV0FEQTtBQUNhbkIsYUFBVyxFQUFYQTtBQURiLENBQWpCIiwiZmlsZSI6Ii4vbGliL0NvbXBpbGVyL01hdGNoZXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpXG5jb25zdCBtYXRjaGVycyA9IHt9XG5sZXQgUElEID0gMFxuY2xhc3MgTWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLlBJRCA9IFBJRCsrXG4gICAgICAgIGNvbnN0IG9yaWdpblNjYW4gPSB0aGlzLnNjYW5cbiAgICAgICAgdGhpcy5zY2FuID0gKHBhcmVudFJ1bnRpbWUpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5zY2FuaW5nKHBhcmVudFJ1bnRpbWUsIHRoaXMpXG4gICAgICAgICAgICBvcmlnaW5TY2FuLmNhbGwodGhpcywgcGFyZW50UnVudGltZSlcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubWF0Y2hlckNyZWF0ZWQodGhpcylcbiAgICB9XG5cbiAgICBzdWZmaXhOdW0gKG0sIG4pIHsgLy8g5Yy56YWN5qyh5pWwXG4gICAgICAgIC8vID8gPSB7MCwxfVxuICAgICAgICAvLyAqID0gezAsSW5maW5pdHl9XG4gICAgICAgIC8vICsgPSB7MSxJbmZpbml0eX1cbiAgICAgICAgLy8ge20sbn0gPSB7bSxufVxuICAgICAgICB0aGlzLm0gPSBtXG4gICAgICAgIHRoaXMubiA9IG5cbiAgICB9XG5cbiAgICAvLyDmiafooYzmiavmj4/mk43kvZxcbiAgICBzY2FuICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYE1hdGNoZXIuc2NhbiBtdXN0IGJlIG92ZXJyaWRlIGJ5ICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS5zY2FuYClcbiAgICB9XG5cbiAgICBtYXRjaCAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBNYXRjaGVyLm1hdGNoIG11c3QgYmUgb3ZlcnJpZGUgYnkgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9Lm1hdGNoYClcbiAgICB9XG5cbiAgICBtYXRjaFN1Y2Nlc3MgKCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgTWF0Y2hlci5tYXRjaFN1Y2Nlc3MgbXVzdCBiZSBvdmVycmlkZSBieSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0ubWF0Y2hTdWNjZXNzYClcbiAgICB9XG5cbiAgICBtYXRjaEZhaWx1cmUgKCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgTWF0Y2hlci5tYXRjaEZhaWx1cmUgbXVzdCBiZSBvdmVycmlkZSBieSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0ubWF0Y2hGYWlsdXJlYClcbiAgICB9XG59XG5NYXRjaGVyLnByb3RvdHlwZS5tID0gTWF0Y2hlci5wcm90b3R5cGUubiA9IDFcbk1hdGNoZXIucHJvdG90eXBlLnN0b3AgPSBmYWxzZSAvLyDmmK/lkKbpmLvmraLov5vlhaXkuIvkuIDkuKrliIbmlK/nmoTmiavmj49cbmNsYXNzIFJvb3RNYXRjaGVyIGV4dGVuZHMgTWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IgKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3RcbiAgICB9XG5cbiAgICBtYXRjaEZhaWx1cmUgKGNoaWxkUnVudGltZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5yZWplY3QoY2hpbGRSdW50aW1lLCBlcnJvcilcbiAgICB9XG5cbiAgICBtYXRjaFN1Y2Nlc3MgKGNoaWxkUnVudGltZSkge1xuICAgICAgICB0aGlzLnJlc29sdmUoY2hpbGRSdW50aW1lKVxuICAgIH1cbn1cblxuY2xhc3MgSG9va01hdGNoZXIgZXh0ZW5kcyBNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoaWQsIHsgYmVmb3JlLCBkb25lLCBkb2N1bWVudCwgc291cmNlIH0pIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLl9pZCA9IGlkXG4gICAgICAgIHRoaXMuX2hvb2tzID0geyBiZWZvcmUsIGRvbmUsIGRvY3VtZW50IH1cbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlXG4gICAgICAgIHRoaXMuX2NoaWxkID0gdGhpcy5fcGFyc2VTb3VyY2UoaWQsIHNvdXJjZSlcblxuICAgICAgICBtYXRjaGVyc1tpZF0gPSB0aGlzXG4gICAgfVxuXG4gICAgc2NhbiAocGFyZW50UnVudGltZSkge1xuICAgICAgICB0aGlzLl9jaGlsZC5zY2FuKHBhcmVudFJ1bnRpbWUuY3JlYXRlQ2hpbGQodGhpcykpXG4gICAgfVxuXG4gICAgbWF0Y2hTdWNjZXNzIChjaGlsZFJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgdGhpc1J1bnRpbWUgPSBjaGlsZFJ1bnRpbWUucGFyZW50XG4gICAgICAgIHRoaXNSdW50aW1lLmFwcGVuZENoaWxkKGNoaWxkUnVudGltZSlcbiAgICAgICAgdGhpc1J1bnRpbWUubWF0Y2hzKytcblxuICAgICAgICBpZiAodGhpc1J1bnRpbWUubWF0Y2hzIDwgdGhpcy5uKSB7XG4gICAgICAgICAgICAvLyDnu6fnu63kuIvkuIDkuKrliIbph4/nmoTmiavmj49cbiAgICAgICAgICAgIHRoaXMuX2NoaWxkLnNjYW4odGhpc1J1bnRpbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyDlrozmiJDmiavmj49cbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnJlc29sdmUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWF0Y2hGYWlsdXJlIChjaGlsZFJ1bnRpbWUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRoaXNSdW50aW1lID0gY2hpbGRSdW50aW1lLnBhcmVudFxuICAgICAgICBpZiAodGhpc1J1bnRpbWUubWF0Y2hzIDwgdGhpcy5tKSB7XG4gICAgICAgICAgICAvLyDlvZPliY3lv4XpgInpobnljLnphY3kuI3otrPvvIzliJnljLnphY3lpLHotKVcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnJlc29sdmUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BhcnNlU291cmNlIChpZCwgc291cmNlKSB7XG4gICAgICAgIGxldCBjdXJNYXRjaGVyXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjdXJNYXRjaGVyID0gbmV3IEdyb3VwTWF0Y2hlcihpZClcbiAgICAgICAgICAgIGN1ck1hdGNoZXIucHV0Q2hpbGQobmV3IFJ1bGVNYXRjaGVyKGlkLCBzb3VyY2UpKVxuICAgICAgICAgICAgY3VyTWF0Y2hlci5wdXRFbmQoKVxuICAgICAgICAgICAgcmV0dXJuIGN1ck1hdGNoZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyb3VwU3RhY2sgPSBbXVxuICAgICAgICBjb25zdCBncm91cFBhcnNlclJlZ0V4cCA9IFJlZ0V4cChbXG4gICAgICAgICAgICAvJygoPzpbXiddfFxcXFxcXFxcfFxcXFwnKSspJy8sIC8vIOWMuemFjeWtl+espuS4slxuICAgICAgICAgICAgLzwoXFx3K3wuKT4vLCAvLyDljLnphY1saW5rXG4gICAgICAgICAgICAvKFxcKCkvLCAvKFxcKSkvLCAvLyDljLnphY3liIbnu4RcbiAgICAgICAgICAgIC8oWz8qK118XFx7XFxkK1xcfXxcXHtcXGQrLCg/OlxcZCspP1xcfXxcXHssXFxkK1xcfSkvLCAvLyBcIj9cIiwgXCIqXCIsIFwiK1wiLCBcIntufVwiLCBcInttLH1cIiwgXCJ7bSxufVwiLCBcInssbn1cIlxuICAgICAgICAgICAgLygmKS8sIC8vIFwiJlwiIOWksei0peWImemYu+atoui/m+WFpeaIluWIhuaUr++8jOebtOaOpXJlamVjdFxuICAgICAgICAgICAgLyhcXHwpLywgLy8gXCJ8XCJcbiAgICAgICAgXS5tYXAoaXRlbSA9PiBpdGVtLnNvdXJjZSkuam9pbignfCcpLCAnZycpXG4gICAgICAgIGNvbnN0IGdyb3VwU3RhY2tUb3AgPSAoKSA9PiBncm91cFN0YWNrW2dyb3VwU3RhY2subGVuZ3RoIC0gMV0ubWF0Y2hlclxuICAgICAgICBjb25zdCBncm91cFBhcnNlciA9IChcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgICAgIG1hdGNoU3RyaW5nLFxuICAgICAgICAgICAgbWF0Y2hMaW5rTmFtZSxcbiAgICAgICAgICAgIG1hdGNoR3JvdXBPcGVuLCBtYXRjaEdyb3VwQ2xvc2UsXG4gICAgICAgICAgICBtYXRjaFN1ZmZpeE51bSxcbiAgICAgICAgICAgIG1hdGNoU3RvcCxcbiAgICAgICAgICAgIG1hdGNoT3IsXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICApID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICFtYXRjaFN0cmluZzoge1xuICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyID0gZ3JvdXBTdGFja1RvcCgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld01hdGNoZXIgPSBuZXcgU3RyaW5nTWF0Y2hlcihtYXRjaFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF0Y2hlci5wdXRDaGlsZChuZXdNYXRjaGVyKVxuICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyID0gbmV3TWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICFtYXRjaExpbmtOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIgPSBncm91cFN0YWNrVG9wKClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TWF0Y2hlciA9IG5ldyBMaW5rTWF0Y2hlcihtYXRjaExpbmtOYW1lKVxuICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyLnB1dENoaWxkKG5ld01hdGNoZXIpXG4gICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIgPSBuZXdNYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgIW1hdGNoR3JvdXBPcGVuOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIgPSBncm91cFN0YWNrVG9wKClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TWF0Y2hlciA9IG5ldyBHcm91cE1hdGNoZXIoKVxuICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyLnB1dENoaWxkKG5ld01hdGNoZXIpXG4gICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIgPSBuZXdNYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU3RhY2sucHVzaCh7IG1hdGNoZXI6IGN1ck1hdGNoZXIsIGluZGV4IH0pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgIW1hdGNoR3JvdXBDbG9zZToge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncm91cFN0YWNrUG9wID0gZ3JvdXBTdGFjay5wb3AoKVxuICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyID0gZ3JvdXBTdGFja1BvcC5tYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIucHV0RW5kKHNvdXJjZS5zbGljZShncm91cFN0YWNrUG9wLmluZGV4LCBpbmRleCArIDEpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICFtYXRjaFN1ZmZpeE51bToge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoU3VmZml4TnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc/Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIuc3VmZml4TnVtKDAsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTWF0Y2hlci5zdWZmaXhOdW0oMCwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTWF0Y2hlci5zdWZmaXhOdW0oMSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFN1ZmZpeE51bSA9IG1hdGNoU3VmZml4TnVtLnNsaWNlKDEsIC0xKS5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoU3VmZml4TnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyLnN1ZmZpeE51bSgrbWF0Y2hTdWZmaXhOdW1bMF0sICttYXRjaFN1ZmZpeE51bVswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVyLnN1ZmZpeE51bSgrbWF0Y2hTdWZmaXhOdW1bMF0gfHwgMCwgK21hdGNoU3VmZml4TnVtWzFdIHx8IEluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICFtYXRjaFN0b3A6IHtcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF0Y2hlci5zdG9wID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICFtYXRjaE9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1ck1hdGNoZXIgPSBncm91cFN0YWNrVG9wKClcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF0Y2hlci5wdXRPcigpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdXJNYXRjaGVyID0gbmV3IEdyb3VwTWF0Y2hlcigpXG4gICAgICAgICAgICBncm91cFN0YWNrLnB1c2goeyBtYXRjaGVyOiBjdXJNYXRjaGVyIH0pXG4gICAgICAgICAgICBzb3VyY2UucmVwbGFjZSgvXFwvXFwvXFwvfFxcL1xcKltcXHdcXFddKlxcKlxcLy9nLCAnJykucmVwbGFjZShncm91cFBhcnNlclJlZ0V4cCwgZ3JvdXBQYXJzZXIpXG4gICAgICAgICAgICBjdXJNYXRjaGVyID0gZ3JvdXBTdGFjay5wb3AoKS5tYXRjaGVyXG4gICAgICAgICAgICBjdXJNYXRjaGVyLnB1dEVuZChzb3VyY2UpXG4gICAgICAgICAgICByZXR1cm4gY3VyTWF0Y2hlclxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBpbGVyLm9wdGlvbi5tYXRoY2Vycy4ke3RoaXMua2V5fS5zb3VyY2UgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHN0cmluZ2ApXG4gICAgfVxufVxuXG5jbGFzcyBHcm91cE1hdGNoZXIgZXh0ZW5kcyBNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlXG4gICAgICAgIHRoaXMuX3RlbXBPciA9IG51bGxcbiAgICAgICAgdGhpcy5fdGVtcEFuZCA9IG51bGxcbiAgICAgICAgdGhpcy5fb3JGaXJzdENoaWxkID0gbnVsbFxuICAgIH1cblxuICAgIC8vIOaPkuWFpeWtkOe6p1xuICAgIHB1dENoaWxkIChtYXRjaGVyKSB7XG4gICAgICAgIGNvbnN0IHsgX3RlbXBPciwgX3RlbXBBbmQgfSA9IHRoaXNcbiAgICAgICAgaWYgKF90ZW1wT3IpIHsgLy8g5bey57uP5a2Y5Zyob3LoioLngrlcbiAgICAgICAgICAgIC8vIOe7p+e7rea3u+WKoGFuZOiKgueCuVxuICAgICAgICAgICAgaWYgKF90ZW1wQW5kKSB7XG4gICAgICAgICAgICAgICAgX3RlbXBBbmQubmV4dFNpYmxpbmcgPSBtYXRjaGVyXG4gICAgICAgICAgICAgICAgbWF0Y2hlci5wcmV2aW91c1NpYmxpbmcgPSBfdGVtcEFuZFxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBBbmQgPSBtYXRjaGVyXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBPciA9IF90ZW1wT3IubmV4dFNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZEZpcnN0Q2hpbGQ6IHRoaXMuX3RlbXBBbmQgPSBtYXRjaGVyLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29yRmlyc3RDaGlsZCA9IHRoaXMuX3RlbXBPciA9IHtcbiAgICAgICAgICAgICAgICBhbmRGaXJzdENoaWxkOiB0aGlzLl90ZW1wQW5kID0gbWF0Y2hlcixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVyLnBhcmVudE5vZGUgPSB0aGlzXG4gICAgICAgIHRoaXMuX3RlbXBBbmQuZ3JvdXBQYXJlbnQgPSB0aGlzLl90ZW1wT3IgLy8g5a2Q57qn6ZO+5Zue54i257qn5YiG57uEb3LvvIzlm57muq/nmoTkvb/nlKjkvb/nlKhcbiAgICB9XG5cbiAgICAvLyDmj5LlhaXmlrDnmoRvcuWIhuaUr1xuICAgIHB1dE9yICgpIHtcbiAgICAgICAgdGhpcy5fdGVtcEFuZCA9IG51bGxcbiAgICB9XG5cbiAgICAvLyDlrozmiJDoioLngrnliJvlu7pcbiAgICBwdXRFbmQgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2VcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RlbXBPclxuICAgICAgICBkZWxldGUgdGhpcy5fdGVtcEFuZFxuICAgIH1cblxuXG4gICAgc2NhbiAocGFyZW50UnVudGltZSkge1xuICAgICAgICBjb25zdCBvckNoaWxkID0gdGhpcy5fb3JGaXJzdENoaWxkXG4gICAgICAgIGNvbnN0IGFuZENoaWxkID0gb3JDaGlsZC5hbmRGaXJzdENoaWxkXG4gICAgICAgIGFuZENoaWxkLnNjYW4ocGFyZW50UnVudGltZS5jcmVhdGVDaGlsZCh0aGlzLCB7IG9yQ2hpbGQsIGFuZENoaWxkLCB0ZW1wQ2hpbGRzOiBbXSB9KSlcbiAgICB9XG5cbiAgICBtYXRjaFN1Y2Nlc3MgKGNoaWxkUnVudGltZSkge1xuICAgICAgICAvLyAoQXszfSBCezEsMn0gfCBBezJ9IEJ7Mn0pXG4gICAgICAgIC8vIOWtkOmhueaJq+aPj+aIkOWKn++8jOWImeWIpOaWreaYr+WQpuaYr+acgOWQjumhue+8jOaYr+WImei/m+ihjOS4i+S4gOS4quWIhumHj+aJq+aPj++8jOWQpuWImee7p+e7reS4i+S4gOS4quWtkOmhueaJq+aPj1xuXG4gICAgICAgIGNvbnN0IHRoaXNSdW50aW1lID0gY2hpbGRSdW50aW1lLnBhcmVudFxuICAgICAgICBsZXQgeyBhbmRDaGlsZCB9ID0gdGhpc1J1bnRpbWVcblxuICAgICAgICBpZiAodGhpc1J1bnRpbWUudGVtcExhc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpc1J1bnRpbWUudGVtcExhc3RDaGlsZC5uZXh0U2libGluZyA9IGNoaWxkUnVudGltZVxuICAgICAgICAgICAgY2hpbGRSdW50aW1lLnByZXZpb3VzU2libGluZyA9IHRoaXNSdW50aW1lLnRlbXBMYXN0Q2hpbGRcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnRlbXBMYXN0Q2hpbGQgPSBjaGlsZFJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnRlbXBMYXN0Q2hpbGQgPSB0aGlzUnVudGltZS50ZW1wRmlyc3RDaGlsZCA9IGNoaWxkUnVudGltZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5a2Y5Zyo5LiL5LiA5Liq5a2Q6aG5XG4gICAgICAgIGlmIChhbmRDaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgYW5kQ2hpbGQgPSB0aGlzUnVudGltZS5hbmRDaGlsZCA9IGFuZENoaWxkLm5leHRTaWJsaW5nXG4gICAgICAgICAgICBhbmRDaGlsZC5zY2FuKHRoaXNSdW50aW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1J1bnRpbWUudGVtcENoaWxkcy5wdXNoKHsgZmlyc3RDaGlsZDogdGhpc1J1bnRpbWUudGVtcEZpcnN0Q2hpbGQsIGxhc3RDaGlsZDogdGhpc1J1bnRpbWUudGVtcExhc3RDaGlsZCB9KVxuICAgICAgICAgICAgdGhpc1J1bnRpbWUudGVtcEZpcnN0Q2hpbGQgPSB0aGlzUnVudGltZS50ZW1wTGFzdENoaWxkID0gbnVsbFxuICAgICAgICAgICAgdGhpc1J1bnRpbWUubWF0Y2hzKytcbiAgICAgICAgICAgIGlmICh0aGlzUnVudGltZS5tYXRjaHMgPCB0aGlzLm4pIHtcbiAgICAgICAgICAgICAgICAvLyDnu6fnu63kuIvkuIDkuKrliIbph4/nmoTmiavmj49cbiAgICAgICAgICAgICAgICB0aGlzUnVudGltZS5vckNoaWxkID0gdGhpcy5fb3JGaXJzdENoaWxkXG4gICAgICAgICAgICAgICAgdGhpc1J1bnRpbWUuYW5kQ2hpbGQgPSB0aGlzUnVudGltZS5vckNoaWxkLmFuZEZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgICB0aGlzUnVudGltZS5hbmRDaGlsZC5zY2FuKHRoaXNSdW50aW1lKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyDlt7Lnu4/lrozmiJDkuobmiYDmnInnmoTmiavmj49cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXNSdW50aW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWF0Y2hGYWlsdXJlIChjaGlsZFJ1bnRpbWUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRoaXNSdW50aW1lID0gY2hpbGRSdW50aW1lLnBhcmVudFxuXG4gICAgICAgIC8vIOWtkOmhueWMuemFjeWksei0pVxuXG4gICAgICAgIC8vIOmDqOWIhuWMuemFjeaIkOWKn+S6hu+8jOeUqOS6juWIpOaWreaYr+WQpuWBnOatouaJq+aPj1xuICAgICAgICBjb25zdCBzb21lTWF0Y2hlZCA9IHRoaXNSdW50aW1lLnRlbXBGaXJzdENoaWxkICYmIHRoaXNSdW50aW1lLnRlbXBGaXJzdENoaWxkLmJJbmRleCA8IHRoaXNSdW50aW1lLnRlbXBMYXN0Q2hpbGQuZUluZGV4XG5cbiAgICAgICAgLy8g5Zue6YCA5b2T5YmN5omr5o+P57uT5p6cXG4gICAgICAgIGlmICh0aGlzUnVudGltZS50ZW1wRmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpc1J1bnRpbWUuc3IubW92ZVRvKHRoaXNSdW50aW1lLnRlbXBGaXJzdENoaWxkLmJJbmRleClcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnRlbXBGaXJzdENoaWxkID0gdGhpc1J1bnRpbWUudGVtcExhc3RDaGlsZCA9IG51bGxcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHRoaXNSdW50aW1lLm9yQ2hpbGQubmV4dFNpYmxpbmcgJiYgIWVycm9yLnN0b3ApIHtcbiAgICAgICAgICAgIC8vIOWBh+WmguaWsOeahOmUmeivr+aJq+aPj+eahOabtOi/nO+8jOWImeabtOaWsOmUmeivr1xuICAgICAgICAgICAgdGhpc1J1bnRpbWUuZXJyb3IgPSB0aGlzUnVudGltZS5lcnJvciAmJiB0aGlzUnVudGltZS5lcnJvci5iSW5kZXggPj0gZXJyb3IuYkluZGV4ID8gdGhpc1J1bnRpbWUuZXJyb3IgOiBlcnJvclxuXG4gICAgICAgICAgICB0aGlzUnVudGltZS5vckNoaWxkID0gdGhpc1J1bnRpbWUub3JDaGlsZC5uZXh0U2libGluZ1xuICAgICAgICAgICAgdGhpc1J1bnRpbWUuYW5kQ2hpbGQgPSB0aGlzUnVudGltZS5vckNoaWxkLmFuZEZpcnN0Q2hpbGRcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLmFuZENoaWxkLnNjYW4odGhpc1J1bnRpbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyDlv4XpgInpobnliIbph4/kuI3otrPvvIzliJnmraTmrKHljLnphY3lpLHotKVcbiAgICAgICAgICAgIC8vIOWBh+WmguWPr+mAiembhuW3sue7j+WtmOWcqOmDqOWIhuWMuemFje+8jOW5tuS4lOS4jeWFgeiuuOWbnumAgO+8jOWImeS8muinpuWPkXJlamVjdFxuICAgICAgICAgICAgaWYgKHRoaXNSdW50aW1lLm1hdGNocyA8IHRoaXMubSB8fCAoc29tZU1hdGNoZWQgJiYgZXJyb3Iuc3RvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzUnVudGltZS5lcnJvciA9IHRoaXNSdW50aW1lLmVycm9yICYmIHRoaXNSdW50aW1lLmVycm9yLmJJbmRleCA+PSBlcnJvci5iSW5kZXggPyB0aGlzUnVudGltZS5lcnJvciA6IGVycm9yXG4gICAgICAgICAgICAgICAgdGhpc1J1bnRpbWUuZXJyb3Iuc29tZU1hdGNoZWQgPSBzb21lTWF0Y2hlZFxuICAgICAgICAgICAgICAgIHRoaXNSdW50aW1lLnJlamVjdCh0aGlzUnVudGltZS5lcnJvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzUnVudGltZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNvbHZlICh0aGlzUnVudGltZSkge1xuICAgICAgICBsZXQgbm93TGFzdENoaWxkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpc1J1bnRpbWUudGVtcENoaWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaXJzdENoaWxkLCBsYXN0Q2hpbGQgfSA9IHRoaXNSdW50aW1lLnRlbXBDaGlsZHNbaV1cbiAgICAgICAgICAgIGlmIChub3dMYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub3dMYXN0Q2hpbGQubmV4dFNpYmxpbmcgPSBmaXJzdENoaWxkXG4gICAgICAgICAgICAgICAgbm93TGFzdENoaWxkID0gdGhpc1J1bnRpbWUubGFzdENoaWxkID0gbGFzdENoaWxkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNSdW50aW1lLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkXG4gICAgICAgICAgICAgICAgbm93TGFzdENoaWxkID0gdGhpc1J1bnRpbWUubGFzdENoaWxkID0gbGFzdENoaWxkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXNSdW50aW1lLnRlbXBDaGlsZHNcbiAgICAgICAgZGVsZXRlIHRoaXNSdW50aW1lLnRlbXBGaXJzdENoaWxkXG4gICAgICAgIGRlbGV0ZSB0aGlzUnVudGltZS50ZW1wTGFzdENoaWxkXG4gICAgICAgIGRlbGV0ZSB0aGlzUnVudGltZS5lcnJvclxuICAgICAgICB0aGlzUnVudGltZS5yZXNvbHZlKClcbiAgICB9XG59XG5cbmNsYXNzIExpbmtNYXRjaGVyIGV4dGVuZHMgTWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IgKGlkKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5faWQgPSBpZFxuICAgIH1cblxuICAgIHNjYW4gKHBhcmVudFJ1bnRpbWUpIHtcbiAgICAgICAgbWF0Y2hlcnNbdGhpcy5faWRdLnNjYW4ocGFyZW50UnVudGltZS5jcmVhdGVDaGlsZCh0aGlzKSlcbiAgICB9XG5cbiAgICBtYXRjaFN1Y2Nlc3MgKGNoaWxkUnVudGltZSkge1xuICAgICAgICBjb25zdCB0aGlzUnVudGltZSA9IGNoaWxkUnVudGltZS5wYXJlbnRcblxuICAgICAgICB0aGlzUnVudGltZS5hcHBlbmRDaGlsZChjaGlsZFJ1bnRpbWUpXG4gICAgICAgIHRoaXNSdW50aW1lLm1hdGNocysrXG5cbiAgICAgICAgaWYgKHRoaXNSdW50aW1lLm1hdGNocyA8IHRoaXMubikge1xuICAgICAgICAgICAgLy8g57un57ut5LiL5LiA5Liq5YiG6YeP55qE5omr5o+PXG4gICAgICAgICAgICBtYXRjaGVyc1t0aGlzLl9pZF0uc2Nhbih0aGlzUnVudGltZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOWujOaIkOaJq+aPj1xuICAgICAgICAgICAgdGhpc1J1bnRpbWUucmVzb2x2ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYXRjaEZhaWx1cmUgKGNoaWxkUnVudGltZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdGhpc1J1bnRpbWUgPSBjaGlsZFJ1bnRpbWUucGFyZW50XG5cbiAgICAgICAgaWYgKHRoaXNSdW50aW1lLm1hdGNocyA8IHRoaXMubSB8fCAoZXJyb3Iuc29tZU1hdGNoZWQgJiYgdGhpcy5zdG9wKSkge1xuICAgICAgICAgICAgLy8g5b2T5YmN5b+F6YCJ6aG55Yy56YWN5LiN6Laz77yM5YiZ5Yy56YWN5aSx6LSlXG4gICAgICAgICAgICB0aGlzUnVudGltZS5yZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzUnVudGltZS5yZXNvbHZlKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUnVsZU1hdGNoZXIgZXh0ZW5kcyBNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoaWQsIG1hdGNoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5faWQgPSBpZFxuICAgICAgICB0aGlzLl9tYXRjaCA9IG1hdGNoXG4gICAgICAgIG1hdGNoZXJzW2lkXSA9IHRoaXNcbiAgICB9XG5cbiAgICBzY2FuIChwYXJlbnRSdW50aW1lKSB7XG4gICAgICAgIGNvbnN0IHsgc3IgfSA9IHBhcmVudFJ1bnRpbWVcbiAgICAgICAgY29uc3QgYkluZGV4ID0gc3IuY2hJbmRleFxuICAgICAgICBjb25zdCB0aGlzUnVudGltZSA9IHBhcmVudFJ1bnRpbWUuY3JlYXRlQ2hpbGQodGhpcylcbiAgICAgICAgc3IuY3JlYXRlUmVjb3JkKClcbiAgICAgICAgaWYgKHRoaXMuX21hdGNoKHNyKSkge1xuICAgICAgICAgICAgc3IucmVtb3ZlUmVjb3JkKClcbiAgICAgICAgICAgIHRoaXNSdW50aW1lLnJlc29sdmUoYkluZGV4LCBzci5jaEluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Iucm9sbGJhY2soKVxuICAgICAgICAgICAgdGhpc1J1bnRpbWUucmVqZWN0KHsgYkluZGV4IH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdHJpbmdNYXRjaGVyIGV4dGVuZHMgTWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZVxuICAgIH1cblxuICAgIHNjYW4gKHBhcmVudFJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgeyBzciB9ID0gcGFyZW50UnVudGltZVxuICAgICAgICBjb25zdCB0aGlzUnVudGltZSA9IHBhcmVudFJ1bnRpbWUuY3JlYXRlQ2hpbGQodGhpcylcbiAgICAgICAgY29uc3QgYkluZGV4ID0gc3IuY2hJbmRleFxuICAgICAgICBsZXQgbWF0Y2hlZEVuZEluZGV4IC8vIOWPkeeUn+mUmeivr+eahOS4i+agh1xuICAgICAgICBjb25zdCB7IG0sIG4gfSA9IHRoaXNcblxuICAgICAgICBsZXQgaXNTdWNjZXNzID0gdHJ1ZVxuXG4gICAgICAgIC8vIOW/hemAiembhlxuICAgICAgICBzci5jcmVhdGVSZWNvcmQoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXRjaChzcikpIHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHNyLnJvbGxiYWNrKClcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkRW5kSW5kZXggPSBzci5jaEluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XG4gICAgICAgICAgICBzci5yZW1vdmVSZWNvcmQoKVxuICAgICAgICAgICAgLy8g5Y+v6YCJ6ZuGXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHNyLmNyZWF0ZVJlY29yZCgpXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXRjaChzcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Iucm9sbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNyLnJlbW92ZVJlY29yZCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1J1bnRpbWUucmVzb2x2ZShiSW5kZXgsIHNyLmNoSW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzUnVudGltZS5yZWplY3QoeyBiSW5kZXgsIG1hdGNoZWRFbmRJbmRleCwgc29tZU1hdGNoZWQ6IG1hdGNoZWRFbmRJbmRleCA+IGJJbmRleCB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21hdGNoIChzcikge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9zb3VyY2VcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxnID0gc291cmNlLmxlbmd0aDsgaSA8IGxnOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzci5yZWFkKCkgIT09IHNvdXJjZVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBSb290TWF0Y2hlciwgUnVsZU1hdGNoZXIsIEhvb2tNYXRjaGVyLFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/Compiler/Matchers.js\n");

/***/ }),

/***/ "./lib/Compiler/Runtime.js":
/*!*********************************!*\
  !*** ./lib/Compiler/Runtime.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar logger = __webpack_require__(/*! ./logger */ \"./lib/Compiler/logger.js\");\n\nvar PID = 0;\n\nvar Runtime =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Runtime(parent, matcher, extral) {\n    _classCallCheck(this, Runtime);\n\n    this.PID = PID++;\n    this.parent = parent;\n    this.matcher = matcher;\n    this.matchs = 0; // 成功匹配次数\n\n    if (parent) {\n      this.sr = parent.sr;\n    }\n\n    if (extral) {\n      Object.assign(this, extral);\n    }\n\n    logger.runtimeCreated(this);\n  }\n\n  _createClass(Runtime, [{\n    key: \"createChild\",\n    value: function createChild(matcher, extral) {\n      return new Runtime(this, matcher, extral);\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(childRuntime) {\n      if (this.lastChild) {\n        this.lastChild.nextSibling = childRuntime;\n        childRuntime.previousSibling = this.lastChild;\n        this.lastChild = childRuntime;\n      } else {\n        this.firstChild = this.lastChild = childRuntime;\n      }\n    } // 匹配器完成扫描\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(bIndex, eIndex) {\n      if (eIndex != null) {\n        this.bIndex = bIndex;\n        this.eIndex = eIndex;\n      } else if (this.firstChild) {\n        this.bIndex = this.firstChild.bIndex;\n        this.eIndex = this.lastChild.eIndex;\n      } else {\n        // 0次匹配的节点\n        this.bIndex = this.sr.chIndex;\n        this.eIndex = this.sr.chIndex;\n      }\n\n      logger.resolve(this); // 触发父级子项扫描成功\n\n      this.parent.matcher.matchSuccess(this);\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(error) {\n      if (error.stack) {\n        error.stack.push(this);\n      } else {\n        error.message = '匹配错误';\n        error.text = this.sr.text(error.bIndex);\n        error.stack = [this];\n      }\n\n      logger.reject(this, error);\n\n      if (error.someMatched && this.matcher.stop) {\n        error.stop = true;\n      }\n\n      this.parent.matcher.matchFailure(this, error);\n    }\n  }]);\n\n  return Runtime;\n}();\n\nRuntime.prototype.resolve = killRecursion(Runtime.prototype.resolve);\nRuntime.prototype.reject = killRecursion(Runtime.prototype.reject);\nmodule.exports = Runtime;\n\nfunction killRecursion(recursion) {\n  var scanIsRun = false;\n  var contextArgs;\n  var contextThat;\n  return function () {\n    contextArgs = arguments;\n    contextThat = this;\n\n    if (!scanIsRun) {\n      // console.info('startScan')\n      scanIsRun = true;\n\n      while (contextArgs) {\n        var args = contextArgs;\n        contextArgs = null;\n        recursion.apply(contextThat, args);\n      }\n\n      scanIsRun = false;\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvUnVudGltZS5qcz84MGMyIl0sIm5hbWVzIjpbImxvZ2dlciIsInJlcXVpcmUiLCJQSUQiLCJSdW50aW1lIiwicGFyZW50IiwibWF0Y2hlciIsImV4dHJhbCIsIm1hdGNocyIsInNyIiwiT2JqZWN0IiwiYXNzaWduIiwicnVudGltZUNyZWF0ZWQiLCJjaGlsZFJ1bnRpbWUiLCJsYXN0Q2hpbGQiLCJuZXh0U2libGluZyIsInByZXZpb3VzU2libGluZyIsImZpcnN0Q2hpbGQiLCJiSW5kZXgiLCJlSW5kZXgiLCJjaEluZGV4IiwicmVzb2x2ZSIsIm1hdGNoU3VjY2VzcyIsImVycm9yIiwic3RhY2siLCJwdXNoIiwibWVzc2FnZSIsInRleHQiLCJyZWplY3QiLCJzb21lTWF0Y2hlZCIsInN0b3AiLCJtYXRjaEZhaWx1cmUiLCJwcm90b3R5cGUiLCJraWxsUmVjdXJzaW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlY3Vyc2lvbiIsInNjYW5Jc1J1biIsImNvbnRleHRBcmdzIiwiY29udGV4dFRoYXQiLCJhcmd1bWVudHMiLCJhcmdzIiwiYXBwbHkiXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxJQUFNQSxNQUFNLEdBQUdDLG1CQUFPLENBQUMsMENBQUQsQ0FBdEI7O0FBRUEsSUFBSUMsR0FBRyxHQUFHLENBQVY7O0lBQ01DLE87Ozs7O0FBQ0YsbUJBQWFDLE1BQWIsRUFBcUJDLE9BQXJCLEVBQThCQyxNQUE5QixFQUFzQztBQUFBOztBQUNsQyxTQUFLSixHQUFMLEdBQVdBLEdBQUcsRUFBZDtBQUNBLFNBQUtFLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtDLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtFLE1BQUwsR0FBYyxDQUFkLENBSmtDLENBSWxCOztBQUVoQixRQUFJSCxNQUFKLEVBQVk7QUFDUixXQUFLSSxFQUFMLEdBQVVKLE1BQU0sQ0FBQ0ksRUFBakI7QUFDSDs7QUFFRCxRQUFJRixNQUFKLEVBQVk7QUFD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O0FBQ0EsYUFBT0MsV0FBUCxFQUFvQjtBQUNoQixZQUFNRyxJQUFJLEdBQUdILFdBQWI7QUFDQUEsbUJBQVcsR0FBRyxJQUFkO0FBQ0FGLGlCQUFTLENBQUNNLEtBQVYsQ0FBZ0JILFdBQWhCLEVBQTZCRSxJQUE3QjtBQUNIOztBQUNESixlQUFTLEdBQUcsS0FBWjtBQUNIO0FBQ0osR0FiRDtBQWNIIiwiZmlsZSI6Ii4vbGliL0NvbXBpbGVyL1J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJylcblxubGV0IFBJRCA9IDBcbmNsYXNzIFJ1bnRpbWUge1xuICAgIGNvbnN0cnVjdG9yIChwYXJlbnQsIG1hdGNoZXIsIGV4dHJhbCkge1xuICAgICAgICB0aGlzLlBJRCA9IFBJRCsrXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG4gICAgICAgIHRoaXMubWF0Y2hlciA9IG1hdGNoZXJcbiAgICAgICAgdGhpcy5tYXRjaHMgPSAwIC8vIOaIkOWKn+WMuemFjeasoeaVsFxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3IgPSBwYXJlbnQuc3JcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZXh0cmFsKVxuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLnJ1bnRpbWVDcmVhdGVkKHRoaXMpXG4gICAgfVxuXG4gICAgY3JlYXRlQ2hpbGQgKG1hdGNoZXIsIGV4dHJhbCkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bnRpbWUodGhpcywgbWF0Y2hlciwgZXh0cmFsKVxuICAgIH1cblxuICAgIGFwcGVuZENoaWxkIChjaGlsZFJ1bnRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZC5uZXh0U2libGluZyA9IGNoaWxkUnVudGltZVxuICAgICAgICAgICAgY2hpbGRSdW50aW1lLnByZXZpb3VzU2libGluZyA9IHRoaXMubGFzdENoaWxkXG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGNoaWxkUnVudGltZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZFJ1bnRpbWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOWMuemFjeWZqOWujOaIkOaJq+aPj1xuICAgIHJlc29sdmUgKGJJbmRleCwgZUluZGV4KSB7XG4gICAgICAgIGlmIChlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iSW5kZXggPSBiSW5kZXhcbiAgICAgICAgICAgIHRoaXMuZUluZGV4ID0gZUluZGV4XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmJJbmRleCA9IHRoaXMuZmlyc3RDaGlsZC5iSW5kZXhcbiAgICAgICAgICAgIHRoaXMuZUluZGV4ID0gdGhpcy5sYXN0Q2hpbGQuZUluZGV4XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAw5qyh5Yy56YWN55qE6IqC54K5XG4gICAgICAgICAgICB0aGlzLmJJbmRleCA9IHRoaXMuc3IuY2hJbmRleFxuICAgICAgICAgICAgdGhpcy5lSW5kZXggPSB0aGlzLnNyLmNoSW5kZXhcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIucmVzb2x2ZSh0aGlzKVxuXG4gICAgICAgIC8vIOinpuWPkeeItue6p+WtkOmhueaJq+aPj+aIkOWKn1xuICAgICAgICB0aGlzLnBhcmVudC5tYXRjaGVyLm1hdGNoU3VjY2Vzcyh0aGlzKVxuICAgIH1cblxuICAgIHJlamVjdCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICBlcnJvci5zdGFjay5wdXNoKHRoaXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gJ+WMuemFjemUmeivrydcbiAgICAgICAgICAgIGVycm9yLnRleHQgPSB0aGlzLnNyLnRleHQoZXJyb3IuYkluZGV4KVxuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBbIHRoaXMgXVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5yZWplY3QodGhpcywgZXJyb3IpXG5cbiAgICAgICAgaWYgKGVycm9yLnNvbWVNYXRjaGVkICYmIHRoaXMubWF0Y2hlci5zdG9wKSB7XG4gICAgICAgICAgICBlcnJvci5zdG9wID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJlbnQubWF0Y2hlci5tYXRjaEZhaWx1cmUodGhpcywgZXJyb3IpXG4gICAgfVxufVxuXG5SdW50aW1lLnByb3RvdHlwZS5yZXNvbHZlID0ga2lsbFJlY3Vyc2lvbihSdW50aW1lLnByb3RvdHlwZS5yZXNvbHZlKVxuUnVudGltZS5wcm90b3R5cGUucmVqZWN0ID0ga2lsbFJlY3Vyc2lvbihSdW50aW1lLnByb3RvdHlwZS5yZWplY3QpXG5cbm1vZHVsZS5leHBvcnRzID0gUnVudGltZVxuXG5mdW5jdGlvbiBraWxsUmVjdXJzaW9uIChyZWN1cnNpb24pIHtcbiAgICBsZXQgc2NhbklzUnVuID0gZmFsc2VcbiAgICBsZXQgY29udGV4dEFyZ3NcbiAgICBsZXQgY29udGV4dFRoYXRcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0QXJncyA9IGFyZ3VtZW50c1xuICAgICAgICBjb250ZXh0VGhhdCA9IHRoaXNcbiAgICAgICAgaWYgKCFzY2FuSXNSdW4pIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbygnc3RhcnRTY2FuJylcbiAgICAgICAgICAgIHNjYW5Jc1J1biA9IHRydWVcbiAgICAgICAgICAgIHdoaWxlIChjb250ZXh0QXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBjb250ZXh0QXJnc1xuICAgICAgICAgICAgICAgIGNvbnRleHRBcmdzID0gbnVsbFxuICAgICAgICAgICAgICAgIHJlY3Vyc2lvbi5hcHBseShjb250ZXh0VGhhdCwgYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjYW5Jc1J1biA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/Runtime.js\n");

/***/ }),

/***/ "./lib/Compiler/dataParser/context.js":
/*!********************************************!*\
  !*** ./lib/Compiler/dataParser/context.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvZGF0YVBhcnNlci9jb250ZXh0LmpzPzEyMDUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUFBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixFQUFqQiIsImZpbGUiOiIuL2xpYi9Db21waWxlci9kYXRhUGFyc2VyL2NvbnRleHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHt9XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/dataParser/context.js\n");

/***/ }),

/***/ "./lib/Compiler/dataParser/parsers/document.js":
/*!*****************************************************!*\
  !*** ./lib/Compiler/dataParser/parsers/document.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var parserRegexp = [/^\\/\\/\\/\\s+/, // beginToken\n/(?:([-+?!])\\s+)?/, // matchFlag\n/((\\[)[\\w,\\s]+\\]|[\\w,]+)\\s+/, // matchTypes, isMulti\n/(.+)/ // matchDescription\n].map(function (item) {\n  return item.source;\n}).join('');\nvar shortTypes = {\n  n: 'null',\n  s: 'string',\n  l: 'long',\n  f: 'float',\n  b: 'boolean',\n  a: 'array',\n  m: 'map'\n};\n\nmodule.exports = function documentParser(document) {\n  var flag; // 文档操作类型：{'+':'新增的', '-':'删除的', '?':'存在疑问的', '!':'建议修改的'}\n\n  var types; // 字段数据类型\n\n  var description; // 字段描述\n\n  document.replace(parserRegexp, function (all, matchFlag, matchTypes, isMulti, matchDescription) {\n    flag = matchFlag;\n    types = (isMulti ? matchTypes.slice(1, -1) : matchTypes).split(/,\\s*/).map(function (el) {\n      return shortTypes[el] || el;\n    });\n    description = matchDescription.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n  });\n  return types ? ['[\"', types.join('\", \"'), '\"], \"', description, '\", \"', flag, '\"'].join('') : null;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvZGF0YVBhcnNlci9wYXJzZXJzL2RvY3VtZW50LmpzP2JkNDYiXSwibmFtZXMiOlsicGFyc2VyUmVnZXhwIiwibWFwIiwiaXRlbSIsInNvdXJjZSIsImpvaW4iLCJzaG9ydFR5cGVzIiwibiIsInMiLCJsIiwiZiIsImIiLCJhIiwibSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudFBhcnNlciIsImRvY3VtZW50IiwiZmxhZyIsInR5cGVzIiwiZGVzY3JpcHRpb24iLCJyZXBsYWNlIiwiYWxsIiwibWF0Y2hGbGFnIiwibWF0Y2hUeXBlcyIsImlzTXVsdGkiLCJtYXRjaERlc2NyaXB0aW9uIiwic2xpY2UiLCJzcGxpdCIsImVsIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFNQSxZQUFZLEdBQUcsQ0FDakIsWUFEaUIsRUFDSDtBQUNkLGtCQUZpQixFQUVHO0FBQ3BCLDRCQUhpQixFQUdhO0FBQzlCLE1BSmlCLENBSVQ7QUFKUyxFQUtuQkMsR0FMbUIsQ0FLZixVQUFBQyxJQUFJO0FBQUEsU0FBSUEsSUFBSSxDQUFDQyxNQUFUO0FBQUEsQ0FMVyxFQUtNQyxJQUxOLENBS1csRUFMWCxDQUFyQjtBQU1BLElBQU1DLFVBQVUsR0FBRztBQUFFQyxHQUFDLEVBQUUsTUFBTDtBQUFhQyxHQUFDLEVBQUUsUUFBaEI7QUFBMEJDLEdBQUMsRUFBRSxNQUE3QjtBQUFxQ0MsR0FBQyxFQUFFLE9BQXhDO0FBQWlEQyxHQUFDLEVBQUUsU0FBcEQ7QUFBK0RDLEdBQUMsRUFBRSxPQUFsRTtBQUEyRUMsR0FBQyxFQUFFO0FBQTlFLENBQW5COztBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsU0FBU0MsY0FBVCxDQUF5QkMsUUFBekIsRUFBbUM7QUFDaEQsTUFBSUMsSUFBSixDQURnRCxDQUN2Qzs7QUFDVCxNQUFJQyxLQUFKLENBRmdELENBRXRDOztBQUNWLE1BQUlDLFdBQUosQ0FIZ0QsQ0FHaEM7O0FBRWhCSCxVQUFRLENBQUNJLE9BQVQsQ0FBaUJwQixZQUFqQixFQUErQixVQUFDcUIsR0FBRCxFQUFNQyxTQUFOLEVBQWlCQyxVQUFqQixFQUE2QkMsT0FBN0IsRUFBc0NDLGdCQUF0QyxFQUEyRDtBQUN0RlIsUUFBSSxHQUFHSyxTQUFQO0FBQ0FKLFNBQUssR0FBRyxDQUFDTSxPQUFPLEdBQUdELFVBQVUsQ0FBQ0csS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFDLENBQXJCLENBQUgsR0FBNkJILFVBQXJDLEVBQWlESSxLQUFqRCxDQUF1RCxNQUF2RCxFQUErRDFCLEdBQS9ELENBQW1FLFVBQUEyQixFQUFFO0FBQUEsYUFBSXZCLFVBQVUsQ0FBQ3VCLEVBQUQsQ0FBVixJQUFrQkEsRUFBdEI7QUFBQSxLQUFyRSxDQUFSO0FBQ0FULGVBQVcsR0FBR00sZ0JBQWdCLENBQUNMLE9BQWpCLENBQXlCLEtBQXpCLEVBQWdDLE1BQWhDLEVBQXdDQSxPQUF4QyxDQUFnRCxJQUFoRCxFQUFzRCxLQUF0RCxDQUFkO0FBQ0gsR0FKRDtBQU1BLFNBQU9GLEtBQUssR0FBRyxDQUFFLElBQUYsRUFBUUEsS0FBSyxDQUFDZCxJQUFOLENBQVcsTUFBWCxDQUFSLEVBQTRCLE9BQTVCLEVBQXFDZSxXQUFyQyxFQUFrRCxNQUFsRCxFQUEwREYsSUFBMUQsRUFBZ0UsR0FBaEUsRUFBc0ViLElBQXRFLENBQTJFLEVBQTNFLENBQUgsR0FBb0YsSUFBaEc7QUFDSCxDQVpEIiwiZmlsZSI6Ii4vbGliL0NvbXBpbGVyL2RhdGFQYXJzZXIvcGFyc2Vycy9kb2N1bWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhcnNlclJlZ2V4cCA9IFtcbiAgICAvXlxcL1xcL1xcL1xccysvLCAvLyBiZWdpblRva2VuXG4gICAgLyg/OihbLSs/IV0pXFxzKyk/LywgLy8gbWF0Y2hGbGFnXG4gICAgLygoXFxbKVtcXHcsXFxzXStcXF18W1xcdyxdKylcXHMrLywgLy8gbWF0Y2hUeXBlcywgaXNNdWx0aVxuICAgIC8oLispLywgLy8gbWF0Y2hEZXNjcmlwdGlvblxuXS5tYXAoaXRlbSA9PiBpdGVtLnNvdXJjZSkuam9pbignJylcbmNvbnN0IHNob3J0VHlwZXMgPSB7IG46ICdudWxsJywgczogJ3N0cmluZycsIGw6ICdsb25nJywgZjogJ2Zsb2F0JywgYjogJ2Jvb2xlYW4nLCBhOiAnYXJyYXknLCBtOiAnbWFwJyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG9jdW1lbnRQYXJzZXIgKGRvY3VtZW50KSB7XG4gICAgbGV0IGZsYWcgLy8g5paH5qGj5pON5L2c57G75Z6L77yaeycrJzon5paw5aKe55qEJywgJy0nOifliKDpmaTnmoQnLCAnPyc6J+WtmOWcqOeWkemXrueahCcsICchJzon5bu66K6u5L+u5pS555qEJ31cbiAgICBsZXQgdHlwZXMgLy8g5a2X5q615pWw5o2u57G75Z6LXG4gICAgbGV0IGRlc2NyaXB0aW9uIC8vIOWtl+auteaPj+i/sFxuXG4gICAgZG9jdW1lbnQucmVwbGFjZShwYXJzZXJSZWdleHAsIChhbGwsIG1hdGNoRmxhZywgbWF0Y2hUeXBlcywgaXNNdWx0aSwgbWF0Y2hEZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICBmbGFnID0gbWF0Y2hGbGFnXG4gICAgICAgIHR5cGVzID0gKGlzTXVsdGkgPyBtYXRjaFR5cGVzLnNsaWNlKDEsIC0xKSA6IG1hdGNoVHlwZXMpLnNwbGl0KC8sXFxzKi8pLm1hcChlbCA9PiBzaG9ydFR5cGVzW2VsXSB8fCBlbClcbiAgICAgICAgZGVzY3JpcHRpb24gPSBtYXRjaERlc2NyaXB0aW9uLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG4gICAgfSlcblxuICAgIHJldHVybiB0eXBlcyA/IFsgJ1tcIicsIHR5cGVzLmpvaW4oJ1wiLCBcIicpLCAnXCJdLCBcIicsIGRlc2NyaXB0aW9uLCAnXCIsIFwiJywgZmxhZywgJ1wiJyBdLmpvaW4oJycpIDogbnVsbFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/Compiler/dataParser/parsers/document.js\n");

/***/ }),

/***/ "./lib/Compiler/dataParser/parsers/value.js":
/*!**************************************************!*\
  !*** ./lib/Compiler/dataParser/parsers/value.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nvar parserContext = __webpack_require__(/*! ../context */ \"./lib/Compiler/dataParser/context.js\");\n\nvar parsers = [stepNumParser, thisFieldParser, randomValueParser, mockValueParser];\nObject.assign(parserContext, {\n  $mock: {\n    stepNum: function stepNum(num, step) {\n      return num + step;\n    },\n    randomValue: function randomValue(values) {\n      return values[Math.floor(Math.random() * values.length)];\n    }\n  }\n});\n\nmodule.exports = function valueParser(code) {\n  for (var i = 0, lg = parsers.length; i < lg; i++) {\n    var result = parsers[i](code); // 返回对象，则进行转化操作\n\n    if (_typeof(result) === 'object') {\n      var newCode = result.newCode,\n          isBreak = result.isBreak;\n\n      if (newCode !== undefined) {\n        code = newCode;\n      }\n\n      if (isBreak) {\n        break;\n      }\n    }\n  }\n\n  return code;\n};\n\nfunction stepNumParser(code) {\n  var matches = code.match(/(\\d+)(\\+\\+)/);\n\n  if (!matches) {\n    return;\n  }\n\n  var _matches = _slicedToArray(matches, 3),\n      num = _matches[1],\n      type = _matches[2];\n\n  return {\n    newCode: \"$mock.stepNum(\".concat(num, \", \").concat(type === '++' ? 1 : -1, \")\"),\n    isBreak: true\n  };\n}\n\nfunction thisFieldParser(code) {\n  // 跳过所有的字符串内容\n  var newCode = code.replace(/(?:'(?:[^']|\\\\\\\\|\\\\')')|(?:\"(?:[^\"]|\\\\\\\\|\\\\\")\")|(?:`(?:[^`]|\\\\\\\\|\\\\`)`)|(@)/g, function (all, thisSymbol) {\n    if (thisSymbol) {\n      return 'this.';\n    }\n\n    return all;\n  });\n\n  if (code === newCode) {\n    return;\n  }\n\n  return {\n    newCode: newCode\n  };\n}\n\nfunction randomValueParser(code) {\n  var matches = code.match(/(.+)?\\?\\?/);\n\n  if (!matches) {\n    return;\n  }\n\n  var _matches2 = _slicedToArray(matches, 2),\n      expression = _matches2[1];\n\n  return {\n    newCode: \"$mock.randomValue(\".concat(expression, \")\"),\n    isBreak: true\n  };\n}\n\nfunction mockValueParser(code) {// const matches = code.match(/^#\\w+[.\\w]+/)\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvZGF0YVBhcnNlci9wYXJzZXJzL3ZhbHVlLmpzP2I4MTEiXSwibmFtZXMiOlsicGFyc2VyQ29udGV4dCIsInJlcXVpcmUiLCJwYXJzZXJzIiwic3RlcE51bVBhcnNlciIsInRoaXNGaWVsZFBhcnNlciIsInJhbmRvbVZhbHVlUGFyc2VyIiwibW9ja1ZhbHVlUGFyc2VyIiwiT2JqZWN0IiwiYXNzaWduIiwiJG1vY2siLCJzdGVwTnVtIiwibnVtIiwic3RlcCIsInJhbmRvbVZhbHVlIiwidmFsdWVzIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyIsInZhbHVlUGFyc2VyIiwiY29kZSIsImkiLCJsZyIsInJlc3VsdCIsIm5ld0NvZGUiLCJpc0JyZWFrIiwidW5kZWZpbmVkIiwibWF0Y2hlcyIsIm1hdGNoIiwidHlwZSIsInJlcGxhY2UiLCJhbGwiLCJ0aGlzU3ltYm9sIiwiZXhwcmVzc2lvbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQU1BLGFBQWEsR0FBR0MsbUJBQU8sQ0FBQyx3REFBRCxDQUE3Qjs7QUFFQSxJQUFNQyxPQUFPLEdBQUcsQ0FDWkMsYUFEWSxFQUVaQyxlQUZZLEVBR1pDLGlCQUhZLEVBSVpDLGVBSlksQ0FBaEI7QUFPQUMsTUFBTSxDQUFDQyxNQUFQLENBQWNSLGFBQWQsRUFBNkI7QUFDekJTLE9BQUssRUFBRTtBQUNIQyxXQURHLG1CQUNNQyxHQUROLEVBQ1dDLElBRFgsRUFDaUI7QUFDaEIsYUFBT0QsR0FBRyxHQUFHQyxJQUFiO0FBQ0gsS0FIRTtBQUlIQyxlQUpHLHVCQUlVQyxNQUpWLEVBSWtCO0FBQ2pCLGFBQU9BLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsTUFBTCxLQUFnQkgsTUFBTSxDQUFDSSxNQUFsQyxDQUFELENBQWI7QUFDSDtBQU5FO0FBRGtCLENBQTdCOztBQVdBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsU0FBU0MsV0FBVCxDQUFzQkMsSUFBdEIsRUFBNEI7QUFDekMsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBUixFQUFXQyxFQUFFLEdBQUd0QixPQUFPLENBQUNnQixNQUE3QixFQUFxQ0ssQ0FBQyxHQUFHQyxFQUF6QyxFQUE2Q0QsQ0FBQyxFQUE5QyxFQUFrRDtBQUM5QyxRQUFNRSxNQUFNLEdBQUd2QixPQUFPLENBQUNxQixDQUFELENBQVAsQ0FBV0QsSUFBWCxDQUFmLENBRDhDLENBRzlDOztBQUNBLFFBQUksUUFBT0csTUFBUCxNQUFrQixRQUF0QixFQUFnQztBQUFBLFVBQ3BCQyxPQURvQixHQUNDRCxNQURELENBQ3BCQyxPQURvQjtBQUFBLFVBQ1hDLE9BRFcsR0FDQ0YsTUFERCxDQUNYRSxPQURXOztBQUU1QixVQUFJRCxPQUFPLEtBQUtFLFNBQWhCLEVBQTJCO0FBQ3ZCTixZQUFJLEdBQUdJLE9BQVA7QUFDSDs7QUFDRCxVQUFJQyxPQUFKLEVBQWE7QUFDVDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxTQUFPTCxJQUFQO0FBQ0gsQ0FqQkQ7O0FBb0JBLFNBQVNuQixhQUFULENBQXdCbUIsSUFBeEIsRUFBOEI7QUFDMUIsTUFBTU8sT0FBTyxHQUFHUCxJQUFJLENBQUNRLEtBQUwsQ0FBVyxhQUFYLENBQWhCOztBQUNBLE1BQUksQ0FBQ0QsT0FBTCxFQUFjO0FBQ1Y7QUFDSDs7QUFKeUIsZ0NBS0ZBLE9BTEU7QUFBQSxNQUtoQmxCLEdBTGdCO0FBQUEsTUFLWG9CLElBTFc7O0FBTTFCLFNBQU87QUFBRUwsV0FBTywwQkFBbUJmLEdBQW5CLGVBQTJCb0IsSUFBSSxLQUFLLElBQVQsR0FBZ0IsQ0FBaEIsR0FBb0IsQ0FBQyxDQUFoRCxNQUFUO0FBQStESixXQUFPLEVBQUU7QUFBeEUsR0FBUDtBQUNIOztBQUVELFNBQVN2QixlQUFULENBQTBCa0IsSUFBMUIsRUFBZ0M7QUFDNUI7QUFDQSxNQUFNSSxPQUFPLEdBQUdKLElBQUksQ0FBQ1UsT0FBTCxDQUFhLDhFQUFiLEVBQTZGLFVBQUNDLEdBQUQsRUFBTUMsVUFBTixFQUFxQjtBQUM5SCxRQUFJQSxVQUFKLEVBQWdCO0FBQ1osYUFBTyxPQUFQO0FBQ0g7O0FBQ0QsV0FBT0QsR0FBUDtBQUNILEdBTGUsQ0FBaEI7O0FBTUEsTUFBSVgsSUFBSSxLQUFLSSxPQUFiLEVBQXNCO0FBQ2xCO0FBQ0g7O0FBQ0QsU0FBTztBQUFFQSxXQUFPLEVBQVBBO0FBQUYsR0FBUDtBQUNIOztBQUVELFNBQVNyQixpQkFBVCxDQUE0QmlCLElBQTVCLEVBQWtDO0FBQzlCLE1BQU1PLE9BQU8sR0FBR1AsSUFBSSxDQUFDUSxLQUFMLENBQVcsV0FBWCxDQUFoQjs7QUFDQSxNQUFJLENBQUNELE9BQUwsRUFBYztBQUNWO0FBQ0g7O0FBSjZCLGlDQUtMQSxPQUxLO0FBQUEsTUFLcEJNLFVBTG9COztBQU05QixTQUFPO0FBQUVULFdBQU8sOEJBQXVCUyxVQUF2QixNQUFUO0FBQStDUixXQUFPLEVBQUU7QUFBeEQsR0FBUDtBQUNIOztBQUVELFNBQVNyQixlQUFULENBQTBCZ0IsSUFBMUIsRUFBZ0MsQ0FDNUI7QUFDSCIsImZpbGUiOiIuL2xpYi9Db21waWxlci9kYXRhUGFyc2VyL3BhcnNlcnMvdmFsdWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXJzZXJDb250ZXh0ID0gcmVxdWlyZSgnLi4vY29udGV4dCcpXG5cbmNvbnN0IHBhcnNlcnMgPSBbXG4gICAgc3RlcE51bVBhcnNlcixcbiAgICB0aGlzRmllbGRQYXJzZXIsXG4gICAgcmFuZG9tVmFsdWVQYXJzZXIsXG4gICAgbW9ja1ZhbHVlUGFyc2VyLFxuXVxuXG5PYmplY3QuYXNzaWduKHBhcnNlckNvbnRleHQsIHtcbiAgICAkbW9jazoge1xuICAgICAgICBzdGVwTnVtIChudW0sIHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBudW0gKyBzdGVwXG4gICAgICAgIH0sXG4gICAgICAgIHJhbmRvbVZhbHVlICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFsdWVzLmxlbmd0aCldXG4gICAgICAgIH0sXG4gICAgfSxcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsdWVQYXJzZXIgKGNvZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGcgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGxnOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2Vyc1tpXShjb2RlKVxuXG4gICAgICAgIC8vIOi/lOWbnuWvueixoe+8jOWImei/m+ihjOi9rOWMluaTjeS9nFxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmV3Q29kZSwgaXNCcmVhayB9ID0gcmVzdWx0XG4gICAgICAgICAgICBpZiAobmV3Q29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IG5ld0NvZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JyZWFrKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2RlXG59XG5cblxuZnVuY3Rpb24gc3RlcE51bVBhcnNlciAoY29kZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBjb2RlLm1hdGNoKC8oXFxkKykoXFwrXFwrKS8pXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBbICwgbnVtLCB0eXBlIF0gPSBtYXRjaGVzXG4gICAgcmV0dXJuIHsgbmV3Q29kZTogYCRtb2NrLnN0ZXBOdW0oJHtudW19LCAke3R5cGUgPT09ICcrKycgPyAxIDogLTF9KWAsIGlzQnJlYWs6IHRydWUgfVxufVxuXG5mdW5jdGlvbiB0aGlzRmllbGRQYXJzZXIgKGNvZGUpIHtcbiAgICAvLyDot7Pov4fmiYDmnInnmoTlrZfnrKbkuLLlhoXlrrlcbiAgICBjb25zdCBuZXdDb2RlID0gY29kZS5yZXBsYWNlKC8oPzonKD86W14nXXxcXFxcXFxcXHxcXFxcJyknKXwoPzpcIig/OlteXCJdfFxcXFxcXFxcfFxcXFxcIilcIil8KD86YCg/OlteYF18XFxcXFxcXFx8XFxcXGApYCl8KEApL2csIChhbGwsIHRoaXNTeW1ib2wpID0+IHtcbiAgICAgICAgaWYgKHRoaXNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiAndGhpcy4nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbFxuICAgIH0pXG4gICAgaWYgKGNvZGUgPT09IG5ld0NvZGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiB7IG5ld0NvZGUgfVxufVxuXG5mdW5jdGlvbiByYW5kb21WYWx1ZVBhcnNlciAoY29kZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBjb2RlLm1hdGNoKC8oLispP1xcP1xcPy8pXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBbICwgZXhwcmVzc2lvbiBdID0gbWF0Y2hlc1xuICAgIHJldHVybiB7IG5ld0NvZGU6IGAkbW9jay5yYW5kb21WYWx1ZSgke2V4cHJlc3Npb259KWAsIGlzQnJlYWs6IHRydWUgfVxufVxuXG5mdW5jdGlvbiBtb2NrVmFsdWVQYXJzZXIgKGNvZGUpIHtcbiAgICAvLyBjb25zdCBtYXRjaGVzID0gY29kZS5tYXRjaCgvXiNcXHcrWy5cXHddKy8pXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/dataParser/parsers/value.js\n");

/***/ }),

/***/ "./lib/Compiler/index.js":
/*!*******************************!*\
  !*** ./lib/Compiler/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _require = __webpack_require__(/*! ./Matchers */ \"./lib/Compiler/Matchers.js\"),\n    RuleMatcher = _require.RuleMatcher,\n    HookMatcher = _require.HookMatcher;\n\nvar scanner = __webpack_require__(/*! ./scanner */ \"./lib/Compiler/scanner.js\");\n\nvar interpreter = __webpack_require__(/*! ./interpreter */ \"./lib/Compiler/interpreter.js\");\n\nvar Compiler =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Compiler(_ref) {\n    var matchers = _ref.matchers;\n\n    _classCallCheck(this, Compiler);\n\n    this._matchers = {};\n\n    this._initSystemMatchers();\n\n    this._initCustomMatchers(matchers);\n  }\n\n  _createClass(Compiler, [{\n    key: \"compile\",\n    value: function compile(code) {\n      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n      var sr = scanner(code);\n      var mainMatcher = this._matchers[id];\n\n      try {\n        while (sr.notEOF()) {\n          sr.use(mainMatcher);\n        }\n\n        var tree = sr.tree();\n\n        var _code = tree.code();\n\n        var execute = interpreter.use(_code);\n        return {\n          tree: tree,\n          code: _code,\n          execute: execute\n        };\n      } catch (error) {\n        return {\n          error: error,\n          execute: function execute() {\n            return new Promise(function (resolve) {\n              resolve({\n                $error: error\n              });\n            });\n          }\n        };\n      }\n    }\n  }, {\n    key: \"_initSystemMatchers\",\n    value: function _initSystemMatchers() {\n      var matchers = this._matchers;\n      [['w', function (sr) {\n        return /\\w/.test(sr.read());\n      }], ['W', function (sr) {\n        return /\\W/.test(sr.read());\n      }], ['d', function (sr) {\n        return /\\d/.test(sr.read());\n      }], ['D', function (sr) {\n        return /\\D/.test(sr.read());\n      }], ['s', function (sr) {\n        return /\\s/.test(sr.read());\n      }], ['S', function (sr) {\n        return /\\S/.test(sr.read());\n      }], ['eol', function (sr) {\n        return sr.read() === sr.EOL;\n      }], ['.', function (sr) {\n        return sr.read() !== sr.EOL;\n      }]].forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            id = _ref3[0],\n            pattern = _ref3[1];\n\n        matchers[id] = new RuleMatcher(id, pattern);\n      });\n    }\n  }, {\n    key: \"_initCustomMatchers\",\n    value: function _initCustomMatchers(matcherOptions) {\n      var matchers = this._matchers;\n\n      for (var id in matcherOptions) {\n        matchers[id] = new HookMatcher(id, matcherOptions[id], this);\n      }\n    }\n  }]);\n\n  return Compiler;\n}();\n\nmodule.exports = Compiler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvaW5kZXguanM/OWRjNCJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiUnVsZU1hdGNoZXIiLCJIb29rTWF0Y2hlciIsInNjYW5uZXIiLCJpbnRlcnByZXRlciIsIkNvbXBpbGVyIiwibWF0Y2hlcnMiLCJfbWF0Y2hlcnMiLCJfaW5pdFN5c3RlbU1hdGNoZXJzIiwiX2luaXRDdXN0b21NYXRjaGVycyIsImNvZGUiLCJpZCIsInNyIiwibWFpbk1hdGNoZXIiLCJub3RFT0YiLCJ1c2UiLCJ0cmVlIiwiZXhlY3V0ZSIsImVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCIkZXJyb3IiLCJ0ZXN0IiwicmVhZCIsIkVPTCIsImZvckVhY2giLCJwYXR0ZXJuIiwibWF0Y2hlck9wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7ZUFDcUNBLG1CQUFPLENBQUMsOENBQUQsQztJQUFwQ0MsVyxZQUFBQSxXO0lBQWFDLFcsWUFBQUEsVzs7QUFDckIsSUFBTUMsT0FBTyxHQUFHSCxtQkFBTyxDQUFDLDRDQUFELENBQXZCOztBQUNBLElBQU1JLFdBQVcsR0FBR0osbUJBQU8sQ0FBQyxvREFBRCxDQUEzQjs7SUFFTUssUTs7Ozs7QUFDRiwwQkFBMkI7QUFBQSxRQUFaQyxRQUFZLFFBQVpBLFFBQVk7O0FBQUE7O0FBQ3ZCLFNBQUtDLFNBQUwsR0FBaUIsRUFBakI7O0FBQ0EsU0FBS0MsbUJBQUw7O0FBQ0EsU0FBS0MsbUJBQUwsQ0FBeUJILFFBQXpCO0FBQ0g7Ozs7NEJBRVFJLEksRUFBbUI7QUFBQSxVQUFiQyxFQUFhLHVFQUFSLE1BQVE7QUFDeEIsVUFBTUMsRUFBRSxHQUFHVCxPQUFPLENBQUNPLElBQUQsQ0FBbEI7QUFDQSxVQUFNRyxXQUFXLEdBQUcsS0FBS04sU0FBTCxDQUFlSSxFQUFmLENBQXBCOztBQUNBLFVBQUk7QUFDQSxlQUFPQyxFQUFFLENBQUNFLE1BQUgsRUFBUCxFQUFvQjtBQUNoQkYsWUFBRSxDQUFDRyxHQUFILENBQU9GLFdBQVA7QUFDSDs7QUFFRCxZQUFNRyxJQUFJLEdBQUdKLEVBQUUsQ0FBQ0ksSUFBSCxFQUFiOztBQUNBLFlBQU1OLEtBQUksR0FBR00sSUFBSSxDQUFDTixJQUFMLEVBQWI7O0FBQ0EsWUFBTU8sT0FBTyxHQUFHYixXQUFXLENBQUNXLEdBQVosQ0FBZ0JMLEtBQWhCLENBQWhCO0FBRUEsZUFBTztBQUFFTSxjQUFJLEVBQUpBLElBQUY7QUFBUU4sY0FBSSxFQUFKQSxLQUFSO0FBQWNPLGlCQUFPLEVBQVBBO0FBQWQsU0FBUDtBQUNILE9BVkQsQ0FVRSxPQUFPQyxLQUFQLEVBQWM7QUFDWixlQUFPO0FBQ0hBLGVBQUssRUFBTEEsS0FERztBQUVIRCxpQkFGRyxxQkFFUTtBQUNQLG1CQUFPLElBQUlFLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQWE7QUFDNUJBLHFCQUFPLENBQUM7QUFDSkMsc0JBQU0sRUFBRUg7QUFESixlQUFELENBQVA7QUFHSCxhQUpNLENBQVA7QUFLSDtBQVJFLFNBQVA7QUFVSDtBQUNKOzs7MENBRXNCO0FBQ25CLFVBQU1aLFFBQVEsR0FBRyxLQUFLQyxTQUF0QjtBQUNDLE9BQ0csQ0FBRSxHQUFGLEVBQU8sVUFBQUssRUFBRTtBQUFBLGVBQUksS0FBS1UsSUFBTCxDQUFVVixFQUFFLENBQUNXLElBQUgsRUFBVixDQUFKO0FBQUEsT0FBVCxDQURILEVBRUcsQ0FBRSxHQUFGLEVBQU8sVUFBQVgsRUFBRTtBQUFBLGVBQUksS0FBS1UsSUFBTCxDQUFVVixFQUFFLENBQUNXLElBQUgsRUFBVixDQUFKO0FBQUEsT0FBVCxDQUZILEVBR0csQ0FBRSxHQUFGLEVBQU8sVUFBQVgsRUFBRTtBQUFBLGVBQUksS0FBS1UsSUFBTCxDQUFVVixFQUFFLENBQUNXLElBQUgsRUFBVixDQUFKO0FBQUEsT0FBVCxDQUhILEVBSUcsQ0FBRSxHQUFGLEVBQU8sVUFBQVgsRUFBRTtBQUFBLGVBQUksS0FBS1UsSUFBTCxDQUFVVixFQUFFLENBQUNXLElBQUgsRUFBVixDQUFKO0FBQUEsT0FBVCxDQUpILEVBS0csQ0FBRSxHQUFGLEVBQU8sVUFBQVgsRUFBRTtBQUFBLGVBQUksS0FBS1UsSUFBTCxDQUFVVixFQUFFLENBQUNXLElBQUgsRUFBVixDQUFKO0FBQUEsT0FBVCxDQUxILEVBTUcsQ0FBRSxHQUFGLEVBQU8sVUFBQVgsRUFBRTtBQUFBLGVBQUksS0FBS1UsSUFBTCxDQUFVVixFQUFFLENBQUNXLElBQUgsRUFBVixDQUFKO0FBQUEsT0FBVCxDQU5ILEVBT0csQ0FBRSxLQUFGLEVBQVMsVUFBQVgsRUFBRTtBQUFBLGVBQUlBLEVBQUUsQ0FBQ1csSUFBSCxPQUFjWCxFQUFFLENBQUNZLEdBQXJCO0FBQUEsT0FBWCxDQVBILEVBUUcsQ0FBRSxHQUFGLEVBQU8sVUFBQVosRUFBRTtBQUFBLGVBQUlBLEVBQUUsQ0FBQ1csSUFBSCxPQUFjWCxFQUFFLENBQUNZLEdBQXJCO0FBQUEsT0FBVCxDQVJILEVBU0NDLE9BVEQsQ0FTUyxpQkFBcUI7QUFBQTtBQUFBLFlBQWxCZCxFQUFrQjtBQUFBLFlBQWRlLE9BQWM7O0FBQzNCcEIsZ0JBQVEsQ0FBQ0ssRUFBRCxDQUFSLEdBQWUsSUFBSVYsV0FBSixDQUFnQlUsRUFBaEIsRUFBb0JlLE9BQXBCLENBQWY7QUFDSCxPQVhBO0FBWUo7Ozt3Q0FFb0JDLGMsRUFBZ0I7QUFDakMsVUFBTXJCLFFBQVEsR0FBRyxLQUFLQyxTQUF0Qjs7QUFDQSxXQUFLLElBQU1JLEVBQVgsSUFBaUJnQixjQUFqQixFQUFpQztBQUM3QnJCLGdCQUFRLENBQUNLLEVBQUQsQ0FBUixHQUFlLElBQUlULFdBQUosQ0FBZ0JTLEVBQWhCLEVBQW9CZ0IsY0FBYyxDQUFDaEIsRUFBRCxDQUFsQyxFQUF3QyxJQUF4QyxDQUFmO0FBQ0g7QUFDSjs7Ozs7O0FBR0xpQixNQUFNLENBQUNDLE9BQVAsR0FBaUJ4QixRQUFqQiIsImZpbGUiOiIuL2xpYi9Db21waWxlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgeyBSdWxlTWF0Y2hlciwgSG9va01hdGNoZXIgfSA9IHJlcXVpcmUoJy4vTWF0Y2hlcnMnKVxuY29uc3Qgc2Nhbm5lciA9IHJlcXVpcmUoJy4vc2Nhbm5lcicpXG5jb25zdCBpbnRlcnByZXRlciA9IHJlcXVpcmUoJy4vaW50ZXJwcmV0ZXInKVxuXG5jbGFzcyBDb21waWxlciB7XG4gICAgY29uc3RydWN0b3IgKHsgbWF0Y2hlcnMgfSkge1xuICAgICAgICB0aGlzLl9tYXRjaGVycyA9IHt9XG4gICAgICAgIHRoaXMuX2luaXRTeXN0ZW1NYXRjaGVycygpXG4gICAgICAgIHRoaXMuX2luaXRDdXN0b21NYXRjaGVycyhtYXRjaGVycylcbiAgICB9XG5cbiAgICBjb21waWxlIChjb2RlLCBpZCA9ICdtYWluJykge1xuICAgICAgICBjb25zdCBzciA9IHNjYW5uZXIoY29kZSlcbiAgICAgICAgY29uc3QgbWFpbk1hdGNoZXIgPSB0aGlzLl9tYXRjaGVyc1tpZF1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChzci5ub3RFT0YoKSkge1xuICAgICAgICAgICAgICAgIHNyLnVzZShtYWluTWF0Y2hlcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJlZSA9IHNyLnRyZWUoKVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRyZWUuY29kZSgpXG4gICAgICAgICAgICBjb25zdCBleGVjdXRlID0gaW50ZXJwcmV0ZXIudXNlKGNvZGUpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHRyZWUsIGNvZGUsIGV4ZWN1dGUgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBleGVjdXRlICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2luaXRTeXN0ZW1NYXRjaGVycyAoKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXJzID0gdGhpcy5fbWF0Y2hlcnNcbiAgICAgICAgO1tcbiAgICAgICAgICAgIFsgJ3cnLCBzciA9PiAvXFx3Ly50ZXN0KHNyLnJlYWQoKSkgXSxcbiAgICAgICAgICAgIFsgJ1cnLCBzciA9PiAvXFxXLy50ZXN0KHNyLnJlYWQoKSkgXSxcbiAgICAgICAgICAgIFsgJ2QnLCBzciA9PiAvXFxkLy50ZXN0KHNyLnJlYWQoKSkgXSxcbiAgICAgICAgICAgIFsgJ0QnLCBzciA9PiAvXFxELy50ZXN0KHNyLnJlYWQoKSkgXSxcbiAgICAgICAgICAgIFsgJ3MnLCBzciA9PiAvXFxzLy50ZXN0KHNyLnJlYWQoKSkgXSxcbiAgICAgICAgICAgIFsgJ1MnLCBzciA9PiAvXFxTLy50ZXN0KHNyLnJlYWQoKSkgXSxcbiAgICAgICAgICAgIFsgJ2VvbCcsIHNyID0+IHNyLnJlYWQoKSA9PT0gc3IuRU9MIF0sXG4gICAgICAgICAgICBbICcuJywgc3IgPT4gc3IucmVhZCgpICE9PSBzci5FT0wgXSxcbiAgICAgICAgXS5mb3JFYWNoKChbIGlkLCBwYXR0ZXJuIF0pID0+IHtcbiAgICAgICAgICAgIG1hdGNoZXJzW2lkXSA9IG5ldyBSdWxlTWF0Y2hlcihpZCwgcGF0dGVybilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBfaW5pdEN1c3RvbU1hdGNoZXJzIChtYXRjaGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaGVycyA9IHRoaXMuX21hdGNoZXJzXG4gICAgICAgIGZvciAoY29uc3QgaWQgaW4gbWF0Y2hlck9wdGlvbnMpIHtcbiAgICAgICAgICAgIG1hdGNoZXJzW2lkXSA9IG5ldyBIb29rTWF0Y2hlcihpZCwgbWF0Y2hlck9wdGlvbnNbaWRdLCB0aGlzKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBpbGVyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/index.js\n");

/***/ }),

/***/ "./lib/Compiler/interpreter.js":
/*!*************************************!*\
  !*** ./lib/Compiler/interpreter.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\");\n\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n\nvar vm = __webpack_require__(/*! vm */ \"./node_modules/vm-browserify/index.js\");\n\nvar beautifyJs = __webpack_require__(/*! js-beautify */ \"./node_modules/js-beautify/js/index.js\").js;\n\nvar parserContext = __webpack_require__(/*! ./dataParser/context */ \"./lib/Compiler/dataParser/context.js\");\n\nmodule.exports = {\n  use: use\n}; // 返回执行器\n\nfunction use(code, option) {\n  var script = null;\n  return function _callee(customContext) {\n    var dataExports, runtime, systemContext;\n    return _regeneratorRuntime.async(function _callee$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            dataExports = {};\n            runtime = {};\n            systemContext = {\n              $export: function $export(key, getter) {\n                return _regeneratorRuntime.async(function $export$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return _regeneratorRuntime.awrap(systemContext.$field(key, getter).value(runtime));\n\n                      case 2:\n                        dataExports[key] = _context.sent;\n\n                      case 3:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                });\n              },\n              $field: function $field(key, getter) {\n                var fieldNode = new FieldNode(getter, runtime, key);\n                runtime.curNode.appendChild(fieldNode);\n                return fieldNode;\n              },\n              $map: function $map(getter) {\n                runtime.curNode.appendChild(new MapNode(getter, runtime));\n              },\n              $list: function $list(arr, getter) {\n                runtime.curNode.appendChild(new ListNode(getter, runtime, arr));\n              },\n              $sql: function $sql(sql, getter, isArray) {\n                runtime.curNode.appendChild(new SqlNode(getter, runtime, sql, isArray));\n              },\n              $block: function $block(getter) {\n                runtime.curNode.appendChild(new BlockNode(getter, runtime));\n              },\n              $value: function $value(getter) {\n                runtime.curNode.appendChild(new ValueNode(getter, runtime));\n              },\n              value: function value() {\n                return _regeneratorRuntime.async(function value$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        return _context2.abrupt(\"return\", runtime.curNode.value(runtime));\n\n                      case 1:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                });\n              }\n            };\n            runtime.curNode = new MapNode(function () {}, runtime);\n\n            script = script || function () {\n              var scriptCode = beautifyJs(\"\\n                async function main(){\\n                    \".concat(code, \"\\n                }\\n                let promise = main() \\n\\n                typeof $success === 'function' && (promise = promise.then($success))\\n                typeof $failure === 'function' && (promise = promise.catch($failure))\\n                typeof $finally === 'function' && (promise = promise.finally($finally))\\n            \"));\n\n              try {\n                return new vm.Script(scriptCode);\n              } catch (err) {\n                var errLine = err.stack.match(/:(\\d+)/)[1];\n                var errMessage = err.message;\n                var errCodes = scriptCode.split(/\\n/);\n                var error = {\n                  line: errLine,\n                  message: errMessage,\n                  codes: errCodes,\n                  lineCode: scriptCode.split(/\\n/)[errLine - 1]\n                };\n                return new vm.Script(\"\\n                    async function main(){\\n                        await $export('$error', function(){\\n                            $value(function(){\\n                                return \".concat(JSON.stringify(error), \"\\n                            })\\n                        })\\n                    }\\n                    let promise = main()\\n                    typeof $success === 'function' && (promise = promise.then($success))\\n                \"));\n              }\n            }();\n\n            return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n              script.runInNewContext(Object.assign({}, customContext, parserContext, systemContext, {\n                $success: function $success() {\n                  resolve(dataExports);\n                },\n                $failure: function $failure(err) {\n                  dataExports.$error = err;\n                  resolve(dataExports);\n                }\n              }));\n            }));\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    });\n  };\n}\n\nvar pid = 1;\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Node(getter, runtime) {\n    _classCallCheck(this, Node);\n\n    this.PID = pid++;\n    this.parentNode = runtime.curNode;\n\n    this.Context = function () {};\n\n    this.context = this.Context.prototype = this.parentNode ? new this.parentNode.Context() : {}; // 从上一级环境中继承上下文变量\n\n    this.getter = getter;\n  } // 在获取值的时候，通过调用getter生成子节点结构\n\n\n  _createClass(Node, [{\n    key: \"getterProxy\",\n    value: function getterProxy(runtime) {\n      runtime.curNode = this;\n      runtime.curNode.getter.call(this.context, runtime);\n      runtime.curNode = this.parentNode;\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(childNode) {\n      this.childNode = childNode;\n    }\n  }]);\n\n  return Node;\n}();\n\nvar MapNode =\n/*#__PURE__*/\nfunction (_Node) {\n  \"use strict\";\n\n  _inherits(MapNode, _Node);\n\n  function MapNode() {\n    var _this;\n\n    _classCallCheck(this, MapNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapNode).apply(this, arguments));\n    _this.fields = {};\n    return _this;\n  }\n\n  _createClass(MapNode, [{\n    key: \"appendChild\",\n    value: function appendChild(childNode) {\n      // 后续的同名字段会覆盖前面的字段\n      if (this.fields[childNode.key]) {\n        delete this.fields[childNode.key];\n      }\n\n      this.fields[childNode.key] = childNode;\n    }\n  }, {\n    key: \"value\",\n    value: function value(runtime) {\n      var value, key;\n      return _regeneratorRuntime.async(function value$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              this.getterProxy(runtime);\n              value = {};\n              _context4.t0 = _regeneratorRuntime.keys(this.fields);\n\n            case 3:\n              if ((_context4.t1 = _context4.t0()).done) {\n                _context4.next = 12;\n                break;\n              }\n\n              key = _context4.t1.value;\n              runtime.curNode = this;\n              _context4.next = 8;\n              return _regeneratorRuntime.awrap(this.fields[key].value(runtime));\n\n            case 8:\n              value[key] = this.context[key] = _context4.sent;\n              runtime.curNode = this.parentNode;\n              _context4.next = 3;\n              break;\n\n            case 12:\n              return _context4.abrupt(\"return\", value);\n\n            case 13:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n\n  return MapNode;\n}(Node);\n\nvar FieldNode =\n/*#__PURE__*/\nfunction (_Node2) {\n  \"use strict\";\n\n  _inherits(FieldNode, _Node2);\n\n  function FieldNode(getter, runtime, key) {\n    var _this2;\n\n    _classCallCheck(this, FieldNode);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(FieldNode).call(this, getter, runtime));\n    _this2.key = key;\n    return _this2;\n  }\n\n  _createClass(FieldNode, [{\n    key: \"value\",\n    value: function value(runtime) {\n      return _regeneratorRuntime.async(function value$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              this.getterProxy(runtime);\n\n              if (!this.childNode) {\n                _context5.next = 3;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", this.childNode.value(runtime));\n\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n\n  return FieldNode;\n}(Node);\n\nvar ValueNode =\n/*#__PURE__*/\nfunction (_Node3) {\n  \"use strict\";\n\n  _inherits(ValueNode, _Node3);\n\n  function ValueNode() {\n    _classCallCheck(this, ValueNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ValueNode).apply(this, arguments));\n  }\n\n  _createClass(ValueNode, [{\n    key: \"value\",\n    value: function value(runtime) {\n      var value = this.getter.call(this.context, runtime);\n      return value === undefined ? null : value;\n    }\n  }]);\n\n  return ValueNode;\n}(Node);\n\nvar ListNode =\n/*#__PURE__*/\nfunction (_Node4) {\n  \"use strict\";\n\n  _inherits(ListNode, _Node4);\n\n  function ListNode(getter, runtime, arr) {\n    var _this3;\n\n    _classCallCheck(this, ListNode);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ListNode).call(this, getter, runtime));\n    _this3.arr = arr;\n    _this3.context.$total = 0;\n    return _this3;\n  }\n\n  _createClass(ListNode, [{\n    key: \"value\",\n    value: function value(runtime) {\n      var value, childNode, rs, i, _i;\n\n      return _regeneratorRuntime.async(function value$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              this.getterProxy(runtime);\n              runtime.curNode = this;\n              value = [];\n              childNode = this.childNode;\n\n              if (childNode) {\n                _context6.next = 6;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", value);\n\n            case 6:\n              if (!Array.isArray(this.arr)) {\n                _context6.next = 23;\n                break;\n              }\n\n              // 数据库模式\n              rs = this.arr;\n              i = 0;\n\n            case 9:\n              if (!(i < rs.length)) {\n                _context6.next = 21;\n                break;\n              }\n\n              this.context.$index = i;\n              this.context.$total++;\n              Object.assign(this.context, rs[i]);\n              _context6.t0 = value;\n              _context6.next = 16;\n              return _regeneratorRuntime.awrap(this.childNode.value(runtime));\n\n            case 16:\n              _context6.t1 = _context6.sent;\n\n              _context6.t0.push.call(_context6.t0, _context6.t1);\n\n            case 18:\n              i++;\n              _context6.next = 9;\n              break;\n\n            case 21:\n              _context6.next = 35;\n              break;\n\n            case 23:\n              _i = 0;\n\n            case 24:\n              if (!(_i < this.arr)) {\n                _context6.next = 35;\n                break;\n              }\n\n              this.context.$index = _i;\n              this.context.$total++;\n              _context6.t2 = value;\n              _context6.next = 30;\n              return _regeneratorRuntime.awrap(this.childNode.value(runtime));\n\n            case 30:\n              _context6.t3 = _context6.sent;\n\n              _context6.t2.push.call(_context6.t2, _context6.t3);\n\n            case 32:\n              _i++;\n              _context6.next = 24;\n              break;\n\n            case 35:\n              runtime.curNode = this.parentNode;\n              return _context6.abrupt(\"return\", value);\n\n            case 37:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n\n  return ListNode;\n}(Node);\n\nvar BlockNode =\n/*#__PURE__*/\nfunction (_Node5) {\n  \"use strict\";\n\n  _inherits(BlockNode, _Node5);\n\n  function BlockNode() {\n    _classCallCheck(this, BlockNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BlockNode).apply(this, arguments));\n  }\n\n  _createClass(BlockNode, [{\n    key: \"value\",\n    value: function value(runtime) {\n      var value;\n      return _regeneratorRuntime.async(function value$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              runtime.curNode = this;\n              _context7.next = 3;\n              return _regeneratorRuntime.awrap(this.getter.call(this.context));\n\n            case 3:\n              value = _context7.sent;\n              runtime.curNode = this.parentNode;\n              return _context7.abrupt(\"return\", value);\n\n            case 6:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n\n  return BlockNode;\n}(Node);\n\nvar SqlNode =\n/*#__PURE__*/\nfunction (_Node6) {\n  \"use strict\";\n\n  _inherits(SqlNode, _Node6);\n\n  function SqlNode(getter, runtime, sql) {\n    var _this4;\n\n    var isArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, SqlNode);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(SqlNode).call(this, getter, runtime));\n    _this4.sql = sql;\n    _this4.isArray = isArray;\n    return _this4;\n  }\n\n  _createClass(SqlNode, [{\n    key: \"value\",\n    value: function value(runtime) {\n      var rs, value;\n      return _regeneratorRuntime.async(function value$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              runtime.curNode = this;\n              rs = []; // await $mysql(this.sql)\n\n              if (this.isArray) {\n                this.context.$rs = rs;\n              } else {\n                Object.assign(this.context, rs[0]);\n              }\n\n              _context8.next = 5;\n              return _regeneratorRuntime.awrap(this.getter.call(this.context));\n\n            case 5:\n              _context8.next = 7;\n              return _regeneratorRuntime.awrap(this.childNode.value(runtime));\n\n            case 7:\n              value = _context8.sent;\n              runtime.curNode = this.parentNode;\n              return _context8.abrupt(\"return\", value);\n\n            case 10:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n\n  return SqlNode;\n}(Node);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvaW50ZXJwcmV0ZXIuanM/ZDg3YSJdLCJuYW1lcyI6WyJ2bSIsInJlcXVpcmUiLCJiZWF1dGlmeUpzIiwianMiLCJwYXJzZXJDb250ZXh0IiwibW9kdWxlIiwiZXhwb3J0cyIsInVzZSIsImNvZGUiLCJvcHRpb24iLCJzY3JpcHQiLCJjdXN0b21Db250ZXh0IiwiZGF0YUV4cG9ydHMiLCJydW50aW1lIiwic3lzdGVtQ29udGV4dCIsIiRleHBvcnQiLCJrZXkiLCJnZXR0ZXIiLCIkZmllbGQiLCJ2YWx1ZSIsImZpZWxkTm9kZSIsIkZpZWxkTm9kZSIsImN1ck5vZGUiLCJhcHBlbmRDaGlsZCIsIiRtYXAiLCJNYXBOb2RlIiwiJGxpc3QiLCJhcnIiLCJMaXN0Tm9kZSIsIiRzcWwiLCJzcWwiLCJpc0FycmF5IiwiU3FsTm9kZSIsIiRibG9jayIsIkJsb2NrTm9kZSIsIiR2YWx1ZSIsIlZhbHVlTm9kZSIsInNjcmlwdENvZGUiLCJTY3JpcHQiLCJlcnIiLCJlcnJMaW5lIiwic3RhY2siLCJtYXRjaCIsImVyck1lc3NhZ2UiLCJtZXNzYWdlIiwiZXJyQ29kZXMiLCJzcGxpdCIsImVycm9yIiwibGluZSIsImNvZGVzIiwibGluZUNvZGUiLCJKU09OIiwic3RyaW5naWZ5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJydW5Jbk5ld0NvbnRleHQiLCJPYmplY3QiLCJhc3NpZ24iLCIkc3VjY2VzcyIsIiRmYWlsdXJlIiwiJGVycm9yIiwicGlkIiwiTm9kZSIsIlBJRCIsInBhcmVudE5vZGUiLCJDb250ZXh0IiwiY29udGV4dCIsInByb3RvdHlwZSIsImNhbGwiLCJjaGlsZE5vZGUiLCJhcmd1bWVudHMiLCJmaWVsZHMiLCJnZXR0ZXJQcm94eSIsInVuZGVmaW5lZCIsIiR0b3RhbCIsIkFycmF5IiwicnMiLCJpIiwibGVuZ3RoIiwiJGluZGV4IiwicHVzaCIsIiRycyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7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Szs7Ozs7Ozs7Ozs7O0VBbkJPNEMsSSIsImZpbGUiOiIuL2xpYi9Db21waWxlci9pbnRlcnByZXRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3Qgdm0gPSByZXF1aXJlKCd2bScpXG5jb25zdCBiZWF1dGlmeUpzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qc1xuY29uc3QgcGFyc2VyQ29udGV4dCA9IHJlcXVpcmUoJy4vZGF0YVBhcnNlci9jb250ZXh0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHVzZSxcbn1cblxuLy8g6L+U5Zue5omn6KGM5ZmoXG5mdW5jdGlvbiB1c2UgKGNvZGUsIG9wdGlvbikge1xuICAgIGxldCBzY3JpcHQgPSBudWxsXG5cbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGN1c3RvbUNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZGF0YUV4cG9ydHMgPSB7fVxuICAgICAgICBjb25zdCBydW50aW1lID0ge31cbiAgICAgICAgY29uc3Qgc3lzdGVtQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGFzeW5jICRleHBvcnQgKGtleSwgZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YUV4cG9ydHNba2V5XSA9IGF3YWl0IChzeXN0ZW1Db250ZXh0LiRmaWVsZChrZXksIGdldHRlcikpLnZhbHVlKHJ1bnRpbWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJGZpZWxkIChrZXksIGdldHRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTm9kZSA9IG5ldyBGaWVsZE5vZGUoZ2V0dGVyLCBydW50aW1lLCBrZXkpXG4gICAgICAgICAgICAgICAgcnVudGltZS5jdXJOb2RlLmFwcGVuZENoaWxkKGZpZWxkTm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGROb2RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJG1hcCAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgcnVudGltZS5jdXJOb2RlLmFwcGVuZENoaWxkKG5ldyBNYXBOb2RlKGdldHRlciwgcnVudGltZSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJGxpc3QgKGFyciwgZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgcnVudGltZS5jdXJOb2RlLmFwcGVuZENoaWxkKG5ldyBMaXN0Tm9kZShnZXR0ZXIsIHJ1bnRpbWUsIGFycikpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJHNxbCAoc3FsLCBnZXR0ZXIsIGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBydW50aW1lLmN1ck5vZGUuYXBwZW5kQ2hpbGQobmV3IFNxbE5vZGUoZ2V0dGVyLCBydW50aW1lLCBzcWwsIGlzQXJyYXkpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICRibG9jayAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgcnVudGltZS5jdXJOb2RlLmFwcGVuZENoaWxkKG5ldyBCbG9ja05vZGUoZ2V0dGVyLCBydW50aW1lKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAkdmFsdWUgKGdldHRlcikge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUuY3VyTm9kZS5hcHBlbmRDaGlsZChuZXcgVmFsdWVOb2RlKGdldHRlciwgcnVudGltZSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgdmFsdWUgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW50aW1lLmN1ck5vZGUudmFsdWUocnVudGltZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICBydW50aW1lLmN1ck5vZGUgPSBuZXcgTWFwTm9kZSgoKSA9PiB7IH0sIHJ1bnRpbWUpXG5cbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0IHx8ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHRDb2RlID0gYmVhdXRpZnlKcyhgXG4gICAgICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gbWFpbigpe1xuICAgICAgICAgICAgICAgICAgICAke2NvZGV9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwcm9taXNlID0gbWFpbigpIFxuXG4gICAgICAgICAgICAgICAgdHlwZW9mICRzdWNjZXNzID09PSAnZnVuY3Rpb24nICYmIChwcm9taXNlID0gcHJvbWlzZS50aGVuKCRzdWNjZXNzKSlcbiAgICAgICAgICAgICAgICB0eXBlb2YgJGZhaWx1cmUgPT09ICdmdW5jdGlvbicgJiYgKHByb21pc2UgPSBwcm9taXNlLmNhdGNoKCRmYWlsdXJlKSlcbiAgICAgICAgICAgICAgICB0eXBlb2YgJGZpbmFsbHkgPT09ICdmdW5jdGlvbicgJiYgKHByb21pc2UgPSBwcm9taXNlLmZpbmFsbHkoJGZpbmFsbHkpKVxuICAgICAgICAgICAgYClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2bS5TY3JpcHQoc2NyaXB0Q29kZSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyckxpbmUgPSBlcnIuc3RhY2subWF0Y2goLzooXFxkKykvKVsxXVxuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVyckNvZGVzID0gc2NyaXB0Q29kZS5zcGxpdCgvXFxuLylcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZXJyTGluZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgY29kZXM6IGVyckNvZGVzLFxuICAgICAgICAgICAgICAgICAgICBsaW5lQ29kZTogc2NyaXB0Q29kZS5zcGxpdCgvXFxuLylbZXJyTGluZSAtIDFdLFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdm0uU2NyaXB0KGBcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gbWFpbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgJGV4cG9ydCgnJGVycm9yJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdmFsdWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9taXNlID0gbWFpbigpXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiAkc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAocHJvbWlzZSA9IHByb21pc2UudGhlbigkc3VjY2VzcykpXG4gICAgICAgICAgICAgICAgYClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzY3JpcHQucnVuSW5OZXdDb250ZXh0KE9iamVjdC5hc3NpZ24oeyB9LCBjdXN0b21Db250ZXh0LCBwYXJzZXJDb250ZXh0LCBzeXN0ZW1Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgJHN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGFFeHBvcnRzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJGZhaWx1cmUgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhRXhwb3J0cy4kZXJyb3IgPSBlcnJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhRXhwb3J0cylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5cbmxldCBwaWQgPSAxXG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvciAoZ2V0dGVyLCBydW50aW1lKSB7XG4gICAgICAgIHRoaXMuUElEID0gcGlkKytcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gcnVudGltZS5jdXJOb2RlXG4gICAgICAgIHRoaXMuQ29udGV4dCA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuQ29udGV4dC5wcm90b3R5cGUgPSB0aGlzLnBhcmVudE5vZGUgPyBuZXcgdGhpcy5wYXJlbnROb2RlLkNvbnRleHQoKSA6IHt9IC8vIOS7juS4iuS4gOe6p+eOr+Wig+S4ree7p+aJv+S4iuS4i+aWh+WPmOmHj1xuICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlclxuICAgIH1cblxuICAgIC8vIOWcqOiOt+WPluWAvOeahOaXtuWAme+8jOmAmui/h+iwg+eUqGdldHRlcueUn+aIkOWtkOiKgueCuee7k+aehFxuICAgIGdldHRlclByb3h5IChydW50aW1lKSB7XG4gICAgICAgIHJ1bnRpbWUuY3VyTm9kZSA9IHRoaXNcbiAgICAgICAgcnVudGltZS5jdXJOb2RlLmdldHRlci5jYWxsKHRoaXMuY29udGV4dCwgcnVudGltZSlcbiAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpcy5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgYXBwZW5kQ2hpbGQgKGNoaWxkTm9kZSkge1xuICAgICAgICB0aGlzLmNoaWxkTm9kZSA9IGNoaWxkTm9kZVxuICAgIH1cbn1cblxuY2xhc3MgTWFwTm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKVxuICAgICAgICB0aGlzLmZpZWxkcyA9IHt9XG4gICAgfVxuXG4gICAgYXBwZW5kQ2hpbGQgKGNoaWxkTm9kZSkge1xuICAgICAgICAvLyDlkI7nu63nmoTlkIzlkI3lrZfmrrXkvJropobnm5bliY3pnaLnmoTlrZfmrrVcbiAgICAgICAgaWYgKHRoaXMuZmllbGRzW2NoaWxkTm9kZS5rZXldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWVsZHNbY2hpbGROb2RlLmtleV1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpZWxkc1tjaGlsZE5vZGUua2V5XSA9IGNoaWxkTm9kZVxuICAgIH1cblxuICAgIGFzeW5jIHZhbHVlIChydW50aW1lKSB7XG4gICAgICAgIHRoaXMuZ2V0dGVyUHJveHkocnVudGltZSlcbiAgICAgICAgY29uc3QgdmFsdWUgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpc1xuICAgICAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMuY29udGV4dFtrZXldID0gYXdhaXQgdGhpcy5maWVsZHNba2V5XS52YWx1ZShydW50aW1lKVxuICAgICAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpcy5wYXJlbnROb2RlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxufVxuXG5jbGFzcyBGaWVsZE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvciAoZ2V0dGVyLCBydW50aW1lLCBrZXkpIHtcbiAgICAgICAgc3VwZXIoZ2V0dGVyLCBydW50aW1lKVxuICAgICAgICB0aGlzLmtleSA9IGtleVxuICAgIH1cblxuICAgIGFzeW5jIHZhbHVlIChydW50aW1lKSB7XG4gICAgICAgIHRoaXMuZ2V0dGVyUHJveHkocnVudGltZSlcbiAgICAgICAgaWYgKHRoaXMuY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGUudmFsdWUocnVudGltZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVmFsdWVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgdmFsdWUgKHJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHRoaXMuY29udGV4dCwgcnVudGltZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWVcbiAgICB9XG59XG5cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IgKGdldHRlciwgcnVudGltZSwgYXJyKSB7XG4gICAgICAgIHN1cGVyKGdldHRlciwgcnVudGltZSlcbiAgICAgICAgdGhpcy5hcnIgPSBhcnJcbiAgICAgICAgdGhpcy5jb250ZXh0LiR0b3RhbCA9IDBcbiAgICB9XG5cbiAgICBhc3luYyB2YWx1ZSAocnVudGltZSkge1xuICAgICAgICB0aGlzLmdldHRlclByb3h5KHJ1bnRpbWUpXG4gICAgICAgIHJ1bnRpbWUuY3VyTm9kZSA9IHRoaXNcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXVxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLmNoaWxkTm9kZVxuICAgICAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmFycikpIHtcbiAgICAgICAgICAgIC8vIOaVsOaNruW6k+aooeW8j1xuICAgICAgICAgICAgY29uc3QgcnMgPSB0aGlzLmFyclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC4kaW5kZXggPSBpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LiR0b3RhbCsrXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbnRleHQsIHJzW2ldKVxuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goYXdhaXQgdGhpcy5jaGlsZE5vZGUudmFsdWUocnVudGltZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyDluLjop4Rtb2Nr5qih5byPXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuJGluZGV4ID0gaVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC4kdG90YWwrK1xuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goYXdhaXQgdGhpcy5jaGlsZE5vZGUudmFsdWUocnVudGltZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpcy5wYXJlbnROb2RlXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbn1cblxuY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgYXN5bmMgdmFsdWUgKHJ1bnRpbWUpIHtcbiAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpc1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy5jb250ZXh0KVxuICAgICAgICBydW50aW1lLmN1ck5vZGUgPSB0aGlzLnBhcmVudE5vZGVcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxufVxuXG5jbGFzcyBTcWxOb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IgKGdldHRlciwgcnVudGltZSwgc3FsLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoZ2V0dGVyLCBydW50aW1lKVxuICAgICAgICB0aGlzLnNxbCA9IHNxbFxuICAgICAgICB0aGlzLmlzQXJyYXkgPSBpc0FycmF5XG4gICAgfVxuXG4gICAgYXN5bmMgdmFsdWUgKHJ1bnRpbWUpIHtcbiAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpc1xuICAgICAgICBjb25zdCBycyA9IFtdLy8gYXdhaXQgJG15c3FsKHRoaXMuc3FsKVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuJHJzID0gcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCByc1swXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy5jb250ZXh0KVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuY2hpbGROb2RlLnZhbHVlKHJ1bnRpbWUpXG4gICAgICAgIHJ1bnRpbWUuY3VyTm9kZSA9IHRoaXMucGFyZW50Tm9kZVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/interpreter.js\n");

/***/ }),

/***/ "./lib/Compiler/logger.js":
/*!********************************!*\
  !*** ./lib/Compiler/logger.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var indentSize = 0;\nvar _matcherCreated = true;\nvar _runtimeCreated = true;\nvar _scaning = true;\nvar _resolve = true;\nvar _reject = true;\nvar indentSpace = '  ';\n\nvar indent = function indent(changeSize) {\n  if (changeSize === -1) {\n    return Array(Math.max(0, indentSize--)).join(indentSpace);\n  } else if (changeSize === 1) {\n    return Array(++indentSize).join(indentSpace);\n  } else {\n    return Array(indentSize).join(indentSpace);\n  }\n};\n\nvar matcherIdentfier = function matcherIdentfier(matcher) {\n  return \"\".concat(matcher.PID, \".\").concat(matcher.constructor.name);\n};\n\nvar matcherInfo = function matcherInfo(matcher) {\n  // LinkMatcher\n  if (matcher._id) {\n    return \" \\\"\".concat(matcher._id, \"\\\" \");\n  } // StringMatcher\n\n\n  if (matcher._source) {\n    return \" \\\"\".concat(matcher._source, \"\\\" \");\n  }\n\n  return '';\n};\n\nvar chNow = function chNow(sr) {\n  var index = sr.chIndex;\n  var chNow = sr.chAlls[index];\n  return \"\\u3010\".concat(index, \": \").concat(chNow === sr.EOL ? '\\\\n' : chNow, \"\\u3011\");\n};\n\nvar matchedString = function matchedString(runtime) {\n  return \"\\u3010\".concat(runtime.sr.text(runtime.bIndex, runtime.eIndex), \"\\u3011\");\n};\n\nmodule.exports = {\n  matcherCreated: function matcherCreated(matcher) {\n    if (_matcherCreated) {\n      console.warn(\"\".concat(indent(0)).concat(matcherIdentfier(matcher), \"  created\"), [matcher]);\n    }\n  },\n  runtimeCreated: function runtimeCreated(thisRuntime) {\n    if (_runtimeCreated) {\n      console.warn(\"\".concat(indent(0)).concat(matcherIdentfier(thisRuntime.matcher), \".Runtime created\"), [thisRuntime]);\n    }\n  },\n  scaning: function scaning(_ref, matcher) {\n    var sr = _ref.sr;\n\n    if (_scaning) {\n      console.warn(\"\".concat(indent(1)).concat(matcherIdentfier(matcher)).concat(matcherInfo(matcher), \" scaning \").concat(chNow(sr)), [matcher]);\n    }\n  },\n  resolve: function resolve(thisRuntime) {\n    if (_resolve) {\n      var matcher = thisRuntime.matcher;\n      console.warn(\"\".concat(indent(-1)).concat(matcherIdentfier(matcher)).concat(matcherInfo(matcher), \" resolve \").concat(matchedString(thisRuntime)), [matcher]);\n    }\n  },\n  reject: function reject(thisRuntime, error) {\n    if (_reject) {\n      var sr = thisRuntime.sr,\n          matcher = thisRuntime.matcher;\n      console.error(\"\".concat(indent(-1)).concat(matcherIdentfier(matcher)).concat(matcherInfo(matcher), \" reject \").concat(chNow(sr)), [matcher, error]);\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvbG9nZ2VyLmpzPzM2YjEiXSwibmFtZXMiOlsiaW5kZW50U2l6ZSIsIm1hdGNoZXJDcmVhdGVkIiwicnVudGltZUNyZWF0ZWQiLCJzY2FuaW5nIiwicmVzb2x2ZSIsInJlamVjdCIsImluZGVudFNwYWNlIiwiaW5kZW50IiwiY2hhbmdlU2l6ZSIsIkFycmF5IiwiTWF0aCIsIm1heCIsImpvaW4iLCJtYXRjaGVySWRlbnRmaWVyIiwibWF0Y2hlciIsIlBJRCIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm1hdGNoZXJJbmZvIiwiX2lkIiwiX3NvdXJjZSIsImNoTm93Iiwic3IiLCJpbmRleCIsImNoSW5kZXgiLCJjaEFsbHMiLCJFT0wiLCJtYXRjaGVkU3RyaW5nIiwicnVudGltZSIsInRleHQiLCJiSW5kZXgiLCJlSW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIiwiY29uc29sZSIsIndhcm4iLCJ0aGlzUnVudGltZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiQUFDQSxJQUFJQSxVQUFVLEdBQUcsQ0FBakI7QUFDQSxJQUFNQyxlQUFjLEdBQUcsSUFBdkI7QUFDQSxJQUFNQyxlQUFjLEdBQUcsSUFBdkI7QUFDQSxJQUFNQyxRQUFPLEdBQUcsSUFBaEI7QUFDQSxJQUFNQyxRQUFPLEdBQUcsSUFBaEI7QUFDQSxJQUFNQyxPQUFNLEdBQUcsSUFBZjtBQUVBLElBQU1DLFdBQVcsR0FBRyxJQUFwQjs7QUFDQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFDQyxVQUFELEVBQWdCO0FBQzNCLE1BQUlBLFVBQVUsS0FBSyxDQUFDLENBQXBCLEVBQXVCO0FBQ25CLFdBQU9DLEtBQUssQ0FBQ0MsSUFBSSxDQUFDQyxHQUFMLENBQVMsQ0FBVCxFQUFZWCxVQUFVLEVBQXRCLENBQUQsQ0FBTCxDQUFpQ1ksSUFBakMsQ0FBc0NOLFdBQXRDLENBQVA7QUFDSCxHQUZELE1BRU8sSUFBSUUsVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FB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QUFGLENBQXZIO0FBQ0g7QUFDSixHQXJCWTtBQXNCYlQsUUF0QmEsa0JBc0JMK0IsV0F0QkssRUFzQlFDLEtBdEJSLEVBc0JlO0FBQ3hCLFFBQUloQyxPQUFKLEVBQVk7QUFBQSxVQUNBaUIsRUFEQSxHQUNnQmMsV0FEaEIsQ0FDQWQsRUFEQTtBQUFBLFVBQ0lSLE9BREosR0FDZ0JzQixXQURoQixDQUNJdEIsT0FESjtBQUVSb0IsYUFBTyxDQUFDRyxLQUFSLFdBQWlCOUIsTUFBTSxDQUFDLENBQUMsQ0FBRixDQUF2QixTQUE4Qk0sZ0JBQWdCLENBQUNDLE9BQUQsQ0FBOUMsU0FBMERJLFdBQVcsQ0FBQ0osT0FBRCxDQUFyRSxxQkFBeUZPLEtBQUssQ0FBQ0MsRUFBRCxDQUE5RixHQUFzRyxDQUFFUixPQUFGLEVBQVd1QixLQUFYLENBQXRHO0FBQ0g7QUFDSjtBQTNCWSxDQUFqQiIsImZpbGUiOiIuL2xpYi9Db21waWxlci9sb2dnZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmxldCBpbmRlbnRTaXplID0gMFxuY29uc3QgbWF0Y2hlckNyZWF0ZWQgPSB0cnVlXG5jb25zdCBydW50aW1lQ3JlYXRlZCA9IHRydWVcbmNvbnN0IHNjYW5pbmcgPSB0cnVlXG5jb25zdCByZXNvbHZlID0gdHJ1ZVxuY29uc3QgcmVqZWN0ID0gdHJ1ZVxuXG5jb25zdCBpbmRlbnRTcGFjZSA9ICcgICdcbmNvbnN0IGluZGVudCA9IChjaGFuZ2VTaXplKSA9PiB7XG4gICAgaWYgKGNoYW5nZVNpemUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBBcnJheShNYXRoLm1heCgwLCBpbmRlbnRTaXplLS0pKS5qb2luKGluZGVudFNwYWNlKVxuICAgIH0gZWxzZSBpZiAoY2hhbmdlU2l6ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gQXJyYXkoKytpbmRlbnRTaXplKS5qb2luKGluZGVudFNwYWNlKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBBcnJheShpbmRlbnRTaXplKS5qb2luKGluZGVudFNwYWNlKVxuICAgIH1cbn1cbmNvbnN0IG1hdGNoZXJJZGVudGZpZXIgPSAobWF0Y2hlcikgPT4gYCR7bWF0Y2hlci5QSUR9LiR7bWF0Y2hlci5jb25zdHJ1Y3Rvci5uYW1lfWBcbmNvbnN0IG1hdGNoZXJJbmZvID0gKG1hdGNoZXIpID0+IHtcbiAgICAvLyBMaW5rTWF0Y2hlclxuICAgIGlmIChtYXRjaGVyLl9pZCkge1xuICAgICAgICByZXR1cm4gYCBcIiR7bWF0Y2hlci5faWR9XCIgYFxuICAgIH1cblxuICAgIC8vIFN0cmluZ01hdGNoZXJcbiAgICBpZiAobWF0Y2hlci5fc291cmNlKSB7XG4gICAgICAgIHJldHVybiBgIFwiJHttYXRjaGVyLl9zb3VyY2V9XCIgYFxuICAgIH1cbiAgICByZXR1cm4gJydcbn1cbmNvbnN0IGNoTm93ID0gKHNyKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBzci5jaEluZGV4XG4gICAgY29uc3QgY2hOb3cgPSBzci5jaEFsbHNbaW5kZXhdXG4gICAgcmV0dXJuIGDjgJAke2luZGV4fTogJHtjaE5vdyA9PT0gc3IuRU9MID8gJ1xcXFxuJyA6IGNoTm93feOAkWBcbn1cbmNvbnN0IG1hdGNoZWRTdHJpbmcgPSAocnVudGltZSkgPT4gYOOAkCR7cnVudGltZS5zci50ZXh0KHJ1bnRpbWUuYkluZGV4LCBydW50aW1lLmVJbmRleCl944CRYFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaGVyQ3JlYXRlZCAobWF0Y2hlcikge1xuICAgICAgICBpZiAobWF0Y2hlckNyZWF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtpbmRlbnQoMCl9JHttYXRjaGVySWRlbnRmaWVyKG1hdGNoZXIpfSAgY3JlYXRlZGAsIFsgbWF0Y2hlciBdKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBydW50aW1lQ3JlYXRlZCAodGhpc1J1bnRpbWUpIHtcbiAgICAgICAgaWYgKHJ1bnRpbWVDcmVhdGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7aW5kZW50KDApfSR7bWF0Y2hlcklkZW50Zmllcih0aGlzUnVudGltZS5tYXRjaGVyKX0uUnVudGltZSBjcmVhdGVkYCwgWyB0aGlzUnVudGltZSBdKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzY2FuaW5nICh7IHNyIH0sIG1hdGNoZXIpIHtcbiAgICAgICAgaWYgKHNjYW5pbmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtpbmRlbnQoMSl9JHttYXRjaGVySWRlbnRmaWVyKG1hdGNoZXIpfSR7bWF0Y2hlckluZm8obWF0Y2hlcil9IHNjYW5pbmcgJHtjaE5vdyhzcil9YCwgWyBtYXRjaGVyIF0pXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlc29sdmUgKHRoaXNSdW50aW1lKSB7XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1hdGNoZXIgfSA9IHRoaXNSdW50aW1lXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7aW5kZW50KC0xKX0ke21hdGNoZXJJZGVudGZpZXIobWF0Y2hlcil9JHttYXRjaGVySW5mbyhtYXRjaGVyKX0gcmVzb2x2ZSAke21hdGNoZWRTdHJpbmcodGhpc1J1bnRpbWUpfWAsIFsgbWF0Y2hlciBdKVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZWplY3QgKHRoaXNSdW50aW1lLCBlcnJvcikge1xuICAgICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNyLCBtYXRjaGVyIH0gPSB0aGlzUnVudGltZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHtpbmRlbnQoLTEpfSR7bWF0Y2hlcklkZW50ZmllcihtYXRjaGVyKX0ke21hdGNoZXJJbmZvKG1hdGNoZXIpfSByZWplY3QgJHtjaE5vdyhzcil9YCwgWyBtYXRjaGVyLCBlcnJvciBdKVxuICAgICAgICB9XG4gICAgfSxcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/Compiler/logger.js\n");

/***/ }),

/***/ "./lib/Compiler/scanner.js":
/*!*********************************!*\
  !*** ./lib/Compiler/scanner.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n\nvar Runtime = __webpack_require__(/*! ./Runtime */ \"./lib/Compiler/Runtime.js\");\n\nvar _require = __webpack_require__(/*! ./Matchers */ \"./lib/Compiler/Matchers.js\"),\n    RootMatcher = _require.RootMatcher;\n\nvar treeBuilder = __webpack_require__(/*! ./treeBuilder */ \"./lib/Compiler/treeBuilder.js\");\n\nmodule.exports = scanner;\n\nfunction scanner(code) {\n  var BOF = {},\n      EOF = {},\n      EOL = '\\n';\n  var chAlls = [],\n      chMaps = []; // 初始化代码数据\n\n  init();\n  var recordStack = [];\n  var runtimes = [];\n  var sr = {\n    EOF: EOF,\n    EOL: EOL,\n    chAlls: chAlls,\n    chIndex: 0,\n    chNow: BOF,\n    notEOF: function notEOF() {\n      return sr.chIndex < chAlls.length;\n    },\n    use: function use(matcher) {\n      matcher.scan(new Runtime(null, new RootMatcher(function (thisRuntime) {\n        runtimes.push(thisRuntime);\n      }, function (thisRuntime, error) {\n        var codeInfo = info(error.bIndex); // eslint-disable-next-line no-throw-literal\n\n        throw {\n          message: '编译错误',\n          line: codeInfo.line,\n          column: codeInfo.column,\n          text: chAlls.slice.apply(chAlls, _toConsumableArray(codeInfo.range)).join(''),\n          codes: chAlls.join('').split(/\\n/)\n        };\n      }), {\n        sr: sr\n      }));\n    },\n    read: function read() {\n      if (sr.chIndex === chAlls.length) {\n        // 处于文件结尾\n        throw Error('ch已经到达结尾');\n      }\n\n      return sr.chNow = chAlls[sr.chIndex++];\n    },\n    back: function back() {\n      return sr.chNow = chAlls[--sr.chIndex];\n    },\n    moveTo: function moveTo(chIndex) {\n      return sr.chNow = chAlls[sr.chIndex = chIndex];\n    },\n    createRecord: function createRecord() {\n      return recordStack.push(sr.chIndex);\n    },\n    removeRecord: function removeRecord() {\n      return recordStack.pop();\n    },\n    lastRecord: function lastRecord() {\n      return recordStack[recordStack.length - 1];\n    },\n    rollback: function rollback() {\n      return sr.moveTo(recordStack.pop());\n    },\n    text: function text(bIndex) {\n      var eIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : bIndex + 100;\n      return chAlls.slice(bIndex, Math.min(chAlls.length, eIndex)).join('').replace(/\\n/g, '\\\\n');\n    },\n    tree: function tree() {\n      var tb = treeBuilder();\n\n      var walkRuntimes = function walkRuntimes(runtime) {\n        if (!runtime) {\n          return;\n        }\n\n        var text;\n        var matcher = runtime.matcher;\n        var hooks = matcher._hooks;\n\n        if (hooks) {\n          text = chAlls.slice(runtime.bIndex, runtime.eIndex).join('');\n          hooks.before && hooks.before(tb, text);\n        }\n\n        if (runtime.firstChild) {\n          walkRuntimes(runtime.firstChild);\n        }\n\n        if (hooks) {\n          hooks.done && hooks.done(tb, text);\n          hooks.document && hooks.document(tb, info(runtime.bIndex).document);\n        }\n\n        if (runtime.nextSibling) {\n          walkRuntimes(runtime.nextSibling);\n        }\n      };\n\n      runtimes.forEach(walkRuntimes);\n      return tb.getValue();\n    }\n  };\n  return sr;\n\n  function init() {\n    var lineNum = -1; // 原始行标，因为要对空行进行过滤\n\n    code.split(/\\r\\n?|\\r?\\n/).forEach(function (line) {\n      line = line.trim();\n      lineNum++;\n\n      if (!line) {\n        return;\n      }\n\n      var document;\n      line = line.replace(/\\/\\/(\\/)? .+/, function (matched, isDocument) {\n        if (isDocument) {\n          document = matched;\n        }\n\n        return '';\n      }).trim();\n\n      if (!line) {\n        return;\n      }\n\n      var bIndex = chAlls.length;\n      chAlls.push.apply(chAlls, _toConsumableArray(line.split('')).concat(['\\n']));\n      var eIndex = chAlls.length;\n      chMaps.push([lineNum, bIndex, eIndex, document]);\n    });\n  }\n\n  function info(index) {\n    var map = chMaps;\n    var mapLength = map.length - 1;\n    var bSection = 0;\n    var eSection = mapLength;\n    var nSection = bSection;\n    var i = 1000; // 越界中断标识\n\n    while (i--) {\n      // nSection = Math.ceil((bSection + eSection) / 2)\n      var item = map[nSection]; // 二分法取值\n\n      var bIndex = item[1];\n      var eIndex = item[2]; // console.info({ nSection, index, bIndex, eIndex })\n\n      if (index >= bIndex && index < eIndex) {\n        return {\n          range: item.slice(1, 3),\n          line: item[0],\n          // 行\n          column: index - bIndex + 1,\n          // 列\n          document: item[3] // 文档\n\n        };\n      } else if (index < bIndex) {\n        // 向前搜\n        eSection = nSection;\n        nSection = Math.floor((eSection + bSection) / 2); // 把当前值作为结束区间\n      } else {\n        // 向后搜\n        bSection = nSection;\n        nSection = Math.ceil((eSection + bSection) / 2); // 把当前值作为开始区间\n      }\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvc2Nhbm5lci5qcz80ZTFhIl0sIm5hbWVzIjpbIlJ1bnRpbWUiLCJyZXF1aXJlIiwiUm9vdE1hdGNoZXIiLCJ0cmVlQnVpbGRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJzY2FubmVyIiwiY29kZSIsIkJPRiIsIkVPRiIsIkVPTCIsImNoQWxscyIsImNoTWFwcyIsImluaXQiLCJyZWNvcmRTdGFjayIsInJ1bnRpbWVzIiwic3IiLCJjaEluZGV4IiwiY2hOb3ciLCJub3RFT0YiLCJsZW5ndGgiLCJ1c2UiLCJtYXRjaGVyIiwic2NhbiIsInRoaXNSdW50aW1lIiwicHVzaCIsImVycm9yIiwiY29kZUluZm8iLCJpbmZvIiwiYkluZGV4IiwibWVzc2FnZSIsImxpbmUiLCJjb2x1bW4iLCJ0ZXh0Iiwic2xpY2UiLCJyYW5nZSIsImpvaW4iLCJjb2RlcyIsInNwbGl0IiwicmVhZCIsIkVycm9yIiwiYmFjayIsIm1vdmVUbyIsImNyZWF0ZVJlY29yZCIsInJlbW92ZVJlY29yZCIsInBvcCIsImxhc3RSZWNvcmQiLCJyb2xsYmFjayIsImVJbmRleCIsIk1hdGgiLCJtaW4iLCJyZXBsYWNlIiwidHJlZSIsInRiIiwid2Fsa1J1bnRpbWVzIiwicnVudGltZSIsImhvb2tzIiwiX2hvb2tzIiwiYmVmb3JlIiwiZmlyc3RDaGlsZCIsImRvbmUiLCJkb2N1bWVudCIsIm5leHRTaWJsaW5nIiwiZm9yRWFjaCIsImdldFZhbHVlIiwibGluZU51bSIsInRyaW0iLCJtYXRjaGVkIiwiaXNEb2N1bWVudCIsImluZGV4IiwibWFwIiwibWFwTGVuZ3RoIiwiYlNlY3Rpb24iLCJlU2VjdGlvbiIsIm5TZWN0aW9uIiwiaSIsIml0ZW0iLCJmbG9vciIsImNlaWwiXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBTUEsT0FBTyxHQUFHQyxtQkFBTyxDQUFDLDRDQUFELENBQXZCOztlQUN3QkEsbUJBQU8sQ0FBQyw4Q0FBRCxDO0lBQXZCQyxXLFlBQUFB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NUJnQyxrQkFBUSxFQUFFZSxJQUFJLENBQUMsQ0FBRCxDQUpYLENBSWdCOztBQUpoQixTQUFQO0FBTUgsT0FQRCxNQU9PLElBQUlQLEtBQUssR0FBR3hDLE1BQVosRUFBb0I7QUFBRTtBQUN6QjRDLGdCQUFRLEdBQUdDLFFBQVg7QUFDQUEsZ0JBQVEsR0FBR3pCLElBQUksQ0FBQzRCLEtBQUwsQ0FBVyxDQUFDSixRQUFRLEdBQUdELFFBQVosSUFBd0IsQ0FBbkMsQ0FBWCxDQUZ1QixDQUUwQjtBQUNwRCxPQUhNLE1BR0E7QUFBRTtBQUNMQSxnQkFBUSxHQUFHRSxRQUFYO0FBQ0FBLGdCQUFRLEdBQUd6QixJQUFJLENBQUM2QixJQUFMLENBQVUsQ0FBQ0wsUUFBUSxHQUFHRCxRQUFaLElBQXdCLENBQWxDLENBQVgsQ0FGRyxDQUU2QztBQUNuRDtBQUNKO0FBQ0o7QUFDSiIsImZpbGUiOiIuL2xpYi9Db21waWxlci9zY2FubmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUnVudGltZSA9IHJlcXVpcmUoJy4vUnVudGltZScpXG5jb25zdCB7IFJvb3RNYXRjaGVyIH0gPSByZXF1aXJlKCcuL01hdGNoZXJzJylcbmNvbnN0IHRyZWVCdWlsZGVyID0gcmVxdWlyZSgnLi90cmVlQnVpbGRlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gc2Nhbm5lclxuXG5mdW5jdGlvbiBzY2FubmVyIChjb2RlKSB7XG4gICAgY29uc3QgWyBCT0YsIEVPRiwgRU9MIF0gPSBbIHt9LCB7fSwgJ1xcbicgXVxuICAgIGNvbnN0IFsgY2hBbGxzLCBjaE1hcHMgXSA9IFsgW10sIFtdIF1cblxuICAgIC8vIOWIneWni+WMluS7o+eggeaVsOaNrlxuICAgIGluaXQoKVxuXG4gICAgY29uc3QgcmVjb3JkU3RhY2sgPSBbXVxuICAgIGNvbnN0IHJ1bnRpbWVzID0gW11cbiAgICBjb25zdCBzciA9IHtcbiAgICAgICAgRU9GLFxuICAgICAgICBFT0wsXG4gICAgICAgIGNoQWxscyxcbiAgICAgICAgY2hJbmRleDogMCxcbiAgICAgICAgY2hOb3c6IEJPRixcbiAgICAgICAgbm90RU9GOiAoKSA9PiBzci5jaEluZGV4IDwgY2hBbGxzLmxlbmd0aCxcbiAgICAgICAgdXNlIChtYXRjaGVyKSB7XG4gICAgICAgICAgICBtYXRjaGVyLnNjYW4obmV3IFJ1bnRpbWUobnVsbCwgbmV3IFJvb3RNYXRjaGVyKCh0aGlzUnVudGltZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWVzLnB1c2godGhpc1J1bnRpbWUpXG4gICAgICAgICAgICB9LCAodGhpc1J1bnRpbWUsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUluZm8gPSBpbmZvKGVycm9yLmJJbmRleClcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ+e8luivkemUmeivrycsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGNvZGVJbmZvLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29kZUluZm8uY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaEFsbHMuc2xpY2UoLi4uY29kZUluZm8ucmFuZ2UpLmpvaW4oJycpLFxuICAgICAgICAgICAgICAgICAgICBjb2RlczogY2hBbGxzLmpvaW4oJycpLnNwbGl0KC9cXG4vKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgeyBzciB9KSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNyLmNoSW5kZXggPT09IGNoQWxscy5sZW5ndGgpIHsgLy8g5aSE5LqO5paH5Lu257uT5bC+XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2No5bey57uP5Yiw6L6+57uT5bC+JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzci5jaE5vdyA9IGNoQWxsc1tzci5jaEluZGV4KytdXG4gICAgICAgIH0sXG4gICAgICAgIGJhY2s6ICgpID0+IHNyLmNoTm93ID0gY2hBbGxzWy0tc3IuY2hJbmRleF0sXG4gICAgICAgIG1vdmVUbzogKGNoSW5kZXgpID0+IHNyLmNoTm93ID0gY2hBbGxzW3NyLmNoSW5kZXggPSBjaEluZGV4XSxcbiAgICAgICAgY3JlYXRlUmVjb3JkOiAoKSA9PiByZWNvcmRTdGFjay5wdXNoKHNyLmNoSW5kZXgpLFxuICAgICAgICByZW1vdmVSZWNvcmQ6ICgpID0+IHJlY29yZFN0YWNrLnBvcCgpLFxuICAgICAgICBsYXN0UmVjb3JkOiAoKSA9PiByZWNvcmRTdGFja1tyZWNvcmRTdGFjay5sZW5ndGggLSAxXSxcbiAgICAgICAgcm9sbGJhY2s6ICgpID0+IHNyLm1vdmVUbyhyZWNvcmRTdGFjay5wb3AoKSksXG4gICAgICAgIHRleHQ6IChiSW5kZXgsIGVJbmRleCA9IGJJbmRleCArIDEwMCkgPT4gY2hBbGxzLnNsaWNlKGJJbmRleCwgTWF0aC5taW4oY2hBbGxzLmxlbmd0aCwgZUluZGV4KSkuam9pbignJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLFxuICAgICAgICB0cmVlICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRiID0gdHJlZUJ1aWxkZXIoKVxuICAgICAgICAgICAgY29uc3Qgd2Fsa1J1bnRpbWVzID0gKHJ1bnRpbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHRleHRcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gcnVudGltZS5tYXRjaGVyXG4gICAgICAgICAgICAgICAgY29uc3QgaG9va3MgPSBtYXRjaGVyLl9ob29rc1xuXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBjaEFsbHMuc2xpY2UocnVudGltZS5iSW5kZXgsIHJ1bnRpbWUuZUluZGV4KS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICBob29rcy5iZWZvcmUgJiYgaG9va3MuYmVmb3JlKHRiLCB0ZXh0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChydW50aW1lLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa1J1bnRpbWVzKHJ1bnRpbWUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MuZG9uZSAmJiBob29rcy5kb25lKHRiLCB0ZXh0KVxuICAgICAgICAgICAgICAgICAgICBob29rcy5kb2N1bWVudCAmJiBob29rcy5kb2N1bWVudCh0YiwgaW5mbyhydW50aW1lLmJJbmRleCkuZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJ1bnRpbWUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa1J1bnRpbWVzKHJ1bnRpbWUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBydW50aW1lcy5mb3JFYWNoKHdhbGtSdW50aW1lcylcblxuICAgICAgICAgICAgcmV0dXJuIHRiLmdldFZhbHVlKClcbiAgICAgICAgfSxcbiAgICB9XG5cbiAgICByZXR1cm4gc3JcblxuICAgIGZ1bmN0aW9uIGluaXQgKCkge1xuICAgICAgICBsZXQgbGluZU51bSA9IC0xIC8vIOWOn+Wni+ihjOagh++8jOWboOS4uuimgeWvueepuuihjOi/m+ihjOi/h+a7pFxuICAgICAgICBjb2RlLnNwbGl0KC9cXHJcXG4/fFxccj9cXG4vKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICAgICAgICBsaW5lTnVtKytcblxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkb2N1bWVudFxuICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFwvXFwvKFxcLyk/IC4rLywgKG1hdGNoZWQsIGlzRG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudCA9IG1hdGNoZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9KS50cmltKClcblxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJJbmRleCA9IGNoQWxscy5sZW5ndGhcbiAgICAgICAgICAgIGNoQWxscy5wdXNoKC4uLmxpbmUuc3BsaXQoJycpLCAnXFxuJylcbiAgICAgICAgICAgIGNvbnN0IGVJbmRleCA9IGNoQWxscy5sZW5ndGhcbiAgICAgICAgICAgIGNoTWFwcy5wdXNoKFsgbGluZU51bSwgYkluZGV4LCBlSW5kZXgsIGRvY3VtZW50IF0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5mbyAoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWFwID0gY2hNYXBzXG4gICAgICAgIGNvbnN0IG1hcExlbmd0aCA9IG1hcC5sZW5ndGggLSAxXG5cbiAgICAgICAgbGV0IGJTZWN0aW9uID0gMFxuICAgICAgICBsZXQgZVNlY3Rpb24gPSBtYXBMZW5ndGhcbiAgICAgICAgbGV0IG5TZWN0aW9uID0gYlNlY3Rpb25cbiAgICAgICAgbGV0IGkgPSAxMDAwIC8vIOi2iueVjOS4reaWreagh+ivhlxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBuU2VjdGlvbiA9IE1hdGguY2VpbCgoYlNlY3Rpb24gKyBlU2VjdGlvbikgLyAyKVxuXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gbWFwW25TZWN0aW9uXSAvLyDkuozliIbms5Xlj5blgLxcbiAgICAgICAgICAgIGNvbnN0IGJJbmRleCA9IGl0ZW1bMV1cbiAgICAgICAgICAgIGNvbnN0IGVJbmRleCA9IGl0ZW1bMl1cblxuICAgICAgICAgICAgLy8gY29uc29sZS5pbmZvKHsgblNlY3Rpb24sIGluZGV4LCBiSW5kZXgsIGVJbmRleCB9KVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gYkluZGV4ICYmIGluZGV4IDwgZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGl0ZW0uc2xpY2UoMSwgMyksXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGl0ZW1bMF0sIC8vIOihjFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gYkluZGV4ICsgMSwgLy8g5YiXXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBpdGVtWzNdLCAvLyDmlofmoaNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgYkluZGV4KSB7IC8vIOWQkeWJjeaQnFxuICAgICAgICAgICAgICAgIGVTZWN0aW9uID0gblNlY3Rpb25cbiAgICAgICAgICAgICAgICBuU2VjdGlvbiA9IE1hdGguZmxvb3IoKGVTZWN0aW9uICsgYlNlY3Rpb24pIC8gMikgLy8g5oqK5b2T5YmN5YC85L2c5Li657uT5p2f5Yy66Ze0XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDlkJHlkI7mkJxcbiAgICAgICAgICAgICAgICBiU2VjdGlvbiA9IG5TZWN0aW9uXG4gICAgICAgICAgICAgICAgblNlY3Rpb24gPSBNYXRoLmNlaWwoKGVTZWN0aW9uICsgYlNlY3Rpb24pIC8gMikgLy8g5oqK5b2T5YmN5YC85L2c5Li65byA5aeL5Yy66Ze0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/scanner.js\n");

/***/ }),

/***/ "./lib/Compiler/treeBuilder.js":
/*!*************************************!*\
  !*** ./lib/Compiler/treeBuilder.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ \"./node_modules/@babel/runtime/helpers/construct.js\");\n\n/*\nconst {\n    NormalExportFieldNode,\n    NormalQueryFieldNode,\n    QueryMapNode,\n    QueryListNode,\n    MapNode,\n    ListNode,\n    BlockNode,\n    JsExpressionNode,\n} = require('./treeNodes')\n*/\nvar _require = __webpack_require__(/*! ./treeNodes */ \"./lib/Compiler/treeNodes.js\"),\n    ObjectFieldNode = _require.ObjectFieldNode,\n    MapNode = _require.MapNode,\n    ListNode = _require.ListNode,\n    ValueNode = _require.ValueNode,\n    JsNode = _require.JsNode;\n\nmodule.exports = function treeBuilder() {\n  return _construct(Builder, Array.prototype.slice.call(arguments));\n};\n\nvar Builder =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Builder() {\n    _classCallCheck(this, Builder);\n\n    new MapNode(this);\n  }\n\n  _createClass(Builder, [{\n    key: \"objectFieldCreate\",\n    value: function objectFieldCreate() {\n      new ObjectFieldNode(this);\n    }\n  }, {\n    key: \"objectFieldSetKey\",\n    value: function objectFieldSetKey(text) {\n      this.curNode.fieldKey = text;\n    }\n  }, {\n    key: \"objectFieldSetValueExpression\",\n    value: function objectFieldSetValueExpression(text) {\n      this.curNode.fieldValueExpression = text;\n    }\n  }, {\n    key: \"dbSetSqlConditionExpression\",\n    value: function dbSetSqlConditionExpression(text) {\n      this.curNode.sqlConditionExpression = text;\n    }\n  }, {\n    key: \"dbSetFieldKey\",\n    value: function dbSetFieldKey(text) {\n      this.curNode.dbFieldKey = text;\n    }\n  }, {\n    key: \"dbSetTableName\",\n    value: function dbSetTableName(text) {\n      this.curNode.tableName = text;\n    }\n  }, {\n    key: \"dbSetFieldsDefineExpression\",\n    value: function dbSetFieldsDefineExpression(text) {\n      if (text) {\n        this.curNode.dbFieldsDefineExpression = text;\n      }\n    }\n  }, {\n    key: \"mapCreate\",\n    value: function mapCreate() {\n      new MapNode(this);\n    }\n  }, {\n    key: \"listCreate\",\n    value: function listCreate() {\n      new ListNode(this);\n    }\n  }, {\n    key: \"listSetLength\",\n    value: function listSetLength(text) {\n      this.curNode.listLength = Number(text) || 0;\n    }\n  }, {\n    key: \"valueCreate\",\n    value: function valueCreate() {\n      new ValueNode(this);\n    }\n  }, {\n    key: \"valueSetBlockExpression\",\n    value: function valueSetBlockExpression(text) {\n      this.curNode.blockExpressions = this.curNode.blockExpressions || [];\n      this.curNode.blockExpressions.push(text);\n    }\n  }, {\n    key: \"valueSetReturnExpression\",\n    value: function valueSetReturnExpression(text) {\n      this.curNode.returnExpression = text;\n    }\n  }, {\n    key: \"jsCreate\",\n    value: function jsCreate() {\n      new JsNode(this);\n    }\n  }, {\n    key: \"jsSetCodeExpression\",\n    value: function jsSetCodeExpression(text) {\n      this.curNode.codeExpression = text;\n    }\n  }, {\n    key: \"documentCreate\",\n    value: function documentCreate(text) {\n      this.curNode.document = text;\n    }\n  }, {\n    key: \"childComplete\",\n    value: function childComplete() {\n      var curNode = this.curNode;\n      var parentNode = curNode.parentNode;\n\n      if (parentNode.fields) {\n        parentNode.fields.push(curNode);\n      } else {\n        parentNode.childNode = curNode;\n      }\n\n      this.curNode = parentNode;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.rootNode;\n    }\n  }]);\n\n  return Builder;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvdHJlZUJ1aWxkZXIuanM/ZjVhYiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiT2JqZWN0RmllbGROb2RlIiwiTWFwTm9kZSIsIkxpc3ROb2RlIiwiVmFsdWVOb2RlIiwiSnNOb2RlIiwibW9kdWxlIiwiZXhwb3J0cyIsInRyZWVCdWlsZGVyIiwiQnVpbGRlciIsImFyZ3VtZW50cyIsInRleHQiLCJjdXJOb2RlIiwiZmllbGRLZXkiLCJmaWVsZFZhbHVlRXhwcmVzc2lvbiIsInNxbENvbmRpdGlvbkV4cHJlc3Npb24iLCJkYkZpZWxkS2V5IiwidGFibGVOYW1lIiwiZGJGaWVsZHNEZWZpbmVFeHByZXNzaW9uIiwibGlzdExlbmd0aCIsIk51bWJlciIsImJsb2NrRXhwcmVzc2lvbnMiLCJwdXNoIiwicmV0dXJuRXhwcmVzc2lvbiIsImNvZGVFeHByZXNzaW9uIiwiZG9jdW1lbnQiLCJwYXJlbnROb2RlIiwiZmllbGRzIiwiY2hpbGROb2RlIiwicm9vdE5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7ZUFtQklBLG1CQUFPLENBQUMsZ0RBQUQsQztJQUxQQyxlLFlBQUFBLGU7SUFDQUMsTyxZQUFBQSxPO0lBQ0FDLFEsWUFBQUEsUTtJQUNBQyxTLFlBQUFBLFM7SUFDQUMsTSxZQUFBQSxNOztBQUdKQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsU0FBU0MsV0FBVCxHQUF3QjtBQUNyQyxvQkFBV0MsT0FBWCw2QkFBc0JDLFNBQXRCO0FBQ0gsQ0FGRDs7SUFLTUQsTzs7Ozs7QUFDRixxQkFBZTtBQUFBOztBQUNYLFFBQUlQLE9BQUosQ0FBWSxJQUFaO0FBQ0g7Ozs7d0NBRW9CO0FBQ2pCLFVBQUlELGVBQUosQ0FBb0IsSUFBcEI7QUFDSDs7O3NDQUVrQlUsSSxFQUFNO0FBQ3JCLFdBQUtDLE9BQUwsQ0FBYUMsUUFBYixHQUF3QkYsSUFBeEI7QUFDSDs7O2tEQUU4QkEsSSxFQUFNO0FBQ2pDLFdBQUtDLE9BQUwsQ0FBYUUsb0JBQWIsR0FBb0NILElBQXBDO0FBQ0g7OztnREFFNEJBLEksRUFBTTtBQUMvQixXQUFLQyxPQUFMLENBQWFHLHNCQUFiLEdBQXNDSixJQUF0QztBQUNIOzs7a0NBRWNBLEksRUFBTTtBQUNqQixXQUFLQyxPQUFMLENBQWFJLFVBQWIsR0FBMEJMLElBQTFCO0FBQ0g7OzttQ0FFZUEsSSxFQUFNO0FBQ2xCLFdBQUtDLE9BQUwsQ0FBYUssU0FBYixHQUF5Qk4sSUFBekI7QUFDSDs7O2dEQUU0QkEsSSxFQUFNO0FBQy9CLFVBQUlBLElBQUosRUFBVTtBQUNOLGFBQUtDLE9BQUwsQ0FBYU0sd0JBQWIsR0FBd0NQLElBQXhDO0FBQ0g7QUFDSjs7O2dDQUVZO0FBQ1QsVUFBSVQsT0FBSixDQUFZLElBQVo7QUFDSDs7O2lDQUVhO0FBQ1YsVUFBSUMsUUFBSixDQUFhLElBQWI7QUFDSDs7O2tDQUVjUSxJLEVBQU07QUFDakIsV0FBS0MsT0FBTCxDQUFhTyxVQUFiLEdBQTBCQyxNQUFNLENBQUNULElBQUQsQ0FBTixJQUFnQixDQUExQztBQUNIOzs7a0NBRWM7QUFDWCxVQUFJUCxTQUFKLENBQWMsSUFBZDtBQUNIOzs7NENBRXdCTyxJLEVBQU07QUFDM0IsV0FBS0MsT0FBTCxDQUFhUyxnQkFBYixHQUFnQyxLQUFLVCxPQUFMLENBQWFTLGdCQUFiLElBQWlDLEVBQWpFO0FBQ0EsV0FBS1QsT0FBTCxDQUFhUyxnQkFBYixDQUE4QkMsSUFBOUIsQ0FBbUNYLElBQW5DO0FBQ0g7Ozs2Q0FFeUJBLEksRUFBTTtBQUM1QixXQUFLQyxPQUFMLENBQWFXLGdCQUFiLEdBQWdDWixJQUFoQztBQUNIOzs7K0JBRVc7QUFDUixVQUFJTixNQUFKLENBQVcsSUFBWDtBQUNIOzs7d0NBRW9CTSxJLEVBQU07QUFDdkIsV0FBS0MsT0FBTCxDQUFhWSxjQUFiLEdBQThCYixJQUE5QjtBQUNIOzs7bUNBRWVBLEksRUFBTTtBQUNsQixXQUFLQyxPQUFMLENBQWFhLFFBQWIsR0FBd0JkLElBQXhCO0FBQ0g7OztvQ0FFZ0I7QUFBQSxVQUNMQyxPQURLLEdBQ08sSUFEUCxDQUNMQSxPQURLO0FBQUEsVUFFTGMsVUFGSyxHQUVVZCxPQUZWLENBRUxjLFVBRks7O0FBSWIsVUFBSUEsVUFBVSxDQUFDQyxNQUFmLEVBQXVCO0FBQ25CRCxrQkFBVSxDQUFDQyxNQUFYLENBQWtCTCxJQUFsQixDQUF1QlYsT0FBdkI7QUFDSCxPQUZELE1BRU87QUFDSGMsa0JBQVUsQ0FBQ0UsU0FBWCxHQUF1QmhCLE9BQXZCO0FBQ0g7O0FBRUQsV0FBS0EsT0FBTCxHQUFlYyxVQUFmO0FBQ0g7OzsrQkFFVztBQUNSLGFBQU8sS0FBS0csUUFBWjtBQUNIIiwiZmlsZSI6Ii4vbGliL0NvbXBpbGVyL3RyZWVCdWlsZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbmNvbnN0IHtcbiAgICBOb3JtYWxFeHBvcnRGaWVsZE5vZGUsXG4gICAgTm9ybWFsUXVlcnlGaWVsZE5vZGUsXG4gICAgUXVlcnlNYXBOb2RlLFxuICAgIFF1ZXJ5TGlzdE5vZGUsXG4gICAgTWFwTm9kZSxcbiAgICBMaXN0Tm9kZSxcbiAgICBCbG9ja05vZGUsXG4gICAgSnNFeHByZXNzaW9uTm9kZSxcbn0gPSByZXF1aXJlKCcuL3RyZWVOb2RlcycpXG4qL1xuXG5jb25zdCB7XG4gICAgT2JqZWN0RmllbGROb2RlLFxuICAgIE1hcE5vZGUsXG4gICAgTGlzdE5vZGUsXG4gICAgVmFsdWVOb2RlLFxuICAgIEpzTm9kZSxcbn0gPSByZXF1aXJlKCcuL3RyZWVOb2RlcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJlZUJ1aWxkZXIgKCkge1xuICAgIHJldHVybiBuZXcgQnVpbGRlciguLi5hcmd1bWVudHMpXG59XG5cblxuY2xhc3MgQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICBuZXcgTWFwTm9kZSh0aGlzKVxuICAgIH1cblxuICAgIG9iamVjdEZpZWxkQ3JlYXRlICgpIHtcbiAgICAgICAgbmV3IE9iamVjdEZpZWxkTm9kZSh0aGlzKVxuICAgIH1cblxuICAgIG9iamVjdEZpZWxkU2V0S2V5ICh0ZXh0KSB7XG4gICAgICAgIHRoaXMuY3VyTm9kZS5maWVsZEtleSA9IHRleHRcbiAgICB9XG5cbiAgICBvYmplY3RGaWVsZFNldFZhbHVlRXhwcmVzc2lvbiAodGV4dCkge1xuICAgICAgICB0aGlzLmN1ck5vZGUuZmllbGRWYWx1ZUV4cHJlc3Npb24gPSB0ZXh0XG4gICAgfVxuXG4gICAgZGJTZXRTcWxDb25kaXRpb25FeHByZXNzaW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMuY3VyTm9kZS5zcWxDb25kaXRpb25FeHByZXNzaW9uID0gdGV4dFxuICAgIH1cblxuICAgIGRiU2V0RmllbGRLZXkgKHRleHQpIHtcbiAgICAgICAgdGhpcy5jdXJOb2RlLmRiRmllbGRLZXkgPSB0ZXh0XG4gICAgfVxuXG4gICAgZGJTZXRUYWJsZU5hbWUgKHRleHQpIHtcbiAgICAgICAgdGhpcy5jdXJOb2RlLnRhYmxlTmFtZSA9IHRleHRcbiAgICB9XG5cbiAgICBkYlNldEZpZWxkc0RlZmluZUV4cHJlc3Npb24gKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTm9kZS5kYkZpZWxkc0RlZmluZUV4cHJlc3Npb24gPSB0ZXh0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYXBDcmVhdGUgKCkge1xuICAgICAgICBuZXcgTWFwTm9kZSh0aGlzKVxuICAgIH1cblxuICAgIGxpc3RDcmVhdGUgKCkge1xuICAgICAgICBuZXcgTGlzdE5vZGUodGhpcylcbiAgICB9XG5cbiAgICBsaXN0U2V0TGVuZ3RoICh0ZXh0KSB7XG4gICAgICAgIHRoaXMuY3VyTm9kZS5saXN0TGVuZ3RoID0gTnVtYmVyKHRleHQpIHx8IDBcbiAgICB9XG5cbiAgICB2YWx1ZUNyZWF0ZSAoKSB7XG4gICAgICAgIG5ldyBWYWx1ZU5vZGUodGhpcylcbiAgICB9XG5cbiAgICB2YWx1ZVNldEJsb2NrRXhwcmVzc2lvbiAodGV4dCkge1xuICAgICAgICB0aGlzLmN1ck5vZGUuYmxvY2tFeHByZXNzaW9ucyA9IHRoaXMuY3VyTm9kZS5ibG9ja0V4cHJlc3Npb25zIHx8IFtdXG4gICAgICAgIHRoaXMuY3VyTm9kZS5ibG9ja0V4cHJlc3Npb25zLnB1c2godGV4dClcbiAgICB9XG5cbiAgICB2YWx1ZVNldFJldHVybkV4cHJlc3Npb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5jdXJOb2RlLnJldHVybkV4cHJlc3Npb24gPSB0ZXh0XG4gICAgfVxuXG4gICAganNDcmVhdGUgKCkge1xuICAgICAgICBuZXcgSnNOb2RlKHRoaXMpXG4gICAgfVxuXG4gICAganNTZXRDb2RlRXhwcmVzc2lvbiAodGV4dCkge1xuICAgICAgICB0aGlzLmN1ck5vZGUuY29kZUV4cHJlc3Npb24gPSB0ZXh0XG4gICAgfVxuXG4gICAgZG9jdW1lbnRDcmVhdGUgKHRleHQpIHtcbiAgICAgICAgdGhpcy5jdXJOb2RlLmRvY3VtZW50ID0gdGV4dFxuICAgIH1cblxuICAgIGNoaWxkQ29tcGxldGUgKCkge1xuICAgICAgICBjb25zdCB7IGN1ck5vZGUgfSA9IHRoaXNcbiAgICAgICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBjdXJOb2RlXG5cbiAgICAgICAgaWYgKHBhcmVudE5vZGUuZmllbGRzKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmZpZWxkcy5wdXNoKGN1ck5vZGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkTm9kZSA9IGN1ck5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VyTm9kZSA9IHBhcmVudE5vZGVcbiAgICB9XG5cbiAgICBnZXRWYWx1ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/Compiler/treeBuilder.js\n");

/***/ }),

/***/ "./lib/Compiler/treeNodes.js":
/*!***********************************!*\
  !*** ./lib/Compiler/treeNodes.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\");\n\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar documentParser = __webpack_require__(/*! ./dataParser/parsers/document */ \"./lib/Compiler/dataParser/parsers/document.js\");\n\nvar valueParser = __webpack_require__(/*! ./dataParser/parsers/value */ \"./lib/Compiler/dataParser/parsers/value.js\");\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Node(runtime) {\n    _classCallCheck(this, Node);\n\n    this.runtime = runtime;\n    this.parentNode = runtime.curNode;\n\n    if (!runtime.rootNode) {\n      runtime.rootNode = this;\n    }\n\n    runtime.curNode = this;\n  }\n\n  _createClass(Node, [{\n    key: \"document\",\n    value: function document() {\n      return '';\n    }\n  }, {\n    key: \"code\",\n    value: function code() {\n      throw Error('Node.code must be override');\n    }\n  }]);\n\n  return Node;\n}();\n\nvar FieldsNode =\n/*#__PURE__*/\nfunction (_Node) {\n  \"use strict\";\n\n  _inherits(FieldsNode, _Node);\n\n  function FieldsNode() {\n    var _this;\n\n    _classCallCheck(this, FieldsNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FieldsNode).apply(this, arguments));\n    _this.fields = [];\n    return _this;\n  }\n\n  _createClass(FieldsNode, [{\n    key: \"fieldsCode\",\n    value: function fieldsCode() {\n      return this.fields.map(function (item) {\n        return item.code();\n      }).join('\\n');\n    }\n  }, {\n    key: \"fieldsDocument\",\n    value: function fieldsDocument() {\n      return this.fields.map(function (item) {\n        return item.document();\n      }).join('\\n');\n    }\n  }, {\n    key: \"getKeysCode\",\n    value: function getKeysCode() {\n      var keys = [];\n      this.fields.forEach(function (item) {\n        if (!item.fieldValueExpression && !item.childNode) {\n          if (item.dbFieldKey) {\n            keys.push(\"\".concat(item.dbFieldKey, \" AS \").concat(item.fieldKey));\n          } else {\n            keys.push(item.fieldKey);\n          }\n        }\n      });\n\n      if (this.dbFieldsDefineExpression) {\n        keys.push(this.dbFieldsDefineExpression);\n      }\n\n      return keys.join(', ');\n    }\n  }]);\n\n  return FieldsNode;\n}(Node);\n\nvar ObjectFieldNode =\n/*#__PURE__*/\nfunction (_Node2) {\n  \"use strict\";\n\n  _inherits(ObjectFieldNode, _Node2);\n\n  function ObjectFieldNode() {\n    _classCallCheck(this, ObjectFieldNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ObjectFieldNode).apply(this, arguments));\n  }\n\n  _createClass(ObjectFieldNode, [{\n    key: \"code\",\n    value: function code() {\n      var key = this.fieldKeyCode();\n      var getterBody;\n\n      if (this.isDbQuery()) {\n        var childNode = this.childNode;\n        var isArray = childNode.constructor === ListNode;\n        var keys = childNode.getKeysCode() || 'count(*) AS total';\n        var tableName = this.dbTableName || this.fieldKey;\n        var sqlArgument = this.conditionCode();\n        var nextGetterBody = childNode.code();\n        getterBody = \"$sql(\\\"SELECT \".concat(keys, \" FROM \").concat(tableName, \" \").concat(sqlArgument, \"\\\", function(){\\n                \").concat(nextGetterBody, \"\\n            }, \").concat(isArray, \");\");\n      } else {\n        if (this.fieldValueExpression) {\n          getterBody = \"$value(function(){\\n                    return \".concat(valueParser(this.fieldValueExpression), \"\\n                });\");\n        } else if (this.childNode) {\n          getterBody = this.childNode.code();\n        } else {\n          getterBody = \"$value(function(){\\n                    return this.\".concat(key, \"\\n                });\");\n        }\n      }\n\n      var mtdName = this.parentNode === this.runtime.rootNode ? 'await $export' : '$field';\n      return \"\".concat(mtdName, \"(\\\"\").concat(key, \"\\\", function(){\\n            \").concat(getterBody, \"\\n        });\");\n    }\n  }, {\n    key: \"fieldKeyCode\",\n    value: function fieldKeyCode() {\n      // 键名格式化\n      return this.fieldKey.replace(/[^.]+\\./, '');\n    }\n  }, {\n    key: \"isDbQuery\",\n    value: function isDbQuery() {\n      // 是否是数据库查询字段\n      return !!this.sqlConditionExpression;\n    }\n  }, {\n    key: \"conditionCode\",\n    value: function conditionCode() {\n      var condition = this.sqlConditionExpression;\n\n      if (condition === 'null') {\n        return '';\n      }\n\n      return \"\".concat(condition.replace(/(\"(?:[^\"]|\\\\\")*\")|('(?:[^']|\\\\')*')|(\\|\\|)|(&&)|(\\\\)/g, function (source, dQuote, sQuote, or, and, esChar) {\n        if (dQuote || sQuote || esChar) {\n          return source.replace(/(\"|'|\\\\)/g, '\\\\$1');\n        }\n\n        if (or) {\n          return ' OR ';\n        }\n\n        if (and) {\n          return ' AND ';\n        }\n      }).replace(/\\{(#|\\$)([\\w.]+)\\}/g, function (source, prefix, word) {\n        if (prefix === '#') {\n          return \"\\\"+ \".concat(word, \" +\\\"\");\n        } else if (prefix === '$') {\n          return \"\\\"+ this.\".concat(word, \" +\\\"\");\n        }\n      }));\n    }\n  }, {\n    key: \"document\",\n    value: function document() {\n      var key = this.fieldKeyCode();\n      var document = this.document ? \"$document(\".concat(documentParser(this.document), \");\") : '$document(null);';\n      var childNode = this.childNode;\n      var childGetter = '';\n\n      if (childNode && (childNode.constructor === ListNode || childNode.constructor === MapNode)) {\n        childGetter = childNode.document();\n      }\n\n      return \"$field(\\\"\".concat(key, \"\\\", function(){\\n            \").concat(document, \"\\n            \").concat(childGetter, \"\\n        });\");\n    }\n  }]);\n\n  return ObjectFieldNode;\n}(Node);\n\nvar ListNode =\n/*#__PURE__*/\nfunction (_FieldsNode) {\n  \"use strict\";\n\n  _inherits(ListNode, _FieldsNode);\n\n  function ListNode() {\n    _classCallCheck(this, ListNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ListNode).apply(this, arguments));\n  }\n\n  _createClass(ListNode, [{\n    key: \"code\",\n    value: function code() {\n      var parentNode = this.parentNode;\n\n      if (parentNode.isDbQuery()) {\n        return \"$list(this.$rs, function(){\\n                $map(function(){\\n                    \".concat(this.fieldsCode(), \"\\n                })\\n            });\");\n      }\n\n      var getterBody = this.childNode ? this.childNode.code() : \"$map(function(){\\n            \".concat(this.fieldsCode(), \"\\n        });\");\n      return \"$list(\".concat(parentNode.listLength || 0, \", function(){\\n            \").concat(getterBody, \"\\n        });\");\n    }\n  }, {\n    key: \"document\",\n    value: function document() {\n      var getterBody = this.childNode ? this.childNode.document() : \"$map(function(){\\n           \".concat(this.fieldsDocument(), \"\\n        });\");\n      return \"$list(function(){\\n            \".concat(getterBody, \"\\n        });\");\n    }\n  }]);\n\n  return ListNode;\n}(FieldsNode);\n\nvar MapNode =\n/*#__PURE__*/\nfunction (_FieldsNode2) {\n  \"use strict\";\n\n  _inherits(MapNode, _FieldsNode2);\n\n  function MapNode() {\n    _classCallCheck(this, MapNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MapNode).apply(this, arguments));\n  }\n\n  _createClass(MapNode, [{\n    key: \"code\",\n    value: function code() {\n      if (this.parentNode) {\n        return \"$map(function(){\\n                \".concat(this.fieldsCode(), \"\\n            });\");\n      }\n\n      return this.fieldsCode();\n    }\n  }, {\n    key: \"document\",\n    value: function document() {\n      if (this.parentNode) {\n        return \"$map(function(){\\n                \".concat(this.fieldsDocument(), \"\\n            });\");\n      }\n    }\n  }]);\n\n  return MapNode;\n}(FieldsNode);\n\nvar ValueNode =\n/*#__PURE__*/\nfunction (_FieldsNode3) {\n  \"use strict\";\n\n  _inherits(ValueNode, _FieldsNode3);\n\n  function ValueNode() {\n    _classCallCheck(this, ValueNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ValueNode).apply(this, arguments));\n  }\n\n  _createClass(ValueNode, [{\n    key: \"code\",\n    value: function code() {\n      return \"$value(function(){ // xxx\\n            \".concat(this.blockExpressions ? this.blockExpressions.join('') : '', \"\\n            return \").concat(valueParser(this.returnExpression), \"\\n        });\");\n    }\n  }]);\n\n  return ValueNode;\n}(FieldsNode);\n\nvar JsNode =\n/*#__PURE__*/\nfunction (_Node3) {\n  \"use strict\";\n\n  _inherits(JsNode, _Node3);\n\n  function JsNode() {\n    _classCallCheck(this, JsNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(JsNode).apply(this, arguments));\n  }\n\n  _createClass(JsNode, [{\n    key: \"code\",\n    value: function code() {\n      return this.codeExpression;\n    }\n  }]);\n\n  return JsNode;\n}(Node);\n\nmodule.exports = {\n  ObjectFieldNode: ObjectFieldNode,\n  MapNode: MapNode,\n  ListNode: ListNode,\n  ValueNode: ValueNode,\n  JsNode: JsNode\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29tcGlsZXIvdHJlZU5vZGVzLmpzPzdiODIiXSwibmFtZXMiOlsiZG9jdW1lbnRQYXJzZXIiLCJyZXF1aXJlIiwidmFsdWVQYXJzZXIiLCJOb2RlIiwicnVudGltZSIsInBhcmVudE5vZGUiLCJjdXJOb2RlIiwicm9vdE5vZGUiLCJFcnJvciIsIkZpZWxkc05vZGUiLCJhcmd1bWVudHMiLCJmaWVsZHMiLCJtYXAiLCJpdGVtIiwiY29kZSIsImpvaW4iLCJkb2N1bWVudCIsImtleXMiLCJmb3JFYWNoIiwiZmllbGRWYWx1ZUV4cHJlc3Npb24iLCJjaGlsZE5vZGUiLCJkYkZpZWxkS2V5IiwicHVzaCIsImZpZWxkS2V5IiwiZGJGaWVsZHNEZWZpbmVFeHByZXNzaW9uIiwiT2JqZWN0RmllbGROb2RlIiwia2V5IiwiZmllbGRLZXlDb2RlIiwiZ2V0dGVyQm9keSIsImlzRGJRdWVyeSIsImlzQXJyYXkiLCJjb25zdHJ1Y3RvciIsIkxpc3ROb2RlIiwiZ2V0S2V5c0NvZGUiLCJ0YWJsZU5hbWUiLCJkYlRhYmxlTmFtZSIsInNxbEFyZ3VtZW50IiwiY29uZGl0aW9uQ29kZSIsIm5leHRHZXR0ZXJCb2R5IiwibXRkTmFtZSIsInJlcGxhY2UiLCJzcWxDb25kaXRpb25FeHByZXNzaW9uIiwiY29uZGl0aW9uIiwic291cmNlIiwiZFF1b3RlIiwic1F1b3RlIiwib3IiLCJhbmQiLCJlc0NoYXIiLCJwcmVmaXgiLCJ3b3JkIiwiY2hpbGRHZXR0ZXIiLCJNYXBOb2RlIiwiZmllbGRzQ29kZSIsImxpc3RMZW5ndGgiLCJmaWVsZHNEb2N1bWVudCIsIlZhbHVlTm9kZSIsImJsb2NrRXhwcmVzc2lvbnMiLCJyZXR1cm5FeHByZXNzaW9uIiwiSnNOb2RlIiwiY29kZUV4cHJlc3Npb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0EsSUFBTUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTlCOztB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LGtCQUFuQjtBQUdBLHNEQUNNM0IsVUFETjtBQUdIOzs7O0VBNUJrQm5CLFU7O0lBK0JqQjJDLE87Ozs7Ozs7Ozs7Ozs7OzsyQkFDTTtBQUNKLFVBQUksS0FBSy9DLFVBQVQsRUFBcUI7QUFDakIsMkRBQ00sS0FBS2dELFVBQUwsRUFETjtBQUdIOztBQUNELGFBQU8sS0FBS0EsVUFBTCxFQUFQO0FBQ0g7OzsrQkFFVztBQUNSLFVBQUksS0FBS2hELFVBQVQsRUFBcUI7QUFDakIsMkRBQ00sS0FBS2tELGNBQUwsRUFETjtBQUdIO0FBQ0o7Ozs7RUFoQmlCOUMsVTs7SUFtQmhCK0MsUzs7Ozs7Ozs7Ozs7Ozs7OzJCQUNNO0FBQ0osOERBQ00sS0FBS0MsZ0JBQUwsR0FBd0IsS0FBS0EsZ0JBQUwsQ0FBc0IxQyxJQUF0QixDQUEyQixFQUEzQixDQUF4QixHQUF5RCxFQUQvRCxrQ0FFYWIsV0FBVyxDQUFDLEtBQUt3RCxnQkFBTixDQUZ4QjtBQUlIOzs7O0VBTm1CakQsVTs7SUFTbEJrRCxNOzs7Ozs7Ozs7Ozs7Ozs7MkJBQ007QUFDSixhQUFPLEtBQUtDLGNBQVo7QUFDSDs7OztFQUhnQnpELEk7O0FBTXJCMEQsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2JyQyxpQkFBZSxFQUFmQSxlQURhO0FBRWIyQixTQUFPLEVBQVBBLE9BRmE7QUFHYnBCLFVBQVEsRUFBUkEsUUFIYTtBQUlid0IsV0FBUyxFQUFUQSxTQUphO0FBS2JHLFFBQU0sRUFBTkE7QUFMYSxDQUFqQiIsImZpbGUiOiIuL2xpYi9Db21waWxlci90cmVlTm9kZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IGRvY3VtZW50UGFyc2VyID0gcmVxdWlyZSgnLi9kYXRhUGFyc2VyL3BhcnNlcnMvZG9jdW1lbnQnKVxuY29uc3QgdmFsdWVQYXJzZXIgPSByZXF1aXJlKCcuL2RhdGFQYXJzZXIvcGFyc2Vycy92YWx1ZScpXG5cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yIChydW50aW1lKSB7XG4gICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWVcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gcnVudGltZS5jdXJOb2RlXG5cbiAgICAgICAgaWYgKCFydW50aW1lLnJvb3ROb2RlKSB7XG4gICAgICAgICAgICBydW50aW1lLnJvb3ROb2RlID0gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgcnVudGltZS5jdXJOb2RlID0gdGhpc1xuICAgIH1cblxuICAgIGRvY3VtZW50ICgpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgY29kZSAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb2RlLmNvZGUgbXVzdCBiZSBvdmVycmlkZScpXG4gICAgfVxufVxuXG5jbGFzcyBGaWVsZHNOb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpXG4gICAgICAgIHRoaXMuZmllbGRzID0gW11cbiAgICB9XG5cbiAgICBmaWVsZHNDb2RlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLm1hcChpdGVtID0+IGl0ZW0uY29kZSgpKS5qb2luKCdcXG4nKVxuICAgIH1cblxuICAgIGZpZWxkc0RvY3VtZW50ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLm1hcChpdGVtID0+IGl0ZW0uZG9jdW1lbnQoKSkuam9pbignXFxuJylcbiAgICB9XG5cbiAgICBnZXRLZXlzQ29kZSAoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXVxuICAgICAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmZpZWxkVmFsdWVFeHByZXNzaW9uICYmICFpdGVtLmNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmRiRmllbGRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGAke2l0ZW0uZGJGaWVsZEtleX0gQVMgJHtpdGVtLmZpZWxkS2V5fWApXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGl0ZW0uZmllbGRLZXkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh0aGlzLmRiRmllbGRzRGVmaW5lRXhwcmVzc2lvbikge1xuICAgICAgICAgICAga2V5cy5wdXNoKHRoaXMuZGJGaWVsZHNEZWZpbmVFeHByZXNzaW9uKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXMuam9pbignLCAnKVxuICAgIH1cbn1cblxuY2xhc3MgT2JqZWN0RmllbGROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29kZSAoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZmllbGRLZXlDb2RlKClcbiAgICAgICAgbGV0IGdldHRlckJvZHlcbiAgICAgICAgaWYgKHRoaXMuaXNEYlF1ZXJ5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2RlXG4gICAgICAgICAgICBjb25zdCBpc0FycmF5ID0gY2hpbGROb2RlLmNvbnN0cnVjdG9yID09PSBMaXN0Tm9kZVxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGNoaWxkTm9kZS5nZXRLZXlzQ29kZSgpIHx8ICdjb3VudCgqKSBBUyB0b3RhbCdcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZGJUYWJsZU5hbWUgfHwgdGhpcy5maWVsZEtleVxuICAgICAgICAgICAgY29uc3Qgc3FsQXJndW1lbnQgPSB0aGlzLmNvbmRpdGlvbkNvZGUoKVxuICAgICAgICAgICAgY29uc3QgbmV4dEdldHRlckJvZHkgPSBjaGlsZE5vZGUuY29kZSgpXG4gICAgICAgICAgICBnZXR0ZXJCb2R5ID0gYCRzcWwoXCJTRUxFQ1QgJHtrZXlzfSBGUk9NICR7dGFibGVOYW1lfSAke3NxbEFyZ3VtZW50fVwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICR7bmV4dEdldHRlckJvZHl9XG4gICAgICAgICAgICB9LCAke2lzQXJyYXl9KTtgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWVsZFZhbHVlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGdldHRlckJvZHkgPSBgJHZhbHVlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke3ZhbHVlUGFyc2VyKHRoaXMuZmllbGRWYWx1ZUV4cHJlc3Npb24pfVxuICAgICAgICAgICAgICAgIH0pO2BcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBnZXR0ZXJCb2R5ID0gdGhpcy5jaGlsZE5vZGUuY29kZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldHRlckJvZHkgPSBgJHZhbHVlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiR7a2V5fVxuICAgICAgICAgICAgICAgIH0pO2BcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdGROYW1lID0gdGhpcy5wYXJlbnROb2RlID09PSB0aGlzLnJ1bnRpbWUucm9vdE5vZGUgPyAnYXdhaXQgJGV4cG9ydCcgOiAnJGZpZWxkJ1xuICAgICAgICByZXR1cm4gYCR7bXRkTmFtZX0oXCIke2tleX1cIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICR7Z2V0dGVyQm9keX1cbiAgICAgICAgfSk7YFxuICAgIH1cblxuICAgIGZpZWxkS2V5Q29kZSAoKSB7IC8vIOmUruWQjeagvOW8j+WMllxuICAgICAgICByZXR1cm4gdGhpcy5maWVsZEtleS5yZXBsYWNlKC9bXi5dK1xcLi8sICcnKVxuICAgIH1cblxuICAgIGlzRGJRdWVyeSAoKSB7IC8vIOaYr+WQpuaYr+aVsOaNruW6k+afpeivouWtl+autVxuICAgICAgICByZXR1cm4gISF0aGlzLnNxbENvbmRpdGlvbkV4cHJlc3Npb25cbiAgICB9XG5cbiAgICBjb25kaXRpb25Db2RlICgpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5zcWxDb25kaXRpb25FeHByZXNzaW9uXG4gICAgICAgIGlmIChjb25kaXRpb24gPT09ICdudWxsJykge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke1xuICAgICAgICAgICAgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhcIig/OlteXCJdfFxcXFxcIikqXCIpfCgnKD86W14nXXxcXFxcJykqJyl8KFxcfFxcfCl8KCYmKXwoXFxcXCkvZywgZnVuY3Rpb24gKHNvdXJjZSwgZFF1b3RlLCBzUXVvdGUsIG9yLCBhbmQsIGVzQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZFF1b3RlIHx8IHNRdW90ZSB8fCBlc0NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvKFwifCd8XFxcXCkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyBPUiAnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcgQU5EICdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xceygjfFxcJCkoW1xcdy5dKylcXH0vZywgZnVuY3Rpb24gKHNvdXJjZSwgcHJlZml4LCB3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcIisgJHt3b3JkfSArXCJgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgXCIrIHRoaXMuJHt3b3JkfSArXCJgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KX1gXG4gICAgfVxuXG4gICAgZG9jdW1lbnQgKCkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZpZWxkS2V5Q29kZSgpXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCA/IGAkZG9jdW1lbnQoJHtkb2N1bWVudFBhcnNlcih0aGlzLmRvY3VtZW50KX0pO2AgOiAnJGRvY3VtZW50KG51bGwpOydcbiAgICAgICAgY29uc3QgY2hpbGROb2RlID0gdGhpcy5jaGlsZE5vZGVcbiAgICAgICAgbGV0IGNoaWxkR2V0dGVyID0gJydcbiAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiAoY2hpbGROb2RlLmNvbnN0cnVjdG9yID09PSBMaXN0Tm9kZSB8fCBjaGlsZE5vZGUuY29uc3RydWN0b3IgPT09IE1hcE5vZGUpKSB7XG4gICAgICAgICAgICBjaGlsZEdldHRlciA9IGNoaWxkTm9kZS5kb2N1bWVudCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAkZmllbGQoXCIke2tleX1cIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICR7ZG9jdW1lbnR9XG4gICAgICAgICAgICAke2NoaWxkR2V0dGVyfVxuICAgICAgICB9KTtgXG4gICAgfVxufVxuXG5jbGFzcyBMaXN0Tm9kZSBleHRlbmRzIEZpZWxkc05vZGUge1xuICAgIGNvZGUgKCkge1xuICAgICAgICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IHRoaXNcblxuICAgICAgICBpZiAocGFyZW50Tm9kZS5pc0RiUXVlcnkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAkbGlzdCh0aGlzLiRycywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkbWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5maWVsZHNDb2RlKCl9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO2BcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdldHRlckJvZHkgPSB0aGlzLmNoaWxkTm9kZSA/IHRoaXMuY2hpbGROb2RlLmNvZGUoKSA6IGAkbWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAke3RoaXMuZmllbGRzQ29kZSgpfVxuICAgICAgICB9KTtgXG5cbiAgICAgICAgcmV0dXJuIGAkbGlzdCgke3BhcmVudE5vZGUubGlzdExlbmd0aCB8fCAwfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICR7Z2V0dGVyQm9keX1cbiAgICAgICAgfSk7YFxuICAgIH1cblxuICAgIGRvY3VtZW50ICgpIHtcbiAgICAgICAgY29uc3QgZ2V0dGVyQm9keSA9IHRoaXMuY2hpbGROb2RlID8gdGhpcy5jaGlsZE5vZGUuZG9jdW1lbnQoKSA6IGAkbWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICR7dGhpcy5maWVsZHNEb2N1bWVudCgpfVxuICAgICAgICB9KTtgXG4gICAgICAgIHJldHVybiBgJGxpc3QoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICR7Z2V0dGVyQm9keX1cbiAgICAgICAgfSk7YFxuICAgIH1cbn1cblxuY2xhc3MgTWFwTm9kZSBleHRlbmRzIEZpZWxkc05vZGUge1xuICAgIGNvZGUgKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gYCRtYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAke3RoaXMuZmllbGRzQ29kZSgpfVxuICAgICAgICAgICAgfSk7YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkc0NvZGUoKVxuICAgIH1cblxuICAgIGRvY3VtZW50ICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGAkbWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJHt0aGlzLmZpZWxkc0RvY3VtZW50KCl9XG4gICAgICAgICAgICB9KTtgXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFZhbHVlTm9kZSBleHRlbmRzIEZpZWxkc05vZGUge1xuICAgIGNvZGUgKCkge1xuICAgICAgICByZXR1cm4gYCR2YWx1ZShmdW5jdGlvbigpeyAvLyB4eHhcbiAgICAgICAgICAgICR7dGhpcy5ibG9ja0V4cHJlc3Npb25zID8gdGhpcy5ibG9ja0V4cHJlc3Npb25zLmpvaW4oJycpIDogJyd9XG4gICAgICAgICAgICByZXR1cm4gJHt2YWx1ZVBhcnNlcih0aGlzLnJldHVybkV4cHJlc3Npb24pfVxuICAgICAgICB9KTtgXG4gICAgfVxufVxuXG5jbGFzcyBKc05vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb2RlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZUV4cHJlc3Npb25cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE9iamVjdEZpZWxkTm9kZSxcbiAgICBNYXBOb2RlLFxuICAgIExpc3ROb2RlLFxuICAgIFZhbHVlTm9kZSxcbiAgICBKc05vZGUsXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Compiler/treeNodes.js\n");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Compiler = __webpack_require__(/*! ./Compiler */ \"./lib/Compiler/index.js\");\n\nvar compiler = new Compiler({\n  matchers: {\n    main: {\n      source: ' <objectField>& | <js> '\n    },\n    objectField: {\n      source: \"\\n                '@' <objectFieldKey> \\n                (\\n                    ( '#' <dbFieldKey> )? <eol> |\\n                    ( <s>+ <objectFiledValueExpression> <eol> )& |\\n                    ( '(' <s>* ')' )? <block>& |\\n                    ( '(' <listLength> ')' <list>& ) |\\n                    ( '#' <dbTableName> )? '(' <dbSqlConditionExpression> ')' <block>\\n                )\\n            \",\n      before: function before(tb) {\n        return tb.objectFieldCreate();\n      },\n      done: function done(tb) {\n        return tb.childComplete();\n      },\n      document: function document(tb, text) {\n        return tb.documentCreate(text);\n      }\n    },\n    objectFieldKey: {\n      source: ' <w>+ ',\n      done: function done(tb, text) {\n        return tb.objectFieldSetKey(text);\n      }\n    },\n    objectFiledValueExpression: {\n      source: function source(sr) {\n        var hasMatched = false;\n\n        while (true) {\n          if (sr.read() === sr.EOL) {\n            sr.back();\n            break;\n          }\n\n          hasMatched = true;\n        }\n\n        return hasMatched;\n      },\n      done: function done(tb, text) {\n        return tb.objectFieldSetValueExpression(text);\n      }\n    },\n    block: {\n      source: '<map>& | <list>& | <value>&'\n    },\n    map: {\n      source: \" \\n                '{' <eol> <dbFieldsDefineExpression>? <objectField>*& '}' <eol> \\n            \",\n      before: function before(tb) {\n        return tb.mapCreate();\n      },\n      done: function done(tb) {\n        return tb.childComplete();\n      },\n      exclusive: true\n    },\n    list: {\n      source: \"\\n                '[' <eol> <dbFieldsDefineExpression>? <objectField>*& ']' <eol>\\n            \",\n      before: function before(tb) {\n        return tb.listCreate();\n      },\n      done: function done(tb) {\n        return tb.childComplete();\n      },\n      exclusive: true\n    },\n    listLength: {\n      source: ' <d>+ ',\n      done: function done(tb, text) {\n        return tb.listSetLength(text);\n      }\n    },\n    value: {\n      source: \"\\n                '(:' <eol> <dbFieldsDefineExpression>? <valueBlockExpression>* <valueReturnExpression> ':)' <eol> \\n            \",\n      before: function before(tb) {\n        return tb.valueCreate();\n      },\n      done: function done(tb) {\n        return tb.childComplete();\n      },\n      exclusive: true\n    },\n    valueBlockExpression: {\n      source: function source(sr) {\n        var text = [];\n\n        while (true) {\n          var cr = sr.read();\n\n          if (cr === sr.EOL) {\n            break;\n          }\n\n          text.push(cr);\n        }\n\n        var line = text.join('');\n\n        if (/^@|^:\\)$/.test(line)) {\n          return false;\n        }\n\n        return true;\n      },\n      done: function done(tb, text) {\n        return tb.valueSetBlockExpression(text);\n      }\n    },\n    valueReturnExpression: {\n      source: function source(sr) {\n        if (sr.read() !== '@' || sr.read() !== ' ') {\n          return false;\n        }\n\n        while (true) {\n          if (sr.read() === sr.EOL) {\n            break;\n          }\n        }\n\n        return true;\n      },\n      done: function done(tb, text) {\n        return tb.valueSetReturnExpression(text.slice(2, -1));\n      }\n    },\n    js: {\n      source: ' <.>+ <eol> ',\n      before: function before(tb) {\n        return tb.jsCreate();\n      },\n      done: function done(tb, text) {\n        tb.jsSetCodeExpression(text.slice(0, -1));\n        tb.childComplete();\n      }\n    },\n    dbFieldKey: {\n      source: \"\\n                <w> (<w> | '.')*\\n            \",\n      done: function done(tb, text) {\n        return tb.dbSetFieldKey(text);\n      }\n    },\n    dbTableName: {\n      source: ' <w>+ ',\n      done: function done(tb, text) {\n        return tb.dbSetTableName(text);\n      }\n    },\n    dbSqlConditionExpression: {\n      source: function source(sr) {\n        var hasMatched = false;\n        var isEscape = false; // 是否遇到转义反斜杠\n\n        var bkLength = 0; // 括号开启的次数\n\n        while (sr.notEOF()) {\n          var cr = sr.read();\n\n          if (isEscape) {\n            isEscape = false;\n          } else if (cr === '\\\\') {\n            isEscape = true;\n          } else if (cr === '(') {\n            bkLength++;\n          } else if (cr === ')') {\n            if (bkLength > 0) {\n              bkLength--;\n            } else {\n              // 结束\n              sr.back();\n              break;\n            }\n          }\n\n          hasMatched = true; // 任意长度，表示成功\n        }\n\n        return hasMatched;\n      },\n      done: function done(tb, text) {\n        return tb.dbSetSqlConditionExpression(text);\n      }\n    },\n    dbFieldsDefineExpression: {\n      source: function source(sr) {\n        if (sr.read() !== '#') {\n          return false;\n        }\n\n        var text = [];\n\n        while (sr.notEOF()) {\n          var cr = sr.read();\n\n          if (cr === sr.EOL) {\n            break;\n          }\n\n          text.push(cr);\n        }\n\n        return /^\\(.+?\\)$/.test(text.join(''));\n      },\n      done: function done(tb, text) {\n        return tb.dbSetFieldsDefineExpression(text.slice(2, -2));\n      }\n    }\n  }\n});\nmodule.exports = {\n  compile: function compile(code) {\n    return compiler.compile(code);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvaW5kZXguanM/OWIwYSJdLCJuYW1lcyI6WyJDb21waWxlciIsInJlcXVpcmUiLCJjb21waWxlciIsIm1hdGNoZXJzIiwibWFpbiIsInNvdXJjZSIsIm9iamVjdEZpZWxkIiwiYmVmb3JlIiwidGIiLCJvYmplY3RGaWVsZENyZWF0ZSIsImRvbmUiLCJjaGlsZENvbXBsZXRlIiwiZG9jdW1lbnQiLCJ0ZXh0IiwiZG9jdW1lbnRDcmVhdGUiLCJvYmplY3RGaWVsZEtleSIsIm9iamVjdEZpZWxkU2V0S2V5Iiwib2JqZWN0RmlsZWRWYWx1ZUV4cHJlc3Npb24iLCJzciIsImhhc01hdGNoZWQiLCJyZWFkIiwiRU9MIiwiYmFjayIsIm9iamVjdEZpZWxkU2V0VmFsdWVFeHByZXNzaW9uIiwiYmxvY2siLCJtYXAiLCJtYXBDcmVhdGUiLCJleGNsdXNpdmUiLCJsaXN0IiwibGlzdENyZWF0ZSIsImxpc3RMZW5ndGgiLCJsaXN0U2V0TGVuZ3RoIiwidmFsdWUiLCJ2YWx1ZUNyZWF0ZSIsInZhbHVlQmxvY2tFeHByZXNzaW9uIiwiY3IiLCJwdXNoIiwibGluZSIsImpvaW4iLCJ0ZXN0IiwidmFsdWVTZXRCbG9ja0V4cHJlc3Npb24iLCJ2YWx1ZVJldHVybkV4cHJlc3Npb24iLCJ2YWx1ZVNldFJldHVybkV4cHJlc3Npb24iLCJzbGljZSIsImpzIiwianNDcmVhdGUiLCJqc1NldENvZGVFeHByZXNzaW9uIiwiZGJGaWVsZEtleSIsImRiU2V0RmllbGRLZXkiLCJkYlRhYmxlTmFtZSIsImRiU2V0VGFibGVOYW1lIiwiZGJTcWxDb25kaXRpb25FeHByZXNzaW9uIiwiaXNFc2NhcGUiLCJia0xlbmd0aCIsIm5vdEVPRiIsImRiU2V0U3FsQ29uZGl0aW9uRXhwcmVzc2lvbiIsImRiRmllbGRzRGVmaW5lRXhwcmVzc2lvbiIsImRiU2V0RmllbGRzRGVmaW5lRXhwcmVzc2lvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb21waWxlIiwiY29kZSJdLCJt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QUFDQyxPQUFQLEdBQWlCO0FBQ2JDLFNBQU8sRUFBRSxpQkFBQUMsSUFBSTtBQUFBLFdBQUkzRCxRQUFRLENBQUMwRCxPQUFULENBQWlCQyxJQUFqQixDQUFKO0FBQUE7QUFEQSxDQUFqQiIsImZpbGUiOiIuL2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgQ29tcGlsZXIgPSByZXF1aXJlKCcuL0NvbXBpbGVyJylcblxuY29uc3QgY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIoe1xuICAgIG1hdGNoZXJzOiB7XG4gICAgICAgIG1haW46IHtcbiAgICAgICAgICAgIHNvdXJjZTogJyA8b2JqZWN0RmllbGQ+JiB8IDxqcz4gJyxcbiAgICAgICAgfSxcblxuICAgICAgICBvYmplY3RGaWVsZDoge1xuICAgICAgICAgICAgc291cmNlOiBgXG4gICAgICAgICAgICAgICAgJ0AnIDxvYmplY3RGaWVsZEtleT4gXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAoICcjJyA8ZGJGaWVsZEtleT4gKT8gPGVvbD4gfFxuICAgICAgICAgICAgICAgICAgICAoIDxzPisgPG9iamVjdEZpbGVkVmFsdWVFeHByZXNzaW9uPiA8ZW9sPiApJiB8XG4gICAgICAgICAgICAgICAgICAgICggJygnIDxzPiogJyknICk/IDxibG9jaz4mIHxcbiAgICAgICAgICAgICAgICAgICAgKCAnKCcgPGxpc3RMZW5ndGg+ICcpJyA8bGlzdD4mICkgfFxuICAgICAgICAgICAgICAgICAgICAoICcjJyA8ZGJUYWJsZU5hbWU+ICk/ICcoJyA8ZGJTcWxDb25kaXRpb25FeHByZXNzaW9uPiAnKScgPGJsb2NrPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICBiZWZvcmU6IHRiID0+IHRiLm9iamVjdEZpZWxkQ3JlYXRlKCksXG4gICAgICAgICAgICBkb25lOiB0YiA9PiB0Yi5jaGlsZENvbXBsZXRlKCksXG4gICAgICAgICAgICBkb2N1bWVudDogKHRiLCB0ZXh0KSA9PiB0Yi5kb2N1bWVudENyZWF0ZSh0ZXh0KSxcbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0RmllbGRLZXk6IHtcbiAgICAgICAgICAgIHNvdXJjZTogJyA8dz4rICcsXG4gICAgICAgICAgICBkb25lOiAodGIsIHRleHQpID0+IHRiLm9iamVjdEZpZWxkU2V0S2V5KHRleHQpLFxuICAgICAgICB9LFxuICAgICAgICBvYmplY3RGaWxlZFZhbHVlRXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgc291cmNlIChzcikge1xuICAgICAgICAgICAgICAgIGxldCBoYXNNYXRjaGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3IucmVhZCgpID09PSBzci5FT0wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyLmJhY2soKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzTWF0Y2hlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6ICh0YiwgdGV4dCkgPT4gdGIub2JqZWN0RmllbGRTZXRWYWx1ZUV4cHJlc3Npb24odGV4dCksXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgIHNvdXJjZTogJzxtYXA+JiB8IDxsaXN0PiYgfCA8dmFsdWU+JicsXG4gICAgICAgIH0sXG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgc291cmNlOiBgIFxuICAgICAgICAgICAgICAgICd7JyA8ZW9sPiA8ZGJGaWVsZHNEZWZpbmVFeHByZXNzaW9uPj8gPG9iamVjdEZpZWxkPiomICd9JyA8ZW9sPiBcbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICBiZWZvcmU6IHRiID0+IHRiLm1hcENyZWF0ZSgpLFxuICAgICAgICAgICAgZG9uZTogdGIgPT4gdGIuY2hpbGRDb21wbGV0ZSgpLFxuICAgICAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBsaXN0OiB7XG4gICAgICAgICAgICBzb3VyY2U6IGBcbiAgICAgICAgICAgICAgICAnWycgPGVvbD4gPGRiRmllbGRzRGVmaW5lRXhwcmVzc2lvbj4/IDxvYmplY3RGaWVsZD4qJiAnXScgPGVvbD5cbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICBiZWZvcmU6ICh0YikgPT4gdGIubGlzdENyZWF0ZSgpLFxuICAgICAgICAgICAgZG9uZTogdGIgPT4gdGIuY2hpbGRDb21wbGV0ZSgpLFxuICAgICAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBsaXN0TGVuZ3RoOiB7XG4gICAgICAgICAgICBzb3VyY2U6ICcgPGQ+KyAnLFxuICAgICAgICAgICAgZG9uZTogKHRiLCB0ZXh0KSA9PiB0Yi5saXN0U2V0TGVuZ3RoKHRleHQpLFxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBzb3VyY2U6IGBcbiAgICAgICAgICAgICAgICAnKDonIDxlb2w+IDxkYkZpZWxkc0RlZmluZUV4cHJlc3Npb24+PyA8dmFsdWVCbG9ja0V4cHJlc3Npb24+KiA8dmFsdWVSZXR1cm5FeHByZXNzaW9uPiAnOiknIDxlb2w+IFxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgIGJlZm9yZTogdGIgPT4gdGIudmFsdWVDcmVhdGUoKSxcbiAgICAgICAgICAgIGRvbmU6IHRiID0+IHRiLmNoaWxkQ29tcGxldGUoKSxcbiAgICAgICAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVCbG9ja0V4cHJlc3Npb246IHtcbiAgICAgICAgICAgIHNvdXJjZTogZnVuY3Rpb24gKHNyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IFtdXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3IgPSBzci5yZWFkKClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyID09PSBzci5FT0wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKGNyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gdGV4dC5qb2luKCcnKVxuICAgICAgICAgICAgICAgIGlmICgvXkB8XjpcXCkkLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6ICh0YiwgdGV4dCkgPT4gdGIudmFsdWVTZXRCbG9ja0V4cHJlc3Npb24odGV4dCksXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlUmV0dXJuRXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgc291cmNlIChzcikge1xuICAgICAgICAgICAgICAgIGlmIChzci5yZWFkKCkgIT09ICdAJyB8fCBzci5yZWFkKCkgIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyLnJlYWQoKSA9PT0gc3IuRU9MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogKHRiLCB0ZXh0KSA9PiB0Yi52YWx1ZVNldFJldHVybkV4cHJlc3Npb24odGV4dC5zbGljZSgyLCAtMSkpLFxuICAgICAgICB9LFxuXG4gICAgICAgIGpzOiB7XG4gICAgICAgICAgICBzb3VyY2U6ICcgPC4+KyA8ZW9sPiAnLFxuICAgICAgICAgICAgYmVmb3JlOiB0YiA9PiB0Yi5qc0NyZWF0ZSgpLFxuICAgICAgICAgICAgZG9uZTogKHRiLCB0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGIuanNTZXRDb2RlRXhwcmVzc2lvbih0ZXh0LnNsaWNlKDAsIC0xKSlcbiAgICAgICAgICAgICAgICB0Yi5jaGlsZENvbXBsZXRlKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGJGaWVsZEtleToge1xuICAgICAgICAgICAgc291cmNlOiBgXG4gICAgICAgICAgICAgICAgPHc+ICg8dz4gfCAnLicpKlxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgIGRvbmU6ICh0YiwgdGV4dCkgPT4gdGIuZGJTZXRGaWVsZEtleSh0ZXh0KSxcbiAgICAgICAgfSxcbiAgICAgICAgZGJUYWJsZU5hbWU6IHtcbiAgICAgICAgICAgIHNvdXJjZTogJyA8dz4rICcsXG4gICAgICAgICAgICBkb25lOiAodGIsIHRleHQpID0+IHRiLmRiU2V0VGFibGVOYW1lKHRleHQpLFxuICAgICAgICB9LFxuICAgICAgICBkYlNxbENvbmRpdGlvbkV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIHNvdXJjZSAoc3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzTWF0Y2hlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgbGV0IGlzRXNjYXBlID0gZmFsc2UgLy8g5piv5ZCm6YGH5Yiw6L2s5LmJ5Y+N5pac5p2gXG4gICAgICAgICAgICAgICAgbGV0IGJrTGVuZ3RoID0gMCAvLyDmi6zlj7flvIDlkK/nmoTmrKHmlbBcblxuICAgICAgICAgICAgICAgIHdoaWxlIChzci5ub3RFT0YoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjciA9IHNyLnJlYWQoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFc2NhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXNjYXBlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VzY2FwZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjciA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBia0xlbmd0aCsrXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3IgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJrTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJrTGVuZ3RoLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIOe7k+adn1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyLmJhY2soKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2hlZCA9IHRydWUgLy8g5Lu75oSP6ZW/5bqm77yM6KGo56S65oiQ5YqfXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc01hdGNoZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lOiAodGIsIHRleHQpID0+IHRiLmRiU2V0U3FsQ29uZGl0aW9uRXhwcmVzc2lvbih0ZXh0KSxcbiAgICAgICAgfSxcbiAgICAgICAgZGJGaWVsZHNEZWZpbmVFeHByZXNzaW9uOiB7XG4gICAgICAgICAgICBzb3VyY2UgKHNyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNyLnJlYWQoKSAhPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBbXVxuICAgICAgICAgICAgICAgIHdoaWxlIChzci5ub3RFT0YoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjciA9IHNyLnJlYWQoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3IgPT09IHNyLkVPTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2goY3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAvXlxcKC4rP1xcKSQvLnRlc3QodGV4dC5qb2luKCcnKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lOiAodGIsIHRleHQpID0+IHRiLmRiU2V0RmllbGRzRGVmaW5lRXhwcmVzc2lvbih0ZXh0LnNsaWNlKDIsIC0yKSksXG4gICAgICAgIH0sXG4gICAgfSxcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXBpbGU6IGNvZGUgPT4gY29tcGlsZXIuY29tcGlsZShjb2RlKSxcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/index.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcz9jMTM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcz8yMjM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/M2M5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz85NzBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanM/YjE3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/construct.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcz81YmMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz8zNmM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9lZDZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFrQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanM/MTFiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/iterableToArray.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcz85YjQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanM/YzI0MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/nonIterableRest.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcz8wNjc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/nonIterableSpread.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! ../helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzPzZiNTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFekMsNEJBQTRCLG1CQUFPLENBQUMsK0ZBQXlCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz80YTRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzPzI3OGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsaUZBQWtCOztBQUUvQywyQkFBMkIsbUJBQU8sQ0FBQyw2RkFBd0I7O0FBRTNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUFtQjs7QUFFakQ7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/slicedToArray.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\");\n\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\n\nvar nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ \"./node_modules/@babel/runtime/helpers/nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcz80NDhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHdCQUF3QixtQkFBTyxDQUFDLHVGQUFxQjs7QUFFckQsc0JBQXNCLG1CQUFPLENBQUMsbUZBQW1COztBQUVqRCx3QkFBd0IsbUJBQU8sQ0FBQyx1RkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/toConsumableArray.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IsMkVBQTJFLG9DQUFvQyxtQkFBbUIsR0FBRyxFQUFFLE9BQU8sb0NBQW9DLDhIQUE4SCxHQUFHLEVBQUUsc0JBQXNCOztBQUVuVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/YTM0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/index.js":
/*!**********************************************!*\
  !*** ./node_modules/js-beautify/js/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */\n/* globals define */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/\n\n\n\n/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/\n\nfunction get_beautify(js_beautify, css_beautify, html_beautify) {\n  // the default is js\n  var beautify = function(src, config) {\n    return js_beautify.js_beautify(src, config);\n  };\n\n  // short aliases\n  beautify.js = js_beautify.js_beautify;\n  beautify.css = css_beautify.css_beautify;\n  beautify.html = html_beautify.html_beautify;\n\n  // legacy aliases\n  beautify.js_beautify = js_beautify.js_beautify;\n  beautify.css_beautify = css_beautify.css_beautify;\n  beautify.html_beautify = html_beautify.html_beautify;\n\n  return beautify;\n}\n\nif (true) {\n  // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(/*! ./lib/beautify */ \"./node_modules/js-beautify/js/lib/beautify.js\"),\n    __webpack_require__(/*! ./lib/beautify-css */ \"./node_modules/js-beautify/js/lib/beautify-css.js\"),\n    __webpack_require__(/*! ./lib/beautify-html */ \"./node_modules/js-beautify/js/lib/beautify-html.js\")\n  ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {\n    return get_beautify(js_beautify, css_beautify, html_beautify);\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvaW5kZXguanM/ZTU1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksSUFBMEM7QUFDOUM7QUFDQSxFQUFFLGlDQUFPO0FBQ1QsSUFBSSwwRkFBZ0I7QUFDcEIsSUFBSSxrR0FBb0I7QUFDeEIsSUFBSSxvR0FBcUI7QUFDekIsR0FBRyxtQ0FBRTtBQUNMO0FBQ0EsR0FBRztBQUFBLG9HQUFDO0FBQ0osQ0FBQyxNQUFNIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKiBnbG9iYWxzIGRlZmluZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuVGhlIGZvbGxvd2luZyBiYXRjaGVzIGFyZSBlcXVpdmFsZW50OlxuXG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qcztcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzcztcbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWw7XG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbF9iZWF1dGlmeTtcblxuQWxsIG1ldGhvZHMgcmV0dXJuZWQgYWNjZXB0IHR3byBhcmd1bWVudHMsIHRoZSBzb3VyY2Ugc3RyaW5nIGFuZCBhbiBvcHRpb25zIG9iamVjdC5cbioqL1xuXG5mdW5jdGlvbiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAvLyB0aGUgZGVmYXVsdCBpcyBqc1xuICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgIHJldHVybiBqc19iZWF1dGlmeS5qc19iZWF1dGlmeShzcmMsIGNvbmZpZyk7XG4gIH07XG5cbiAgLy8gc2hvcnQgYWxpYXNlc1xuICBiZWF1dGlmeS5qcyA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gIC8vIGxlZ2FjeSBhbGlhc2VzXG4gIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5Lmh0bWxfYmVhdXRpZnkgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gIGRlZmluZShbXG4gICAgXCIuL2xpYi9iZWF1dGlmeVwiLFxuICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgXCIuL2xpYi9iZWF1dGlmeS1odG1sXCJcbiAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgIHJldHVybiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG4gIH0pO1xufSBlbHNlIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciBiZWF1dGlmaWVyID0gcmVxdWlyZSgnLi9zcmMvaW5kZXgnKTtcbiAgICBiZWF1dGlmaWVyLmpzX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5qcztcbiAgICBiZWF1dGlmaWVyLmNzc19iZWF1dGlmeSA9IGJlYXV0aWZpZXIuY3NzO1xuICAgIGJlYXV0aWZpZXIuaHRtbF9iZWF1dGlmeSA9IGJlYXV0aWZpZXIuaHRtbDtcblxuICAgIG1vZC5leHBvcnRzID0gZ2V0X2JlYXV0aWZ5KGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIpO1xuXG4gIH0pKG1vZHVsZSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/index.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/lib/beautify-css.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-css.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n        https://beautifier.io/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                         — indentation size,\n        indent_char (space)                     — character to indent with,\n        selector_separator_newline (true)       - separate selectors with newline or\n                                                  not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)                - end with a newline\n        newline_between_rules (true)            - add a new line after every css rule\n        space_around_selector_separator (false) - ensure space around selector separators:\n                                                  '>', '+', '~' (e.g. \"a>b\" -> \"a > b\")\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true,\n      'space_around_selector_separator': true\n    });\n*/\n\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n\n(function() {\n\n/* GENERATED_BUILD_OUTPUT */\nvar legacy_beautify_css =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 15);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction OutputLine(parent) {\n  this.__parent = parent;\n  this.__character_count = 0;\n  // use indent_count as a marker for this.__lines that have preserved indentation\n  this.__indent_count = -1;\n  this.__alignment_count = 0;\n  this.__wrap_point_index = 0;\n  this.__wrap_point_character_count = 0;\n  this.__wrap_point_indent_count = -1;\n  this.__wrap_point_alignment_count = 0;\n\n  this.__items = [];\n}\n\nOutputLine.prototype.clone_empty = function() {\n  var line = new OutputLine(this.__parent);\n  line.set_indent(this.__indent_count, this.__alignment_count);\n  return line;\n};\n\nOutputLine.prototype.item = function(index) {\n  if (index < 0) {\n    return this.__items[this.__items.length + index];\n  } else {\n    return this.__items[index];\n  }\n};\n\nOutputLine.prototype.has_match = function(pattern) {\n  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n    if (this.__items[lastCheckedOutput].match(pattern)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nOutputLine.prototype.set_indent = function(indent, alignment) {\n  if (this.is_empty()) {\n    this.__indent_count = indent || 0;\n    this.__alignment_count = alignment || 0;\n    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n  }\n};\n\nOutputLine.prototype._set_wrap_point = function() {\n  if (this.__parent.wrap_line_length) {\n    this.__wrap_point_index = this.__items.length;\n    this.__wrap_point_character_count = this.__character_count;\n    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n  }\n};\n\nOutputLine.prototype._should_wrap = function() {\n  return this.__wrap_point_index &&\n    this.__character_count > this.__parent.wrap_line_length &&\n    this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n};\n\nOutputLine.prototype._allow_wrap = function() {\n  if (this._should_wrap()) {\n    this.__parent.add_new_line();\n    var next = this.__parent.current_line;\n    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n    next.__items = this.__items.slice(this.__wrap_point_index);\n    this.__items = this.__items.slice(0, this.__wrap_point_index);\n\n    next.__character_count += this.__character_count - this.__wrap_point_character_count;\n    this.__character_count = this.__wrap_point_character_count;\n\n    if (next.__items[0] === \" \") {\n      next.__items.splice(0, 1);\n      next.__character_count -= 1;\n    }\n    return true;\n  }\n  return false;\n};\n\nOutputLine.prototype.is_empty = function() {\n  return this.__items.length === 0;\n};\n\nOutputLine.prototype.last = function() {\n  if (!this.is_empty()) {\n    return this.__items[this.__items.length - 1];\n  } else {\n    return null;\n  }\n};\n\nOutputLine.prototype.push = function(item) {\n  this.__items.push(item);\n  var last_newline_index = item.lastIndexOf('\\n');\n  if (last_newline_index !== -1) {\n    this.__character_count = item.length - last_newline_index;\n  } else {\n    this.__character_count += item.length;\n  }\n};\n\nOutputLine.prototype.pop = function() {\n  var item = null;\n  if (!this.is_empty()) {\n    item = this.__items.pop();\n    this.__character_count -= item.length;\n  }\n  return item;\n};\n\n\nOutputLine.prototype._remove_indent = function() {\n  if (this.__indent_count > 0) {\n    this.__indent_count -= 1;\n    this.__character_count -= this.__parent.indent_size;\n  }\n};\n\nOutputLine.prototype._remove_wrap_indent = function() {\n  if (this.__wrap_point_indent_count > 0) {\n    this.__wrap_point_indent_count -= 1;\n  }\n};\nOutputLine.prototype.trim = function() {\n  while (this.last() === ' ') {\n    this.__items.pop();\n    this.__character_count -= 1;\n  }\n};\n\nOutputLine.prototype.toString = function() {\n  var result = '';\n  if (this.is_empty()) {\n    if (this.__parent.indent_empty_lines) {\n      result = this.__parent.get_indent_string(this.__indent_count);\n    }\n  } else {\n    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n    result += this.__items.join('');\n  }\n  return result;\n};\n\nfunction IndentStringCache(options, baseIndentString) {\n  this.__cache = [''];\n  this.__indent_size = options.indent_size;\n  this.__indent_string = options.indent_char;\n  if (!options.indent_with_tabs) {\n    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n  }\n\n  // Set to null to continue support for auto detection of base indent\n  baseIndentString = baseIndentString || '';\n  if (options.indent_level > 0) {\n    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n  }\n\n  this.__base_string = baseIndentString;\n  this.__base_string_length = baseIndentString.length;\n}\n\nIndentStringCache.prototype.get_indent_size = function(indent, column) {\n  var result = this.__base_string_length;\n  column = column || 0;\n  if (indent < 0) {\n    result = 0;\n  }\n  result += indent * this.__indent_size;\n  result += column;\n  return result;\n};\n\nIndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n  var result = this.__base_string;\n  column = column || 0;\n  if (indent_level < 0) {\n    indent_level = 0;\n    result = '';\n  }\n  column += indent_level * this.__indent_size;\n  this.__ensure_cache(column);\n  result += this.__cache[column];\n  return result;\n};\n\nIndentStringCache.prototype.__ensure_cache = function(column) {\n  while (column >= this.__cache.length) {\n    this.__add_column();\n  }\n};\n\nIndentStringCache.prototype.__add_column = function() {\n  var column = this.__cache.length;\n  var indent = 0;\n  var result = '';\n  if (this.__indent_size && column >= this.__indent_size) {\n    indent = Math.floor(column / this.__indent_size);\n    column -= indent * this.__indent_size;\n    result = new Array(indent + 1).join(this.__indent_string);\n  }\n  if (column) {\n    result += new Array(column + 1).join(' ');\n  }\n\n  this.__cache.push(result);\n};\n\nfunction Output(options, baseIndentString) {\n  this.__indent_cache = new IndentStringCache(options, baseIndentString);\n  this.raw = false;\n  this._end_with_newline = options.end_with_newline;\n  this.indent_size = options.indent_size;\n  this.wrap_line_length = options.wrap_line_length;\n  this.indent_empty_lines = options.indent_empty_lines;\n  this.__lines = [];\n  this.previous_line = null;\n  this.current_line = null;\n  this.next_line = new OutputLine(this);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n  // initialize\n  this.__add_outputline();\n}\n\nOutput.prototype.__add_outputline = function() {\n  this.previous_line = this.current_line;\n  this.current_line = this.next_line.clone_empty();\n  this.__lines.push(this.current_line);\n};\n\nOutput.prototype.get_line_number = function() {\n  return this.__lines.length;\n};\n\nOutput.prototype.get_indent_string = function(indent, column) {\n  return this.__indent_cache.get_indent_string(indent, column);\n};\n\nOutput.prototype.get_indent_size = function(indent, column) {\n  return this.__indent_cache.get_indent_size(indent, column);\n};\n\nOutput.prototype.is_empty = function() {\n  return !this.previous_line && this.current_line.is_empty();\n};\n\nOutput.prototype.add_new_line = function(force_newline) {\n  // never newline at the start of file\n  // otherwise, newline only if we didn't just add one or we're forced\n  if (this.is_empty() ||\n    (!force_newline && this.just_added_newline())) {\n    return false;\n  }\n\n  // if raw output is enabled, don't print additional newlines,\n  // but still return True as though you had\n  if (!this.raw) {\n    this.__add_outputline();\n  }\n  return true;\n};\n\nOutput.prototype.get_code = function(eol) {\n  this.trim(true);\n\n  // handle some edge cases where the last tokens\n  // has text that ends with newline(s)\n  var last_item = this.current_line.pop();\n  if (last_item) {\n    if (last_item[last_item.length - 1] === '\\n') {\n      last_item = last_item.replace(/\\n+$/g, '');\n    }\n    this.current_line.push(last_item);\n  }\n\n  if (this._end_with_newline) {\n    this.__add_outputline();\n  }\n\n  var sweet_code = this.__lines.join('\\n');\n\n  if (eol !== '\\n') {\n    sweet_code = sweet_code.replace(/[\\n]/g, eol);\n  }\n  return sweet_code;\n};\n\nOutput.prototype.set_wrap_point = function() {\n  this.current_line._set_wrap_point();\n};\n\nOutput.prototype.set_indent = function(indent, alignment) {\n  indent = indent || 0;\n  alignment = alignment || 0;\n\n  // Next line stores alignment values\n  this.next_line.set_indent(indent, alignment);\n\n  // Never indent your first output indent at the start of the file\n  if (this.__lines.length > 1) {\n    this.current_line.set_indent(indent, alignment);\n    return true;\n  }\n\n  this.current_line.set_indent();\n  return false;\n};\n\nOutput.prototype.add_raw_token = function(token) {\n  for (var x = 0; x < token.newlines; x++) {\n    this.__add_outputline();\n  }\n  this.current_line.set_indent(-1);\n  this.current_line.push(token.whitespace_before);\n  this.current_line.push(token.text);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n};\n\nOutput.prototype.add_token = function(printable_token) {\n  this.__add_space_before_token();\n  this.current_line.push(printable_token);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = this.current_line._allow_wrap();\n};\n\nOutput.prototype.__add_space_before_token = function() {\n  if (this.space_before_token && !this.just_added_newline()) {\n    if (!this.non_breaking_space) {\n      this.set_wrap_point();\n    }\n    this.current_line.push(' ');\n  }\n};\n\nOutput.prototype.remove_indent = function(index) {\n  var output_length = this.__lines.length;\n  while (index < output_length) {\n    this.__lines[index]._remove_indent();\n    index++;\n  }\n  this.current_line._remove_wrap_indent();\n};\n\nOutput.prototype.trim = function(eat_newlines) {\n  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n  this.current_line.trim();\n\n  while (eat_newlines && this.__lines.length > 1 &&\n    this.current_line.is_empty()) {\n    this.__lines.pop();\n    this.current_line = this.__lines[this.__lines.length - 1];\n    this.current_line.trim();\n  }\n\n  this.previous_line = this.__lines.length > 1 ?\n    this.__lines[this.__lines.length - 2] : null;\n};\n\nOutput.prototype.just_added_newline = function() {\n  return this.current_line.is_empty();\n};\n\nOutput.prototype.just_added_blankline = function() {\n  return this.is_empty() ||\n    (this.current_line.is_empty() && this.previous_line.is_empty());\n};\n\nOutput.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n  var index = this.__lines.length - 2;\n  while (index >= 0) {\n    var potentialEmptyLine = this.__lines[index];\n    if (potentialEmptyLine.is_empty()) {\n      break;\n    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&\n      potentialEmptyLine.item(-1) !== ends_with) {\n      this.__lines.splice(index + 1, 0, new OutputLine(this));\n      this.previous_line = this.__lines[this.__lines.length - 2];\n      break;\n    }\n    index--;\n  }\n};\n\nmodule.exports.Output = Output;\n\n\n/***/ }),\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Options(options, merge_child_field) {\n  this.raw_options = _mergeOpts(options, merge_child_field);\n\n  // Support passing the source text back with no change\n  this.disabled = this._get_boolean('disabled');\n\n  this.eol = this._get_characters('eol', 'auto');\n  this.end_with_newline = this._get_boolean('end_with_newline');\n  this.indent_size = this._get_number('indent_size', 4);\n  this.indent_char = this._get_characters('indent_char', ' ');\n  this.indent_level = this._get_number('indent_level');\n\n  this.preserve_newlines = this._get_boolean('preserve_newlines', true);\n  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);\n  if (!this.preserve_newlines) {\n    this.max_preserve_newlines = 0;\n  }\n\n  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\\t');\n  if (this.indent_with_tabs) {\n    this.indent_char = '\\t';\n\n    // indent_size behavior changed after 1.8.6\n    // It used to be that indent_size would be\n    // set to 1 for indent_with_tabs. That is no longer needed and\n    // actually doesn't make sense - why not use spaces? Further,\n    // that might produce unexpected behavior - tabs being used\n    // for single-column alignment. So, when indent_with_tabs is true\n    // and indent_size is 1, reset indent_size to 4.\n    if (this.indent_size === 1) {\n      this.indent_size = 4;\n    }\n  }\n\n  // Backwards compat with 1.3.x\n  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));\n\n  this.indent_empty_lines = this._get_boolean('indent_empty_lines');\n\n  // valid templating languages ['django', 'erb', 'handlebars', 'php']\n  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n  // other values ignored\n  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);\n}\n\nOptions.prototype._get_array = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || [];\n  if (typeof option_value === 'object') {\n    if (option_value !== null && typeof option_value.concat === 'function') {\n      result = option_value.concat();\n    }\n  } else if (typeof option_value === 'string') {\n    result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n  }\n  return result;\n};\n\nOptions.prototype._get_boolean = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = option_value === undefined ? !!default_value : !!option_value;\n  return result;\n};\n\nOptions.prototype._get_characters = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || '';\n  if (typeof option_value === 'string') {\n    result = option_value.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n').replace(/\\\\t/, '\\t');\n  }\n  return result;\n};\n\nOptions.prototype._get_number = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  default_value = parseInt(default_value, 10);\n  if (isNaN(default_value)) {\n    default_value = 0;\n  }\n  var result = parseInt(option_value, 10);\n  if (isNaN(result)) {\n    result = default_value;\n  }\n  return result;\n};\n\nOptions.prototype._get_selection = function(name, selection_list, default_value) {\n  var result = this._get_selection_list(name, selection_list, default_value);\n  if (result.length !== 1) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result[0];\n};\n\n\nOptions.prototype._get_selection_list = function(name, selection_list, default_value) {\n  if (!selection_list || selection_list.length === 0) {\n    throw new Error(\"Selection list cannot be empty.\");\n  }\n\n  default_value = default_value || [selection_list[0]];\n  if (!this._is_valid_selection(default_value, selection_list)) {\n    throw new Error(\"Invalid Default Value!\");\n  }\n\n  var result = this._get_array(name, default_value);\n  if (!this._is_valid_selection(result, selection_list)) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result;\n};\n\nOptions.prototype._is_valid_selection = function(result, selection_list) {\n  return result.length && selection_list.length &&\n    !result.some(function(item) { return selection_list.indexOf(item) === -1; });\n};\n\n\n// merges child options up with the parent options object\n// Example: obj = {a: 1, b: {a: 2}}\n//          mergeOpts(obj, 'b')\n//\n//          Returns: {a: 2}\nfunction _mergeOpts(allOptions, childFieldName) {\n  var finalOpts = {};\n  allOptions = _normalizeOpts(allOptions);\n  var name;\n\n  for (name in allOptions) {\n    if (name !== childFieldName) {\n      finalOpts[name] = allOptions[name];\n    }\n  }\n\n  //merge in the per type settings for the childFieldName\n  if (childFieldName && allOptions[childFieldName]) {\n    for (name in allOptions[childFieldName]) {\n      finalOpts[name] = allOptions[childFieldName][name];\n    }\n  }\n  return finalOpts;\n}\n\nfunction _normalizeOpts(options) {\n  var convertedOpts = {};\n  var key;\n\n  for (key in options) {\n    var newKey = key.replace(/-/g, \"_\");\n    convertedOpts[newKey] = options[key];\n  }\n  return convertedOpts;\n}\n\nmodule.exports.Options = Options;\nmodule.exports.normalizeOpts = _normalizeOpts;\nmodule.exports.mergeOpts = _mergeOpts;\n\n\n/***/ }),\n/* 7 */,\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');\n\nfunction InputScanner(input_string) {\n  this.__input = input_string || '';\n  this.__input_length = this.__input.length;\n  this.__position = 0;\n}\n\nInputScanner.prototype.restart = function() {\n  this.__position = 0;\n};\n\nInputScanner.prototype.back = function() {\n  if (this.__position > 0) {\n    this.__position -= 1;\n  }\n};\n\nInputScanner.prototype.hasNext = function() {\n  return this.__position < this.__input_length;\n};\n\nInputScanner.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__input.charAt(this.__position);\n    this.__position += 1;\n  }\n  return val;\n};\n\nInputScanner.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__input_length) {\n    val = this.__input.charAt(index);\n  }\n  return val;\n};\n\n// This is a JavaScript only helper function (not in python)\n// Javascript doesn't have a match method\n// and not all implementation support \"sticky\" flag.\n// If they do not support sticky then both this.match() and this.test() method\n// must get the match and check the index of the match.\n// If sticky is supported and set, this method will use it.\n// Otherwise it will check that global is set, and fall back to the slower method.\nInputScanner.prototype.__match = function(pattern, index) {\n  pattern.lastIndex = index;\n  var pattern_match = pattern.exec(this.__input);\n\n  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n    if (pattern_match.index !== index) {\n      pattern_match = null;\n    }\n  }\n\n  return pattern_match;\n};\n\nInputScanner.prototype.test = function(pattern, index) {\n  index = index || 0;\n  index += this.__position;\n\n  if (index >= 0 && index < this.__input_length) {\n    return !!this.__match(pattern, index);\n  } else {\n    return false;\n  }\n};\n\nInputScanner.prototype.testChar = function(pattern, index) {\n  // test one character regex match\n  var val = this.peek(index);\n  pattern.lastIndex = 0;\n  return val !== null && pattern.test(val);\n};\n\nInputScanner.prototype.match = function(pattern) {\n  var pattern_match = this.__match(pattern, this.__position);\n  if (pattern_match) {\n    this.__position += pattern_match[0].length;\n  } else {\n    pattern_match = null;\n  }\n  return pattern_match;\n};\n\nInputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n  var val = '';\n  var match;\n  if (starting_pattern) {\n    match = this.match(starting_pattern);\n    if (match) {\n      val += match[0];\n    }\n  }\n  if (until_pattern && (match || !starting_pattern)) {\n    val += this.readUntil(until_pattern, until_after);\n  }\n  return val;\n};\n\nInputScanner.prototype.readUntil = function(pattern, until_after) {\n  var val = '';\n  var match_index = this.__position;\n  pattern.lastIndex = this.__position;\n  var pattern_match = pattern.exec(this.__input);\n  if (pattern_match) {\n    match_index = pattern_match.index;\n    if (until_after) {\n      match_index += pattern_match[0].length;\n    }\n  } else {\n    match_index = this.__input_length;\n  }\n\n  val = this.__input.substring(this.__position, match_index);\n  this.__position = match_index;\n  return val;\n};\n\nInputScanner.prototype.readUntilAfter = function(pattern) {\n  return this.readUntil(pattern, true);\n};\n\nInputScanner.prototype.get_regexp = function(pattern, match_from) {\n  var result = null;\n  var flags = 'g';\n  if (match_from && regexp_has_sticky) {\n    flags = 'y';\n  }\n  // strings are converted to regexp\n  if (typeof pattern === \"string\" && pattern !== '') {\n    // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n    result = new RegExp(pattern, flags);\n  } else if (pattern) {\n    result = new RegExp(pattern.source, flags);\n  }\n  return result;\n};\n\nInputScanner.prototype.get_literal_regexp = function(literal_string) {\n  return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n};\n\n/* css beautifier legacy helpers */\nInputScanner.prototype.peekUntilAfter = function(pattern) {\n  var start = this.__position;\n  var val = this.readUntilAfter(pattern);\n  this.__position = start;\n  return val;\n};\n\nInputScanner.prototype.lookBack = function(testVal) {\n  var start = this.__position - 1;\n  return start >= testVal.length && this.__input.substring(start - testVal.length, start)\n    .toLowerCase() === testVal;\n};\n\nmodule.exports.InputScanner = InputScanner;\n\n\n/***/ }),\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Directives(start_block_pattern, end_block_pattern) {\n  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;\n  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;\n  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, 'g');\n  this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n\n  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, 'g');\n}\n\nDirectives.prototype.get_directives = function(text) {\n  if (!text.match(this.__directives_block_pattern)) {\n    return null;\n  }\n\n  var directives = {};\n  this.__directive_pattern.lastIndex = 0;\n  var directive_match = this.__directive_pattern.exec(text);\n\n  while (directive_match) {\n    directives[directive_match[1]] = directive_match[2];\n    directive_match = this.__directive_pattern.exec(text);\n  }\n\n  return directives;\n};\n\nDirectives.prototype.readIgnored = function(input) {\n  return input.readUntilAfter(this.__directives_end_ignore_pattern);\n};\n\n\nmodule.exports.Directives = Directives;\n\n\n/***/ }),\n/* 14 */,\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Beautifier = __webpack_require__(16).Beautifier,\n  Options = __webpack_require__(17).Options;\n\nfunction css_beautify(source_text, options) {\n  var beautifier = new Beautifier(source_text, options);\n  return beautifier.beautify();\n}\n\nmodule.exports = css_beautify;\nmodule.exports.defaultOptions = function() {\n  return new Options();\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Options = __webpack_require__(17).Options;\nvar Output = __webpack_require__(2).Output;\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar Directives = __webpack_require__(13).Directives;\n\nvar directives_core = new Directives(/\\/\\*/, /\\*\\//);\n\nvar lineBreak = /\\r\\n|[\\r\\n]/;\nvar allLineBreaks = /\\r\\n|[\\r\\n]/g;\n\n// tokenizer\nvar whitespaceChar = /\\s/;\nvar whitespacePattern = /(?:\\s|\\n)+/g;\nvar block_comment_pattern = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|$)/g;\nvar comment_pattern = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;\n\nfunction Beautifier(source_text, options) {\n  this._source_text = source_text || '';\n  // Allow the setting of language/file-type specific options\n  // with inheritance of overall settings\n  this._options = new Options(options);\n  this._ch = null;\n  this._input = null;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n  this.NESTED_AT_RULE = {\n    \"@page\": true,\n    \"@font-face\": true,\n    \"@keyframes\": true,\n    // also in CONDITIONAL_GROUP_RULE below\n    \"@media\": true,\n    \"@supports\": true,\n    \"@document\": true\n  };\n  this.CONDITIONAL_GROUP_RULE = {\n    \"@media\": true,\n    \"@supports\": true,\n    \"@document\": true\n  };\n\n}\n\nBeautifier.prototype.eatString = function(endChars) {\n  var result = '';\n  this._ch = this._input.next();\n  while (this._ch) {\n    result += this._ch;\n    if (this._ch === \"\\\\\") {\n      result += this._input.next();\n    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === \"\\n\") {\n      break;\n    }\n    this._ch = this._input.next();\n  }\n  return result;\n};\n\n// Skips any white space in the source text from the current position.\n// When allowAtLeastOneNewLine is true, will output new lines for each\n// newline character found; if the user has preserve_newlines off, only\n// the first newline will be output\nBeautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {\n  var result = whitespaceChar.test(this._input.peek());\n  var isFirstNewLine = true;\n\n  while (whitespaceChar.test(this._input.peek())) {\n    this._ch = this._input.next();\n    if (allowAtLeastOneNewLine && this._ch === '\\n') {\n      if (this._options.preserve_newlines || isFirstNewLine) {\n        isFirstNewLine = false;\n        this._output.add_new_line(true);\n      }\n    }\n  }\n  return result;\n};\n\n// Nested pseudo-class if we are insideRule\n// and the next special character found opens\n// a new block\nBeautifier.prototype.foundNestedPseudoClass = function() {\n  var openParen = 0;\n  var i = 1;\n  var ch = this._input.peek(i);\n  while (ch) {\n    if (ch === \"{\") {\n      return true;\n    } else if (ch === '(') {\n      // pseudoclasses can contain ()\n      openParen += 1;\n    } else if (ch === ')') {\n      if (openParen === 0) {\n        return false;\n      }\n      openParen -= 1;\n    } else if (ch === \";\" || ch === \"}\") {\n      return false;\n    }\n    i++;\n    ch = this._input.peek(i);\n  }\n  return false;\n};\n\nBeautifier.prototype.print_string = function(output_string) {\n  this._output.set_indent(this._indentLevel);\n  this._output.non_breaking_space = true;\n  this._output.add_token(output_string);\n};\n\nBeautifier.prototype.preserveSingleSpace = function(isAfterSpace) {\n  if (isAfterSpace) {\n    this._output.space_before_token = true;\n  }\n};\n\nBeautifier.prototype.indent = function() {\n  this._indentLevel++;\n};\n\nBeautifier.prototype.outdent = function() {\n  if (this._indentLevel > 0) {\n    this._indentLevel--;\n  }\n};\n\n/*_____________________--------------------_____________________*/\n\nBeautifier.prototype.beautify = function() {\n  if (this._options.disabled) {\n    return this._source_text;\n  }\n\n  var source_text = this._source_text;\n  var eol = this._options.eol;\n  if (eol === 'auto') {\n    eol = '\\n';\n    if (source_text && lineBreak.test(source_text || '')) {\n      eol = source_text.match(lineBreak)[0];\n    }\n  }\n\n\n  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.\n  source_text = source_text.replace(allLineBreaks, '\\n');\n\n  // reset\n  var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n\n  this._output = new Output(this._options, baseIndentString);\n  this._input = new InputScanner(source_text);\n  this._indentLevel = 0;\n  this._nestedLevel = 0;\n\n  this._ch = null;\n  var parenLevel = 0;\n\n  var insideRule = false;\n  // This is the value side of a property value pair (blue in the following ex)\n  // label { content: blue }\n  var insidePropertyValue = false;\n  var enteringConditionalGroup = false;\n  var insideAtExtend = false;\n  var insideAtImport = false;\n  var topCharacter = this._ch;\n  var whitespace;\n  var isAfterSpace;\n  var previous_ch;\n\n  while (true) {\n    whitespace = this._input.read(whitespacePattern);\n    isAfterSpace = whitespace !== '';\n    previous_ch = topCharacter;\n    this._ch = this._input.next();\n    if (this._ch === '\\\\' && this._input.hasNext()) {\n      this._ch += this._input.next();\n    }\n    topCharacter = this._ch;\n\n    if (!this._ch) {\n      break;\n    } else if (this._ch === '/' && this._input.peek() === '*') {\n      // /* css comment */\n      // Always start block comments on a new line.\n      // This handles scenarios where a block comment immediately\n      // follows a property definition on the same line or where\n      // minified code is being beautified.\n      this._output.add_new_line();\n      this._input.back();\n\n      var comment = this._input.read(block_comment_pattern);\n\n      // Handle ignore directive\n      var directives = directives_core.get_directives(comment);\n      if (directives && directives.ignore === 'start') {\n        comment += directives_core.readIgnored(this._input);\n      }\n\n      this.print_string(comment);\n\n      // Ensures any new lines following the comment are preserved\n      this.eatWhitespace(true);\n\n      // Block comments are followed by a new line so they don't\n      // share a line with other properties\n      this._output.add_new_line();\n    } else if (this._ch === '/' && this._input.peek() === '/') {\n      // // single line comment\n      // Preserves the space before a comment\n      // on the same line as a rule\n      this._output.space_before_token = true;\n      this._input.back();\n      this.print_string(this._input.read(comment_pattern));\n\n      // Ensures any new lines following the comment are preserved\n      this.eatWhitespace(true);\n    } else if (this._ch === '@') {\n      this.preserveSingleSpace(isAfterSpace);\n\n      // deal with less propery mixins @{...}\n      if (this._input.peek() === '{') {\n        this.print_string(this._ch + this.eatString('}'));\n      } else {\n        this.print_string(this._ch);\n\n        // strip trailing space, if present, for hash property checks\n        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n\n        if (variableOrRule.match(/[ :]$/)) {\n          // we have a variable or pseudo-class, add it and insert one space before continuing\n          variableOrRule = this.eatString(\": \").replace(/\\s$/, '');\n          this.print_string(variableOrRule);\n          this._output.space_before_token = true;\n        }\n\n        variableOrRule = variableOrRule.replace(/\\s$/, '');\n\n        if (variableOrRule === 'extend') {\n          insideAtExtend = true;\n        } else if (variableOrRule === 'import') {\n          insideAtImport = true;\n        }\n\n        // might be a nesting at-rule\n        if (variableOrRule in this.NESTED_AT_RULE) {\n          this._nestedLevel += 1;\n          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {\n            enteringConditionalGroup = true;\n          }\n          // might be less variable\n        } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {\n          insidePropertyValue = true;\n          this.indent();\n        }\n      }\n    } else if (this._ch === '#' && this._input.peek() === '{') {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch + this.eatString('}'));\n    } else if (this._ch === '{') {\n      if (insidePropertyValue) {\n        insidePropertyValue = false;\n        this.outdent();\n      }\n      this.indent();\n      this._output.space_before_token = true;\n      this.print_string(this._ch);\n\n      // when entering conditional groups, only rulesets are allowed\n      if (enteringConditionalGroup) {\n        enteringConditionalGroup = false;\n        insideRule = (this._indentLevel > this._nestedLevel);\n      } else {\n        // otherwise, declarations are also allowed\n        insideRule = (this._indentLevel >= this._nestedLevel);\n      }\n      if (this._options.newline_between_rules && insideRule) {\n        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {\n          this._output.ensure_empty_line_above('/', ',');\n        }\n      }\n      this.eatWhitespace(true);\n      this._output.add_new_line();\n    } else if (this._ch === '}') {\n      this.outdent();\n      this._output.add_new_line();\n      if (previous_ch === '{') {\n        this._output.trim(true);\n      }\n      insideAtImport = false;\n      insideAtExtend = false;\n      if (insidePropertyValue) {\n        this.outdent();\n        insidePropertyValue = false;\n      }\n      this.print_string(this._ch);\n      insideRule = false;\n      if (this._nestedLevel) {\n        this._nestedLevel--;\n      }\n\n      this.eatWhitespace(true);\n      this._output.add_new_line();\n\n      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {\n        if (this._input.peek() !== '}') {\n          this._output.add_new_line(true);\n        }\n      }\n    } else if (this._ch === \":\") {\n      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack(\"&\") || this.foundNestedPseudoClass()) && !this._input.lookBack(\"(\") && !insideAtExtend && parenLevel === 0) {\n        // 'property: value' delimiter\n        // which could be in a conditional group query\n        this.print_string(':');\n        if (!insidePropertyValue) {\n          insidePropertyValue = true;\n          this._output.space_before_token = true;\n          this.eatWhitespace(true);\n          this.indent();\n        }\n      } else {\n        // sass/less parent reference don't use a space\n        // sass nested pseudo-class don't use a space\n\n        // preserve space before pseudoclasses/pseudoelements, as it means \"in any child\"\n        if (this._input.lookBack(\" \")) {\n          this._output.space_before_token = true;\n        }\n        if (this._input.peek() === \":\") {\n          // pseudo-element\n          this._ch = this._input.next();\n          this.print_string(\"::\");\n        } else {\n          // pseudo-class\n          this.print_string(':');\n        }\n      }\n    } else if (this._ch === '\"' || this._ch === '\\'') {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch + this.eatString(this._ch));\n      this.eatWhitespace(true);\n    } else if (this._ch === ';') {\n      if (parenLevel === 0) {\n        if (insidePropertyValue) {\n          this.outdent();\n          insidePropertyValue = false;\n        }\n        insideAtExtend = false;\n        insideAtImport = false;\n        this.print_string(this._ch);\n        this.eatWhitespace(true);\n\n        // This maintains single line comments on the same\n        // line. Block comments are also affected, but\n        // a new line is always output before one inside\n        // that section\n        if (this._input.peek() !== '/') {\n          this._output.add_new_line();\n        }\n      } else {\n        this.print_string(this._ch);\n        this.eatWhitespace(true);\n        this._output.space_before_token = true;\n      }\n    } else if (this._ch === '(') { // may be a url\n      if (this._input.lookBack(\"url\")) {\n        this.print_string(this._ch);\n        this.eatWhitespace();\n        parenLevel++;\n        this.indent();\n        this._ch = this._input.next();\n        if (this._ch === ')' || this._ch === '\"' || this._ch === '\\'') {\n          this._input.back();\n        } else if (this._ch) {\n          this.print_string(this._ch + this.eatString(')'));\n          if (parenLevel) {\n            parenLevel--;\n            this.outdent();\n          }\n        }\n      } else {\n        this.preserveSingleSpace(isAfterSpace);\n        this.print_string(this._ch);\n        this.eatWhitespace();\n        parenLevel++;\n        this.indent();\n      }\n    } else if (this._ch === ')') {\n      if (parenLevel) {\n        parenLevel--;\n        this.outdent();\n      }\n      this.print_string(this._ch);\n    } else if (this._ch === ',') {\n      this.print_string(this._ch);\n      this.eatWhitespace(true);\n      if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport) {\n        this._output.add_new_line();\n      } else {\n        this._output.space_before_token = true;\n      }\n    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {\n      //handle combinator spacing\n      if (this._options.space_around_combinator) {\n        this._output.space_before_token = true;\n        this.print_string(this._ch);\n        this._output.space_before_token = true;\n      } else {\n        this.print_string(this._ch);\n        this.eatWhitespace();\n        // squash extra whitespace\n        if (this._ch && whitespaceChar.test(this._ch)) {\n          this._ch = '';\n        }\n      }\n    } else if (this._ch === ']') {\n      this.print_string(this._ch);\n    } else if (this._ch === '[') {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch);\n    } else if (this._ch === '=') { // no whitespace before or after\n      this.eatWhitespace();\n      this.print_string('=');\n      if (whitespaceChar.test(this._ch)) {\n        this._ch = '';\n      }\n    } else if (this._ch === '!' && !this._input.lookBack(\"\\\\\")) { // !important\n      this.print_string(' ');\n      this.print_string(this._ch);\n    } else {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch);\n    }\n  }\n\n  var sweetCode = this._output.get_code(eol);\n\n  return sweetCode;\n};\n\nmodule.exports.Beautifier = Beautifier;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseOptions = __webpack_require__(6).Options;\n\nfunction Options(options) {\n  BaseOptions.call(this, options, 'css');\n\n  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);\n  this.newline_between_rules = this._get_boolean('newline_between_rules', true);\n  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');\n  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;\n\n}\nOptions.prototype = new BaseOptions();\n\n\n\nmodule.exports.Options = Options;\n\n\n/***/ })\n/******/ ]);\nvar css_beautify = legacy_beautify_css;\n/* Footer */\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return {\n            css_beautify: css_beautify\n        };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWNzcy5qcz80ZDdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDLEVBQUU7QUFDL0U7OztBQUdBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUJBQW1CLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LWNzcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cblxuIENTUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuICAgIFdyaXR0ZW4gYnkgSGFydXR5dW4gQW1pcmphbnlhbiwgKGFtaXJqYW55YW5AZ21haWwuY29tKVxuXG4gICAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBiZWF1dGlmaWVyLmlvPlxuICAgICAgICBodHRwczovL2JlYXV0aWZpZXIuaW8vXG5cbiAgICBVc2FnZTpcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0KTtcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICAgIFRoZSBvcHRpb25zIGFyZSAoZGVmYXVsdCBpbiBicmFja2V0cyk6XG4gICAgICAgIGluZGVudF9zaXplICg0KSAgICAgICAgICAgICAgICAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXIgKHNwYWNlKSAgICAgICAgICAgICAgICAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgICAgIHNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICh0cnVlKSAgICAgICAtIHNlcGFyYXRlIHNlbGVjdG9ycyB3aXRoIG5ld2xpbmUgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IChlLmcuIFwiYSxcXG5iclwiIG9yIFwiYSwgYnJcIilcbiAgICAgICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgICAgIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAodHJ1ZSkgICAgICAgICAgICAtIGFkZCBhIG5ldyBsaW5lIGFmdGVyIGV2ZXJ5IGNzcyBydWxlXG4gICAgICAgIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgKGZhbHNlKSAtIGVuc3VyZSBzcGFjZSBhcm91bmQgc2VsZWN0b3Igc2VwYXJhdG9yczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz4nLCAnKycsICd+JyAoZS5nLiBcImE+YlwiIC0+IFwiYSA+IGJcIilcbiAgICBlLmdcblxuICAgIGNzc19iZWF1dGlmeShjc3Nfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0JyxcbiAgICAgICdzZWxlY3Rvcl9zZXBhcmF0b3InOiAnICcsXG4gICAgICAnZW5kX3dpdGhfbmV3bGluZSc6IGZhbHNlLFxuICAgICAgJ25ld2xpbmVfYmV0d2Vlbl9ydWxlcyc6IHRydWUsXG4gICAgICAnc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcic6IHRydWVcbiAgICB9KTtcbiovXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN0b2tlbml6YXRpb25cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4L1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8qIEdFTkVSQVRFRF9CVUlMRF9PVVRQVVQgKi9cbnZhciBsZWdhY3lfYmVhdXRpZnlfY3NzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTUpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqLyxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovLFxuLyogNCAqLyxcbi8qIDUgKi8sXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQpLlxuICAvLyBvdGhlciB2YWx1ZXMgaWdub3JlZFxuICB0aGlzLnRlbXBsYXRpbmcgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ3RlbXBsYXRpbmcnLCBbJ2F1dG8nLCAnbm9uZScsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ10sIFsnYXV0byddKTtcbn1cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9hcnJheSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8IFtdO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0aW9uX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25fdmFsdWUuY29uY2F0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuY29uY2F0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC9cXC1dKy8pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2Jvb2xlYW4gPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlID09PSB1bmRlZmluZWQgPyAhIWRlZmF1bHRfdmFsdWUgOiAhIW9wdGlvbl92YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfY2hhcmFjdGVycyA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8ICcnO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvXFxcXHQvLCAnXFx0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfbnVtYmVyID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgZGVmYXVsdF92YWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRfdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKGRlZmF1bHRfdmFsdWUpKSB7XG4gICAgZGVmYXVsdF92YWx1ZSA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG9wdGlvbl92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdChuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uX2xpc3QgPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICBpZiAoIXNlbGVjdGlvbl9saXN0IHx8IHNlbGVjdGlvbl9saXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gIH1cblxuICBkZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF92YWx1ZSB8fCBbc2VsZWN0aW9uX2xpc3RbMF1dO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihkZWZhdWx0X3ZhbHVlLCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERlZmF1bHQgVmFsdWUhXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9hcnJheShuYW1lLCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIGNvbnRhaW4gb25seSB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5faXNfdmFsaWRfc2VsZWN0aW9uID0gZnVuY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkge1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAmJiBzZWxlY3Rpb25fbGlzdC5sZW5ndGggJiZcbiAgICAhcmVzdWx0LnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uX2xpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTE7IH0pO1xufTtcblxuXG4vLyBtZXJnZXMgY2hpbGQgb3B0aW9ucyB1cCB3aXRoIHRoZSBwYXJlbnQgb3B0aW9ucyBvYmplY3Rcbi8vIEV4YW1wbGU6IG9iaiA9IHthOiAxLCBiOiB7YTogMn19XG4vLyAgICAgICAgICBtZXJnZU9wdHMob2JqLCAnYicpXG4vL1xuLy8gICAgICAgICAgUmV0dXJuczoge2E6IDJ9XG5mdW5jdGlvbiBfbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIGNoaWxkRmllbGROYW1lKSB7XG4gIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgYWxsT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRzKGFsbE9wdGlvbnMpO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgIGlmIChuYW1lICE9PSBjaGlsZEZpZWxkTmFtZSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIGNoaWxkRmllbGROYW1lXG4gIGlmIChjaGlsZEZpZWxkTmFtZSAmJiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV1bbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVPcHRzKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnZlcnRlZE9wdHMgPSB7fTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5ld0tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICBjb252ZXJ0ZWRPcHRzW25ld0tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplT3B0cyA9IF9ub3JtYWxpemVPcHRzO1xubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gX21lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi8sXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgcmVnZXhwX2hhc19zdGlja3kgPSBSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzdGlja3knKTtcblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZykge1xuICB0aGlzLl9faW5wdXQgPSBpbnB1dF9zdHJpbmcgfHwgJyc7XG4gIHRoaXMuX19pbnB1dF9sZW5ndGggPSB0aGlzLl9faW5wdXQubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufVxuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3Bvc2l0aW9uID4gMCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiAtPSAxO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX19pbnB1dF9sZW5ndGg7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQodGhpcy5fX3Bvc2l0aW9uKTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyBhIEphdmFTY3JpcHQgb25seSBoZWxwZXIgZnVuY3Rpb24gKG5vdCBpbiBweXRob24pXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoIG1ldGhvZFxuLy8gYW5kIG5vdCBhbGwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCBcInN0aWNreVwiIGZsYWcuXG4vLyBJZiB0aGV5IGRvIG5vdCBzdXBwb3J0IHN0aWNreSB0aGVuIGJvdGggdGhpcy5tYXRjaCgpIGFuZCB0aGlzLnRlc3QoKSBtZXRob2Rcbi8vIG11c3QgZ2V0IHRoZSBtYXRjaCBhbmQgY2hlY2sgdGhlIGluZGV4IG9mIHRoZSBtYXRjaC5cbi8vIElmIHN0aWNreSBpcyBzdXBwb3J0ZWQgYW5kIHNldCwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBjaGVjayB0aGF0IGdsb2JhbCBpcyBzZXQsIGFuZCBmYWxsIGJhY2sgdG8gdGhlIHNsb3dlciBtZXRob2QuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLl9fbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IGluZGV4O1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuXG4gIGlmIChwYXR0ZXJuX21hdGNoICYmICEocmVnZXhwX2hhc19zdGlja3kgJiYgcGF0dGVybi5zdGlja3kpKSB7XG4gICAgaWYgKHBhdHRlcm5fbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuXG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHJldHVybiAhIXRoaXMuX19tYXRjaChwYXR0ZXJuLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgLy8gdGVzdCBvbmUgY2hhcmFjdGVyIHJlZ2V4IG1hdGNoXG4gIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHRoaXMuX19tYXRjaChwYXR0ZXJuLCB0aGlzLl9fcG9zaXRpb24pO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHN0YXJ0aW5nX3BhdHRlcm4sIHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoO1xuICBpZiAoc3RhcnRpbmdfcGF0dGVybikge1xuICAgIG1hdGNoID0gdGhpcy5tYXRjaChzdGFydGluZ19wYXR0ZXJuKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhbCArPSBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgaWYgKHVudGlsX3BhdHRlcm4gJiYgKG1hdGNoIHx8ICFzdGFydGluZ19wYXR0ZXJuKSkge1xuICAgIHZhbCArPSB0aGlzLnJlYWRVbnRpbCh1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsID0gZnVuY3Rpb24ocGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2hfaW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIG1hdGNoX2luZGV4ID0gcGF0dGVybl9tYXRjaC5pbmRleDtcbiAgICBpZiAodW50aWxfYWZ0ZXIpIHtcbiAgICAgIG1hdGNoX2luZGV4ICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRjaF9pbmRleCA9IHRoaXMuX19pbnB1dF9sZW5ndGg7XG4gIH1cblxuICB2YWwgPSB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHRoaXMuX19wb3NpdGlvbiwgbWF0Y2hfaW5kZXgpO1xuICB0aGlzLl9fcG9zaXRpb24gPSBtYXRjaF9pbmRleDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLnJlYWRVbnRpbChwYXR0ZXJuLCB0cnVlKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG1hdGNoX2Zyb20pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBmbGFncyA9ICdnJztcbiAgaWYgKG1hdGNoX2Zyb20gJiYgcmVnZXhwX2hhc19zdGlja3kpIHtcbiAgICBmbGFncyA9ICd5JztcbiAgfVxuICAvLyBzdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gcmVnZXhwXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICE9PSAnJykge1xuICAgIC8vIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSwgZmxhZ3MpO1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGVsc2UgaWYgKHBhdHRlcm4pIHtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X2xpdGVyYWxfcmVnZXhwID0gZnVuY3Rpb24obGl0ZXJhbF9zdHJpbmcpIHtcbiAgcmV0dXJuIFJlZ0V4cChsaXRlcmFsX3N0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSk7XG59O1xuXG4vKiBjc3MgYmVhdXRpZmllciBsZWdhY3kgaGVscGVycyAqL1xuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgdmFsID0gdGhpcy5yZWFkVW50aWxBZnRlcihwYXR0ZXJuKTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmxvb2tCYWNrID0gZnVuY3Rpb24odGVzdFZhbCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb24gLSAxO1xuICByZXR1cm4gc3RhcnQgPj0gdGVzdFZhbC5sZW5ndGggJiYgdGhpcy5fX2lucHV0LnN1YnN0cmluZyhzdGFydCAtIHRlc3RWYWwubGVuZ3RoLCBzdGFydClcbiAgICAudG9Mb3dlckNhc2UoKSA9PT0gdGVzdFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi8sXG4vKiAxMCAqLyxcbi8qIDExICovLFxuLyogMTIgKi8sXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gRGlyZWN0aXZlcyhzdGFydF9ibG9ja19wYXR0ZXJuLCBlbmRfYmxvY2tfcGF0dGVybikge1xuICBzdGFydF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gc3RhcnRfYmxvY2tfcGF0dGVybiA6IHN0YXJ0X2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICBlbmRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBlbmRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBlbmRfYmxvY2tfcGF0dGVybiA6IGVuZF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgdGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC8gYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcblxuICB0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbn1cblxuRGlyZWN0aXZlcy5wcm90b3R5cGUuZ2V0X2RpcmVjdGl2ZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGV4dC5tYXRjaCh0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGl2ZXM7XG59O1xuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5yZWFkSWdub3JlZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5EaXJlY3RpdmVzID0gRGlyZWN0aXZlcztcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNikuQmVhdXRpZmllcixcbiAgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIE9wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KS5PcHRpb25zO1xudmFyIE91dHB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oMikuT3V0cHV0O1xudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyO1xudmFyIERpcmVjdGl2ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5EaXJlY3RpdmVzO1xuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoL1xcL1xcKi8sIC9cXCpcXC8vKTtcblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcbl0vO1xudmFyIGFsbExpbmVCcmVha3MgPSAvXFxyXFxufFtcXHJcXG5dL2c7XG5cbi8vIHRva2VuaXplclxudmFyIHdoaXRlc3BhY2VDaGFyID0gL1xccy87XG52YXIgd2hpdGVzcGFjZVBhdHRlcm4gPSAvKD86XFxzfFxcbikrL2c7XG52YXIgYmxvY2tfY29tbWVudF9wYXR0ZXJuID0gL1xcL1xcKig/OltcXHNcXFNdKj8pKCg/OlxcKlxcLyl8JCkvZztcbnZhciBjb21tZW50X3BhdHRlcm4gPSAvXFwvXFwvKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOV0qKS9nO1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIHRoaXMuX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG4gIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICB0aGlzLl9vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX2NoID0gbnVsbDtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9BdC1ydWxlXG4gIHRoaXMuTkVTVEVEX0FUX1JVTEUgPSB7XG4gICAgXCJAcGFnZVwiOiB0cnVlLFxuICAgIFwiQGZvbnQtZmFjZVwiOiB0cnVlLFxuICAgIFwiQGtleWZyYW1lc1wiOiB0cnVlLFxuICAgIC8vIGFsc28gaW4gQ09ORElUSU9OQUxfR1JPVVBfUlVMRSBiZWxvd1xuICAgIFwiQG1lZGlhXCI6IHRydWUsXG4gICAgXCJAc3VwcG9ydHNcIjogdHJ1ZSxcbiAgICBcIkBkb2N1bWVudFwiOiB0cnVlXG4gIH07XG4gIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSA9IHtcbiAgICBcIkBtZWRpYVwiOiB0cnVlLFxuICAgIFwiQHN1cHBvcnRzXCI6IHRydWUsXG4gICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICB9O1xuXG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmVhdFN0cmluZyA9IGZ1bmN0aW9uKGVuZENoYXJzKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIHdoaWxlICh0aGlzLl9jaCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9jaDtcbiAgICBpZiAodGhpcy5fY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoZW5kQ2hhcnMuaW5kZXhPZih0aGlzLl9jaCkgIT09IC0xIHx8IHRoaXMuX2NoID09PSBcIlxcblwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFNraXBzIGFueSB3aGl0ZSBzcGFjZSBpbiB0aGUgc291cmNlIHRleHQgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbi8vIFdoZW4gYWxsb3dBdExlYXN0T25lTmV3TGluZSBpcyB0cnVlLCB3aWxsIG91dHB1dCBuZXcgbGluZXMgZm9yIGVhY2hcbi8vIG5ld2xpbmUgY2hhcmFjdGVyIGZvdW5kOyBpZiB0aGUgdXNlciBoYXMgcHJlc2VydmVfbmV3bGluZXMgb2ZmLCBvbmx5XG4vLyB0aGUgZmlyc3QgbmV3bGluZSB3aWxsIGJlIG91dHB1dFxuQmVhdXRpZmllci5wcm90b3R5cGUuZWF0V2hpdGVzcGFjZSA9IGZ1bmN0aW9uKGFsbG93QXRMZWFzdE9uZU5ld0xpbmUpIHtcbiAgdmFyIHJlc3VsdCA9IHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5faW5wdXQucGVlaygpKTtcbiAgdmFyIGlzRmlyc3ROZXdMaW5lID0gdHJ1ZTtcblxuICB3aGlsZSAod2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9pbnB1dC5wZWVrKCkpKSB7XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKGFsbG93QXRMZWFzdE9uZU5ld0xpbmUgJiYgdGhpcy5fY2ggPT09ICdcXG4nKSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyB8fCBpc0ZpcnN0TmV3TGluZSkge1xuICAgICAgICBpc0ZpcnN0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gTmVzdGVkIHBzZXVkby1jbGFzcyBpZiB3ZSBhcmUgaW5zaWRlUnVsZVxuLy8gYW5kIHRoZSBuZXh0IHNwZWNpYWwgY2hhcmFjdGVyIGZvdW5kIG9wZW5zXG4vLyBhIG5ldyBibG9ja1xuQmVhdXRpZmllci5wcm90b3R5cGUuZm91bmROZXN0ZWRQc2V1ZG9DbGFzcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3BlblBhcmVuID0gMDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5wZWVrKGkpO1xuICB3aGlsZSAoY2gpIHtcbiAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgIC8vIHBzZXVkb2NsYXNzZXMgY2FuIGNvbnRhaW4gKClcbiAgICAgIG9wZW5QYXJlbiArPSAxO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgaWYgKG9wZW5QYXJlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvcGVuUGFyZW4gLT0gMTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIjtcIiB8fCBjaCA9PT0gXCJ9XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaSsrO1xuICAgIGNoID0gdGhpcy5faW5wdXQucGVlayhpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF9zdHJpbmcgPSBmdW5jdGlvbihvdXRwdXRfc3RyaW5nKSB7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2luZGVudExldmVsKTtcbiAgdGhpcy5fb3V0cHV0Lm5vbl9icmVha2luZ19zcGFjZSA9IHRydWU7XG4gIHRoaXMuX291dHB1dC5hZGRfdG9rZW4ob3V0cHV0X3N0cmluZyk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmVzZXJ2ZVNpbmdsZVNwYWNlID0gZnVuY3Rpb24oaXNBZnRlclNwYWNlKSB7XG4gIGlmIChpc0FmdGVyU3BhY2UpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2luZGVudExldmVsKys7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5vdXRkZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9pbmRlbnRMZXZlbCA+IDApIHtcbiAgICB0aGlzLl9pbmRlbnRMZXZlbC0tO1xuICB9XG59O1xuXG4vKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuQmVhdXRpZmllci5wcm90b3R5cGUuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAoZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgbGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSB0aGlzLl9pbnB1dC5cbiAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAvLyByZXNldFxuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMuX2lucHV0ID0gbmV3IElucHV0U2Nhbm5lcihzb3VyY2VfdGV4dCk7XG4gIHRoaXMuX2luZGVudExldmVsID0gMDtcbiAgdGhpcy5fbmVzdGVkTGV2ZWwgPSAwO1xuXG4gIHRoaXMuX2NoID0gbnVsbDtcbiAgdmFyIHBhcmVuTGV2ZWwgPSAwO1xuXG4gIHZhciBpbnNpZGVSdWxlID0gZmFsc2U7XG4gIC8vIFRoaXMgaXMgdGhlIHZhbHVlIHNpZGUgb2YgYSBwcm9wZXJ0eSB2YWx1ZSBwYWlyIChibHVlIGluIHRoZSBmb2xsb3dpbmcgZXgpXG4gIC8vIGxhYmVsIHsgY29udGVudDogYmx1ZSB9XG4gIHZhciBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gIHZhciBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgdmFyIGluc2lkZUF0RXh0ZW5kID0gZmFsc2U7XG4gIHZhciBpbnNpZGVBdEltcG9ydCA9IGZhbHNlO1xuICB2YXIgdG9wQ2hhcmFjdGVyID0gdGhpcy5fY2g7XG4gIHZhciB3aGl0ZXNwYWNlO1xuICB2YXIgaXNBZnRlclNwYWNlO1xuICB2YXIgcHJldmlvdXNfY2g7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB3aGl0ZXNwYWNlID0gdGhpcy5faW5wdXQucmVhZCh3aGl0ZXNwYWNlUGF0dGVybik7XG4gICAgaXNBZnRlclNwYWNlID0gd2hpdGVzcGFjZSAhPT0gJyc7XG4gICAgcHJldmlvdXNfY2ggPSB0b3BDaGFyYWN0ZXI7XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKHRoaXMuX2NoID09PSAnXFxcXCcgJiYgdGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICB0aGlzLl9jaCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfVxuICAgIHRvcENoYXJhY3RlciA9IHRoaXMuX2NoO1xuXG4gICAgaWYgKCF0aGlzLl9jaCkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJyonKSB7XG4gICAgICAvLyAvKiBjc3MgY29tbWVudCAqL1xuICAgICAgLy8gQWx3YXlzIHN0YXJ0IGJsb2NrIGNvbW1lbnRzIG9uIGEgbmV3IGxpbmUuXG4gICAgICAvLyBUaGlzIGhhbmRsZXMgc2NlbmFyaW9zIHdoZXJlIGEgYmxvY2sgY29tbWVudCBpbW1lZGlhdGVseVxuICAgICAgLy8gZm9sbG93cyBhIHByb3BlcnR5IGRlZmluaXRpb24gb24gdGhlIHNhbWUgbGluZSBvciB3aGVyZVxuICAgICAgLy8gbWluaWZpZWQgY29kZSBpcyBiZWluZyBiZWF1dGlmaWVkLlxuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuXG4gICAgICB2YXIgY29tbWVudCA9IHRoaXMuX2lucHV0LnJlYWQoYmxvY2tfY29tbWVudF9wYXR0ZXJuKTtcblxuICAgICAgLy8gSGFuZGxlIGlnbm9yZSBkaXJlY3RpdmVcbiAgICAgIHZhciBkaXJlY3RpdmVzID0gZGlyZWN0aXZlc19jb3JlLmdldF9kaXJlY3RpdmVzKGNvbW1lbnQpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5pZ25vcmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgY29tbWVudCArPSBkaXJlY3RpdmVzX2NvcmUucmVhZElnbm9yZWQodGhpcy5faW5wdXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByaW50X3N0cmluZyhjb21tZW50KTtcblxuICAgICAgLy8gRW5zdXJlcyBhbnkgbmV3IGxpbmVzIGZvbGxvd2luZyB0aGUgY29tbWVudCBhcmUgcHJlc2VydmVkXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG5cbiAgICAgIC8vIEJsb2NrIGNvbW1lbnRzIGFyZSBmb2xsb3dlZCBieSBhIG5ldyBsaW5lIHNvIHRoZXkgZG9uJ3RcbiAgICAgIC8vIHNoYXJlIGEgbGluZSB3aXRoIG90aGVyIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnLycgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgIC8vIC8vIHNpbmdsZSBsaW5lIGNvbW1lbnRcbiAgICAgIC8vIFByZXNlcnZlcyB0aGUgc3BhY2UgYmVmb3JlIGEgY29tbWVudFxuICAgICAgLy8gb24gdGhlIHNhbWUgbGluZSBhcyBhIHJ1bGVcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5faW5wdXQucmVhZChjb21tZW50X3BhdHRlcm4pKTtcblxuICAgICAgLy8gRW5zdXJlcyBhbnkgbmV3IGxpbmVzIGZvbGxvd2luZyB0aGUgY29tbWVudCBhcmUgcHJlc2VydmVkXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ0AnKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcblxuICAgICAgLy8gZGVhbCB3aXRoIGxlc3MgcHJvcGVyeSBtaXhpbnMgQHsuLi59XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAneycpIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZygnfScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcblxuICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZSwgaWYgcHJlc2VudCwgZm9yIGhhc2ggcHJvcGVydHkgY2hlY2tzXG4gICAgICAgIHZhciB2YXJpYWJsZU9yUnVsZSA9IHRoaXMuX2lucHV0LnBlZWtVbnRpbEFmdGVyKC9bOiAsO3t9KClbXFxdXFwvPSdcIl0vZyk7XG5cbiAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlLm1hdGNoKC9bIDpdJC8pKSB7XG4gICAgICAgICAgLy8gd2UgaGF2ZSBhIHZhcmlhYmxlIG9yIHBzZXVkby1jbGFzcywgYWRkIGl0IGFuZCBpbnNlcnQgb25lIHNwYWNlIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgdmFyaWFibGVPclJ1bGUgPSB0aGlzLmVhdFN0cmluZyhcIjogXCIpLnJlcGxhY2UoL1xccyQvLCAnJyk7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodmFyaWFibGVPclJ1bGUpO1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyaWFibGVPclJ1bGUgPSB2YXJpYWJsZU9yUnVsZS5yZXBsYWNlKC9cXHMkLywgJycpO1xuXG4gICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSA9PT0gJ2V4dGVuZCcpIHtcbiAgICAgICAgICBpbnNpZGVBdEV4dGVuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFyaWFibGVPclJ1bGUgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgICAgaW5zaWRlQXRJbXBvcnQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWlnaHQgYmUgYSBuZXN0aW5nIGF0LXJ1bGVcbiAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIHRoaXMuTkVTVEVEX0FUX1JVTEUpIHtcbiAgICAgICAgICB0aGlzLl9uZXN0ZWRMZXZlbCArPSAxO1xuICAgICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLkNPTkRJVElPTkFMX0dST1VQX1JVTEUpIHtcbiAgICAgICAgICAgIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1pZ2h0IGJlIGxlc3MgdmFyaWFibGVcbiAgICAgICAgfSBlbHNlIGlmICghaW5zaWRlUnVsZSAmJiBwYXJlbkxldmVsID09PSAwICYmIHZhcmlhYmxlT3JSdWxlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyMnICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcoJ30nKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ3snKSB7XG4gICAgICBpZiAoaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuXG4gICAgICAvLyB3aGVuIGVudGVyaW5nIGNvbmRpdGlvbmFsIGdyb3Vwcywgb25seSBydWxlc2V0cyBhcmUgYWxsb3dlZFxuICAgICAgaWYgKGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkge1xuICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgaW5zaWRlUnVsZSA9ICh0aGlzLl9pbmRlbnRMZXZlbCA+IHRoaXMuX25lc3RlZExldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgZGVjbGFyYXRpb25zIGFyZSBhbHNvIGFsbG93ZWRcbiAgICAgICAgaW5zaWRlUnVsZSA9ICh0aGlzLl9pbmRlbnRMZXZlbCA+PSB0aGlzLl9uZXN0ZWRMZXZlbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5uZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgaW5zaWRlUnVsZSkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUgJiYgdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUuaXRlbSgtMSkgIT09ICd7Jykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5lbnN1cmVfZW1wdHlfbGluZV9hYm92ZSgnLycsICcsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnfScpIHtcbiAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgaWYgKHByZXZpb3VzX2NoID09PSAneycpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICB9XG4gICAgICBpbnNpZGVBdEltcG9ydCA9IGZhbHNlO1xuICAgICAgaW5zaWRlQXRFeHRlbmQgPSBmYWxzZTtcbiAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5fbmVzdGVkTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbmVzdGVkTGV2ZWwtLTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5uZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICd9Jykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSBcIjpcIikge1xuICAgICAgaWYgKChpbnNpZGVSdWxlIHx8IGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkgJiYgISh0aGlzLl9pbnB1dC5sb29rQmFjayhcIiZcIikgfHwgdGhpcy5mb3VuZE5lc3RlZFBzZXVkb0NsYXNzKCkpICYmICF0aGlzLl9pbnB1dC5sb29rQmFjayhcIihcIikgJiYgIWluc2lkZUF0RXh0ZW5kICYmIHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgICAgLy8gJ3Byb3BlcnR5OiB2YWx1ZScgZGVsaW1pdGVyXG4gICAgICAgIC8vIHdoaWNoIGNvdWxkIGJlIGluIGEgY29uZGl0aW9uYWwgZ3JvdXAgcXVlcnlcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgaWYgKCFpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNhc3MvbGVzcyBwYXJlbnQgcmVmZXJlbmNlIGRvbid0IHVzZSBhIHNwYWNlXG4gICAgICAgIC8vIHNhc3MgbmVzdGVkIHBzZXVkby1jbGFzcyBkb24ndCB1c2UgYSBzcGFjZVxuXG4gICAgICAgIC8vIHByZXNlcnZlIHNwYWNlIGJlZm9yZSBwc2V1ZG9jbGFzc2VzL3BzZXVkb2VsZW1lbnRzLCBhcyBpdCBtZWFucyBcImluIGFueSBjaGlsZFwiXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcIiBcIikpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSBcIjpcIikge1xuICAgICAgICAgIC8vIHBzZXVkby1lbGVtZW50XG4gICAgICAgICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoXCI6OlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3NcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZygnOicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ1wiJyB8fCB0aGlzLl9jaCA9PT0gJ1xcJycpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZyh0aGlzLl9jaCkpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICc7Jykge1xuICAgICAgaWYgKHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5zaWRlQXRFeHRlbmQgPSBmYWxzZTtcbiAgICAgICAgaW5zaWRlQXRJbXBvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYWludGFpbnMgc2luZ2xlIGxpbmUgY29tbWVudHMgb24gdGhlIHNhbWVcbiAgICAgICAgLy8gbGluZS4gQmxvY2sgY29tbWVudHMgYXJlIGFsc28gYWZmZWN0ZWQsIGJ1dFxuICAgICAgICAvLyBhIG5ldyBsaW5lIGlzIGFsd2F5cyBvdXRwdXQgYmVmb3JlIG9uZSBpbnNpZGVcbiAgICAgICAgLy8gdGhhdCBzZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICcvJykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcoJykgeyAvLyBtYXkgYmUgYSB1cmxcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcInVybFwiKSkge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5fY2ggPT09ICcpJyB8fCB0aGlzLl9jaCA9PT0gJ1wiJyB8fCB0aGlzLl9jaCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2gpIHtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCArIHRoaXMuZWF0U3RyaW5nKCcpJykpO1xuICAgICAgICAgIGlmIChwYXJlbkxldmVsKSB7XG4gICAgICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyknKSB7XG4gICAgICBpZiAocGFyZW5MZXZlbCkge1xuICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcsJykge1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA9PT0gMCAmJiAhaW5zaWRlQXRJbXBvcnQpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodGhpcy5fY2ggPT09ICc+JyB8fCB0aGlzLl9jaCA9PT0gJysnIHx8IHRoaXMuX2NoID09PSAnficpICYmICFpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgIC8vaGFuZGxlIGNvbWJpbmF0b3Igc3BhY2luZ1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAvLyBzcXVhc2ggZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBpZiAodGhpcy5fY2ggJiYgd2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9jaCkpIHtcbiAgICAgICAgICB0aGlzLl9jaCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ10nKSB7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ1snKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnPScpIHsgLy8gbm8gd2hpdGVzcGFjZSBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcoJz0nKTtcbiAgICAgIGlmICh3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2NoKSkge1xuICAgICAgICB0aGlzLl9jaCA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICchJyAmJiAhdGhpcy5faW5wdXQubG9va0JhY2soXCJcXFxcXCIpKSB7IC8vICFpbXBvcnRhbnRcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCcgJyk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzd2VldENvZGUgPSB0aGlzLl9vdXRwdXQuZ2V0X2NvZGUoZW9sKTtcblxuICByZXR1cm4gc3dlZXRDb2RlO1xufTtcblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnY3NzJyk7XG5cbiAgdGhpcy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZScsIHRydWUpO1xuICB0aGlzLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9IHRoaXMuX2dldF9ib29sZWFuKCduZXdsaW5lX2JldHdlZW5fcnVsZXMnLCB0cnVlKTtcbiAgdmFyIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcicpO1xuICB0aGlzLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2Fyb3VuZF9jb21iaW5hdG9yJykgfHwgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcjtcblxufVxuT3B0aW9ucy5wcm90b3R5cGUgPSBuZXcgQmFzZU9wdGlvbnMoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBjc3NfYmVhdXRpZnkgPSBsZWdhY3lfYmVhdXRpZnlfY3NzO1xuLyogRm9vdGVyICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3NzX2JlYXV0aWZ5OiBjc3NfYmVhdXRpZnlcbiAgICAgICAgfTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBodG1sX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmh0bWxfYmVhdXRpZnlgLlxuICAgIGV4cG9ydHMuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgIHdpbmRvdy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59XG5cbn0oKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/lib/beautify-css.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/lib/beautify-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-html.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n    https://beautifier.io/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)  — indent <head> and <body> sections,\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    inline (defaults to inline tags) - list of tags to be considered inline tags\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    content_unformatted (defaults to [\"pre\", \"textarea\"] tags) - list of tags, whose content shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/\n\n(function() {\n\n/* GENERATED_BUILD_OUTPUT */\nvar legacy_beautify_html =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 18);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction OutputLine(parent) {\n  this.__parent = parent;\n  this.__character_count = 0;\n  // use indent_count as a marker for this.__lines that have preserved indentation\n  this.__indent_count = -1;\n  this.__alignment_count = 0;\n  this.__wrap_point_index = 0;\n  this.__wrap_point_character_count = 0;\n  this.__wrap_point_indent_count = -1;\n  this.__wrap_point_alignment_count = 0;\n\n  this.__items = [];\n}\n\nOutputLine.prototype.clone_empty = function() {\n  var line = new OutputLine(this.__parent);\n  line.set_indent(this.__indent_count, this.__alignment_count);\n  return line;\n};\n\nOutputLine.prototype.item = function(index) {\n  if (index < 0) {\n    return this.__items[this.__items.length + index];\n  } else {\n    return this.__items[index];\n  }\n};\n\nOutputLine.prototype.has_match = function(pattern) {\n  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n    if (this.__items[lastCheckedOutput].match(pattern)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nOutputLine.prototype.set_indent = function(indent, alignment) {\n  if (this.is_empty()) {\n    this.__indent_count = indent || 0;\n    this.__alignment_count = alignment || 0;\n    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n  }\n};\n\nOutputLine.prototype._set_wrap_point = function() {\n  if (this.__parent.wrap_line_length) {\n    this.__wrap_point_index = this.__items.length;\n    this.__wrap_point_character_count = this.__character_count;\n    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n  }\n};\n\nOutputLine.prototype._should_wrap = function() {\n  return this.__wrap_point_index &&\n    this.__character_count > this.__parent.wrap_line_length &&\n    this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n};\n\nOutputLine.prototype._allow_wrap = function() {\n  if (this._should_wrap()) {\n    this.__parent.add_new_line();\n    var next = this.__parent.current_line;\n    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n    next.__items = this.__items.slice(this.__wrap_point_index);\n    this.__items = this.__items.slice(0, this.__wrap_point_index);\n\n    next.__character_count += this.__character_count - this.__wrap_point_character_count;\n    this.__character_count = this.__wrap_point_character_count;\n\n    if (next.__items[0] === \" \") {\n      next.__items.splice(0, 1);\n      next.__character_count -= 1;\n    }\n    return true;\n  }\n  return false;\n};\n\nOutputLine.prototype.is_empty = function() {\n  return this.__items.length === 0;\n};\n\nOutputLine.prototype.last = function() {\n  if (!this.is_empty()) {\n    return this.__items[this.__items.length - 1];\n  } else {\n    return null;\n  }\n};\n\nOutputLine.prototype.push = function(item) {\n  this.__items.push(item);\n  var last_newline_index = item.lastIndexOf('\\n');\n  if (last_newline_index !== -1) {\n    this.__character_count = item.length - last_newline_index;\n  } else {\n    this.__character_count += item.length;\n  }\n};\n\nOutputLine.prototype.pop = function() {\n  var item = null;\n  if (!this.is_empty()) {\n    item = this.__items.pop();\n    this.__character_count -= item.length;\n  }\n  return item;\n};\n\n\nOutputLine.prototype._remove_indent = function() {\n  if (this.__indent_count > 0) {\n    this.__indent_count -= 1;\n    this.__character_count -= this.__parent.indent_size;\n  }\n};\n\nOutputLine.prototype._remove_wrap_indent = function() {\n  if (this.__wrap_point_indent_count > 0) {\n    this.__wrap_point_indent_count -= 1;\n  }\n};\nOutputLine.prototype.trim = function() {\n  while (this.last() === ' ') {\n    this.__items.pop();\n    this.__character_count -= 1;\n  }\n};\n\nOutputLine.prototype.toString = function() {\n  var result = '';\n  if (this.is_empty()) {\n    if (this.__parent.indent_empty_lines) {\n      result = this.__parent.get_indent_string(this.__indent_count);\n    }\n  } else {\n    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n    result += this.__items.join('');\n  }\n  return result;\n};\n\nfunction IndentStringCache(options, baseIndentString) {\n  this.__cache = [''];\n  this.__indent_size = options.indent_size;\n  this.__indent_string = options.indent_char;\n  if (!options.indent_with_tabs) {\n    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n  }\n\n  // Set to null to continue support for auto detection of base indent\n  baseIndentString = baseIndentString || '';\n  if (options.indent_level > 0) {\n    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n  }\n\n  this.__base_string = baseIndentString;\n  this.__base_string_length = baseIndentString.length;\n}\n\nIndentStringCache.prototype.get_indent_size = function(indent, column) {\n  var result = this.__base_string_length;\n  column = column || 0;\n  if (indent < 0) {\n    result = 0;\n  }\n  result += indent * this.__indent_size;\n  result += column;\n  return result;\n};\n\nIndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n  var result = this.__base_string;\n  column = column || 0;\n  if (indent_level < 0) {\n    indent_level = 0;\n    result = '';\n  }\n  column += indent_level * this.__indent_size;\n  this.__ensure_cache(column);\n  result += this.__cache[column];\n  return result;\n};\n\nIndentStringCache.prototype.__ensure_cache = function(column) {\n  while (column >= this.__cache.length) {\n    this.__add_column();\n  }\n};\n\nIndentStringCache.prototype.__add_column = function() {\n  var column = this.__cache.length;\n  var indent = 0;\n  var result = '';\n  if (this.__indent_size && column >= this.__indent_size) {\n    indent = Math.floor(column / this.__indent_size);\n    column -= indent * this.__indent_size;\n    result = new Array(indent + 1).join(this.__indent_string);\n  }\n  if (column) {\n    result += new Array(column + 1).join(' ');\n  }\n\n  this.__cache.push(result);\n};\n\nfunction Output(options, baseIndentString) {\n  this.__indent_cache = new IndentStringCache(options, baseIndentString);\n  this.raw = false;\n  this._end_with_newline = options.end_with_newline;\n  this.indent_size = options.indent_size;\n  this.wrap_line_length = options.wrap_line_length;\n  this.indent_empty_lines = options.indent_empty_lines;\n  this.__lines = [];\n  this.previous_line = null;\n  this.current_line = null;\n  this.next_line = new OutputLine(this);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n  // initialize\n  this.__add_outputline();\n}\n\nOutput.prototype.__add_outputline = function() {\n  this.previous_line = this.current_line;\n  this.current_line = this.next_line.clone_empty();\n  this.__lines.push(this.current_line);\n};\n\nOutput.prototype.get_line_number = function() {\n  return this.__lines.length;\n};\n\nOutput.prototype.get_indent_string = function(indent, column) {\n  return this.__indent_cache.get_indent_string(indent, column);\n};\n\nOutput.prototype.get_indent_size = function(indent, column) {\n  return this.__indent_cache.get_indent_size(indent, column);\n};\n\nOutput.prototype.is_empty = function() {\n  return !this.previous_line && this.current_line.is_empty();\n};\n\nOutput.prototype.add_new_line = function(force_newline) {\n  // never newline at the start of file\n  // otherwise, newline only if we didn't just add one or we're forced\n  if (this.is_empty() ||\n    (!force_newline && this.just_added_newline())) {\n    return false;\n  }\n\n  // if raw output is enabled, don't print additional newlines,\n  // but still return True as though you had\n  if (!this.raw) {\n    this.__add_outputline();\n  }\n  return true;\n};\n\nOutput.prototype.get_code = function(eol) {\n  this.trim(true);\n\n  // handle some edge cases where the last tokens\n  // has text that ends with newline(s)\n  var last_item = this.current_line.pop();\n  if (last_item) {\n    if (last_item[last_item.length - 1] === '\\n') {\n      last_item = last_item.replace(/\\n+$/g, '');\n    }\n    this.current_line.push(last_item);\n  }\n\n  if (this._end_with_newline) {\n    this.__add_outputline();\n  }\n\n  var sweet_code = this.__lines.join('\\n');\n\n  if (eol !== '\\n') {\n    sweet_code = sweet_code.replace(/[\\n]/g, eol);\n  }\n  return sweet_code;\n};\n\nOutput.prototype.set_wrap_point = function() {\n  this.current_line._set_wrap_point();\n};\n\nOutput.prototype.set_indent = function(indent, alignment) {\n  indent = indent || 0;\n  alignment = alignment || 0;\n\n  // Next line stores alignment values\n  this.next_line.set_indent(indent, alignment);\n\n  // Never indent your first output indent at the start of the file\n  if (this.__lines.length > 1) {\n    this.current_line.set_indent(indent, alignment);\n    return true;\n  }\n\n  this.current_line.set_indent();\n  return false;\n};\n\nOutput.prototype.add_raw_token = function(token) {\n  for (var x = 0; x < token.newlines; x++) {\n    this.__add_outputline();\n  }\n  this.current_line.set_indent(-1);\n  this.current_line.push(token.whitespace_before);\n  this.current_line.push(token.text);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n};\n\nOutput.prototype.add_token = function(printable_token) {\n  this.__add_space_before_token();\n  this.current_line.push(printable_token);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = this.current_line._allow_wrap();\n};\n\nOutput.prototype.__add_space_before_token = function() {\n  if (this.space_before_token && !this.just_added_newline()) {\n    if (!this.non_breaking_space) {\n      this.set_wrap_point();\n    }\n    this.current_line.push(' ');\n  }\n};\n\nOutput.prototype.remove_indent = function(index) {\n  var output_length = this.__lines.length;\n  while (index < output_length) {\n    this.__lines[index]._remove_indent();\n    index++;\n  }\n  this.current_line._remove_wrap_indent();\n};\n\nOutput.prototype.trim = function(eat_newlines) {\n  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n  this.current_line.trim();\n\n  while (eat_newlines && this.__lines.length > 1 &&\n    this.current_line.is_empty()) {\n    this.__lines.pop();\n    this.current_line = this.__lines[this.__lines.length - 1];\n    this.current_line.trim();\n  }\n\n  this.previous_line = this.__lines.length > 1 ?\n    this.__lines[this.__lines.length - 2] : null;\n};\n\nOutput.prototype.just_added_newline = function() {\n  return this.current_line.is_empty();\n};\n\nOutput.prototype.just_added_blankline = function() {\n  return this.is_empty() ||\n    (this.current_line.is_empty() && this.previous_line.is_empty());\n};\n\nOutput.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n  var index = this.__lines.length - 2;\n  while (index >= 0) {\n    var potentialEmptyLine = this.__lines[index];\n    if (potentialEmptyLine.is_empty()) {\n      break;\n    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&\n      potentialEmptyLine.item(-1) !== ends_with) {\n      this.__lines.splice(index + 1, 0, new OutputLine(this));\n      this.previous_line = this.__lines[this.__lines.length - 2];\n      break;\n    }\n    index--;\n  }\n};\n\nmodule.exports.Output = Output;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Token(type, text, newlines, whitespace_before) {\n  this.type = type;\n  this.text = text;\n\n  // comments_before are\n  // comments that have a new line before them\n  // and may or may not have a newline after\n  // this is a set of comments before\n  this.comments_before = null; /* inline comment*/\n\n\n  // this.comments_after =  new TokenStream(); // no new line before and newline after\n  this.newlines = newlines || 0;\n  this.whitespace_before = whitespace_before || '';\n  this.parent = null;\n  this.next = null;\n  this.previous = null;\n  this.opened = null;\n  this.closed = null;\n  this.directives = null;\n}\n\n\nmodule.exports.Token = Token;\n\n\n/***/ }),\n/* 4 */,\n/* 5 */,\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Options(options, merge_child_field) {\n  this.raw_options = _mergeOpts(options, merge_child_field);\n\n  // Support passing the source text back with no change\n  this.disabled = this._get_boolean('disabled');\n\n  this.eol = this._get_characters('eol', 'auto');\n  this.end_with_newline = this._get_boolean('end_with_newline');\n  this.indent_size = this._get_number('indent_size', 4);\n  this.indent_char = this._get_characters('indent_char', ' ');\n  this.indent_level = this._get_number('indent_level');\n\n  this.preserve_newlines = this._get_boolean('preserve_newlines', true);\n  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);\n  if (!this.preserve_newlines) {\n    this.max_preserve_newlines = 0;\n  }\n\n  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\\t');\n  if (this.indent_with_tabs) {\n    this.indent_char = '\\t';\n\n    // indent_size behavior changed after 1.8.6\n    // It used to be that indent_size would be\n    // set to 1 for indent_with_tabs. That is no longer needed and\n    // actually doesn't make sense - why not use spaces? Further,\n    // that might produce unexpected behavior - tabs being used\n    // for single-column alignment. So, when indent_with_tabs is true\n    // and indent_size is 1, reset indent_size to 4.\n    if (this.indent_size === 1) {\n      this.indent_size = 4;\n    }\n  }\n\n  // Backwards compat with 1.3.x\n  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));\n\n  this.indent_empty_lines = this._get_boolean('indent_empty_lines');\n\n  // valid templating languages ['django', 'erb', 'handlebars', 'php']\n  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n  // other values ignored\n  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);\n}\n\nOptions.prototype._get_array = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || [];\n  if (typeof option_value === 'object') {\n    if (option_value !== null && typeof option_value.concat === 'function') {\n      result = option_value.concat();\n    }\n  } else if (typeof option_value === 'string') {\n    result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n  }\n  return result;\n};\n\nOptions.prototype._get_boolean = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = option_value === undefined ? !!default_value : !!option_value;\n  return result;\n};\n\nOptions.prototype._get_characters = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || '';\n  if (typeof option_value === 'string') {\n    result = option_value.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n').replace(/\\\\t/, '\\t');\n  }\n  return result;\n};\n\nOptions.prototype._get_number = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  default_value = parseInt(default_value, 10);\n  if (isNaN(default_value)) {\n    default_value = 0;\n  }\n  var result = parseInt(option_value, 10);\n  if (isNaN(result)) {\n    result = default_value;\n  }\n  return result;\n};\n\nOptions.prototype._get_selection = function(name, selection_list, default_value) {\n  var result = this._get_selection_list(name, selection_list, default_value);\n  if (result.length !== 1) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result[0];\n};\n\n\nOptions.prototype._get_selection_list = function(name, selection_list, default_value) {\n  if (!selection_list || selection_list.length === 0) {\n    throw new Error(\"Selection list cannot be empty.\");\n  }\n\n  default_value = default_value || [selection_list[0]];\n  if (!this._is_valid_selection(default_value, selection_list)) {\n    throw new Error(\"Invalid Default Value!\");\n  }\n\n  var result = this._get_array(name, default_value);\n  if (!this._is_valid_selection(result, selection_list)) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result;\n};\n\nOptions.prototype._is_valid_selection = function(result, selection_list) {\n  return result.length && selection_list.length &&\n    !result.some(function(item) { return selection_list.indexOf(item) === -1; });\n};\n\n\n// merges child options up with the parent options object\n// Example: obj = {a: 1, b: {a: 2}}\n//          mergeOpts(obj, 'b')\n//\n//          Returns: {a: 2}\nfunction _mergeOpts(allOptions, childFieldName) {\n  var finalOpts = {};\n  allOptions = _normalizeOpts(allOptions);\n  var name;\n\n  for (name in allOptions) {\n    if (name !== childFieldName) {\n      finalOpts[name] = allOptions[name];\n    }\n  }\n\n  //merge in the per type settings for the childFieldName\n  if (childFieldName && allOptions[childFieldName]) {\n    for (name in allOptions[childFieldName]) {\n      finalOpts[name] = allOptions[childFieldName][name];\n    }\n  }\n  return finalOpts;\n}\n\nfunction _normalizeOpts(options) {\n  var convertedOpts = {};\n  var key;\n\n  for (key in options) {\n    var newKey = key.replace(/-/g, \"_\");\n    convertedOpts[newKey] = options[key];\n  }\n  return convertedOpts;\n}\n\nmodule.exports.Options = Options;\nmodule.exports.normalizeOpts = _normalizeOpts;\nmodule.exports.mergeOpts = _mergeOpts;\n\n\n/***/ }),\n/* 7 */,\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');\n\nfunction InputScanner(input_string) {\n  this.__input = input_string || '';\n  this.__input_length = this.__input.length;\n  this.__position = 0;\n}\n\nInputScanner.prototype.restart = function() {\n  this.__position = 0;\n};\n\nInputScanner.prototype.back = function() {\n  if (this.__position > 0) {\n    this.__position -= 1;\n  }\n};\n\nInputScanner.prototype.hasNext = function() {\n  return this.__position < this.__input_length;\n};\n\nInputScanner.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__input.charAt(this.__position);\n    this.__position += 1;\n  }\n  return val;\n};\n\nInputScanner.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__input_length) {\n    val = this.__input.charAt(index);\n  }\n  return val;\n};\n\n// This is a JavaScript only helper function (not in python)\n// Javascript doesn't have a match method\n// and not all implementation support \"sticky\" flag.\n// If they do not support sticky then both this.match() and this.test() method\n// must get the match and check the index of the match.\n// If sticky is supported and set, this method will use it.\n// Otherwise it will check that global is set, and fall back to the slower method.\nInputScanner.prototype.__match = function(pattern, index) {\n  pattern.lastIndex = index;\n  var pattern_match = pattern.exec(this.__input);\n\n  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n    if (pattern_match.index !== index) {\n      pattern_match = null;\n    }\n  }\n\n  return pattern_match;\n};\n\nInputScanner.prototype.test = function(pattern, index) {\n  index = index || 0;\n  index += this.__position;\n\n  if (index >= 0 && index < this.__input_length) {\n    return !!this.__match(pattern, index);\n  } else {\n    return false;\n  }\n};\n\nInputScanner.prototype.testChar = function(pattern, index) {\n  // test one character regex match\n  var val = this.peek(index);\n  pattern.lastIndex = 0;\n  return val !== null && pattern.test(val);\n};\n\nInputScanner.prototype.match = function(pattern) {\n  var pattern_match = this.__match(pattern, this.__position);\n  if (pattern_match) {\n    this.__position += pattern_match[0].length;\n  } else {\n    pattern_match = null;\n  }\n  return pattern_match;\n};\n\nInputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n  var val = '';\n  var match;\n  if (starting_pattern) {\n    match = this.match(starting_pattern);\n    if (match) {\n      val += match[0];\n    }\n  }\n  if (until_pattern && (match || !starting_pattern)) {\n    val += this.readUntil(until_pattern, until_after);\n  }\n  return val;\n};\n\nInputScanner.prototype.readUntil = function(pattern, until_after) {\n  var val = '';\n  var match_index = this.__position;\n  pattern.lastIndex = this.__position;\n  var pattern_match = pattern.exec(this.__input);\n  if (pattern_match) {\n    match_index = pattern_match.index;\n    if (until_after) {\n      match_index += pattern_match[0].length;\n    }\n  } else {\n    match_index = this.__input_length;\n  }\n\n  val = this.__input.substring(this.__position, match_index);\n  this.__position = match_index;\n  return val;\n};\n\nInputScanner.prototype.readUntilAfter = function(pattern) {\n  return this.readUntil(pattern, true);\n};\n\nInputScanner.prototype.get_regexp = function(pattern, match_from) {\n  var result = null;\n  var flags = 'g';\n  if (match_from && regexp_has_sticky) {\n    flags = 'y';\n  }\n  // strings are converted to regexp\n  if (typeof pattern === \"string\" && pattern !== '') {\n    // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n    result = new RegExp(pattern, flags);\n  } else if (pattern) {\n    result = new RegExp(pattern.source, flags);\n  }\n  return result;\n};\n\nInputScanner.prototype.get_literal_regexp = function(literal_string) {\n  return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n};\n\n/* css beautifier legacy helpers */\nInputScanner.prototype.peekUntilAfter = function(pattern) {\n  var start = this.__position;\n  var val = this.readUntilAfter(pattern);\n  this.__position = start;\n  return val;\n};\n\nInputScanner.prototype.lookBack = function(testVal) {\n  var start = this.__position - 1;\n  return start >= testVal.length && this.__input.substring(start - testVal.length, start)\n    .toLowerCase() === testVal;\n};\n\nmodule.exports.InputScanner = InputScanner;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar Token = __webpack_require__(3).Token;\nvar TokenStream = __webpack_require__(10).TokenStream;\nvar WhitespacePattern = __webpack_require__(11).WhitespacePattern;\n\nvar TOKEN = {\n  START: 'TK_START',\n  RAW: 'TK_RAW',\n  EOF: 'TK_EOF'\n};\n\nvar Tokenizer = function(input_string, options) {\n  this._input = new InputScanner(input_string);\n  this._options = options || {};\n  this.__tokens = null;\n\n  this._patterns = {};\n  this._patterns.whitespace = new WhitespacePattern(this._input);\n};\n\nTokenizer.prototype.tokenize = function() {\n  this._input.restart();\n  this.__tokens = new TokenStream();\n\n  this._reset();\n\n  var current;\n  var previous = new Token(TOKEN.START, '');\n  var open_token = null;\n  var open_stack = [];\n  var comments = new TokenStream();\n\n  while (previous.type !== TOKEN.EOF) {\n    current = this._get_next_token(previous, open_token);\n    while (this._is_comment(current)) {\n      comments.add(current);\n      current = this._get_next_token(previous, open_token);\n    }\n\n    if (!comments.isEmpty()) {\n      current.comments_before = comments;\n      comments = new TokenStream();\n    }\n\n    current.parent = open_token;\n\n    if (this._is_opening(current)) {\n      open_stack.push(open_token);\n      open_token = current;\n    } else if (open_token && this._is_closing(current, open_token)) {\n      current.opened = open_token;\n      open_token.closed = current;\n      open_token = open_stack.pop();\n      current.parent = open_token;\n    }\n\n    current.previous = previous;\n    previous.next = current;\n\n    this.__tokens.add(current);\n    previous = current;\n  }\n\n  return this.__tokens;\n};\n\n\nTokenizer.prototype._is_first_token = function() {\n  return this.__tokens.isEmpty();\n};\n\nTokenizer.prototype._reset = function() {};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  this._readWhitespace();\n  var resulting_string = this._input.read(/.+/g);\n  if (resulting_string) {\n    return this._create_token(TOKEN.RAW, resulting_string);\n  } else {\n    return this._create_token(TOKEN.EOF, '');\n  }\n};\n\nTokenizer.prototype._is_comment = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_opening = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._create_token = function(type, text) {\n  var token = new Token(type, text,\n    this._patterns.whitespace.newline_count,\n    this._patterns.whitespace.whitespace_before_token);\n  return token;\n};\n\nTokenizer.prototype._readWhitespace = function() {\n  return this._patterns.whitespace.read();\n};\n\n\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction TokenStream(parent_token) {\n  // private\n  this.__tokens = [];\n  this.__tokens_length = this.__tokens.length;\n  this.__position = 0;\n  this.__parent_token = parent_token;\n}\n\nTokenStream.prototype.restart = function() {\n  this.__position = 0;\n};\n\nTokenStream.prototype.isEmpty = function() {\n  return this.__tokens_length === 0;\n};\n\nTokenStream.prototype.hasNext = function() {\n  return this.__position < this.__tokens_length;\n};\n\nTokenStream.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__tokens[this.__position];\n    this.__position += 1;\n  }\n  return val;\n};\n\nTokenStream.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__tokens_length) {\n    val = this.__tokens[index];\n  }\n  return val;\n};\n\nTokenStream.prototype.add = function(token) {\n  if (this.__parent_token) {\n    token.parent = this.__parent_token;\n  }\n  this.__tokens.push(token);\n  this.__tokens_length += 1;\n};\n\nmodule.exports.TokenStream = TokenStream;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\nfunction WhitespacePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  if (parent) {\n    this._line_regexp = this._input.get_regexp(parent._line_regexp);\n  } else {\n    this.__set_whitespace_patterns('', '');\n  }\n\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n}\nWhitespacePattern.prototype = new Pattern();\n\nWhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n  whitespace_chars += '\\\\t ';\n  newline_chars += '\\\\n\\\\r';\n\n  this._match_pattern = this._input.get_regexp(\n    '[' + whitespace_chars + newline_chars + ']+', true);\n  this._newline_regexp = this._input.get_regexp(\n    '\\\\r\\\\n|[' + newline_chars + ']');\n};\n\nWhitespacePattern.prototype.read = function() {\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n\n  var resulting_string = this._input.read(this._match_pattern);\n  if (resulting_string === ' ') {\n    this.whitespace_before_token = ' ';\n  } else if (resulting_string) {\n    var matches = this.__split(this._newline_regexp, resulting_string);\n    this.newline_count = matches.length - 1;\n    this.whitespace_before_token = matches[this.newline_count];\n  }\n\n  return resulting_string;\n};\n\nWhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n  var result = this._create();\n  result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n  result._update();\n  return result;\n};\n\nWhitespacePattern.prototype._create = function() {\n  return new WhitespacePattern(this._input, this);\n};\n\nWhitespacePattern.prototype.__split = function(regexp, input_string) {\n  regexp.lastIndex = 0;\n  var start_index = 0;\n  var result = [];\n  var next_match = regexp.exec(input_string);\n  while (next_match) {\n    result.push(input_string.substring(start_index, next_match.index));\n    start_index = next_match.index + next_match[0].length;\n    next_match = regexp.exec(input_string);\n  }\n\n  if (start_index < input_string.length) {\n    result.push(input_string.substring(start_index, input_string.length));\n  } else {\n    result.push('');\n  }\n\n  return result;\n};\n\n\n\nmodule.exports.WhitespacePattern = WhitespacePattern;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Pattern(input_scanner, parent) {\n  this._input = input_scanner;\n  this._starting_pattern = null;\n  this._match_pattern = null;\n  this._until_pattern = null;\n  this._until_after = false;\n\n  if (parent) {\n    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n    this._until_pattern = this._input.get_regexp(parent._until_pattern);\n    this._until_after = parent._until_after;\n  }\n}\n\nPattern.prototype.read = function() {\n  var result = this._input.read(this._starting_pattern);\n  if (!this._starting_pattern || result) {\n    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n  }\n  return result;\n};\n\nPattern.prototype.read_match = function() {\n  return this._input.match(this._match_pattern);\n};\n\nPattern.prototype.until_after = function(pattern) {\n  var result = this._create();\n  result._until_after = true;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.until = function(pattern) {\n  var result = this._create();\n  result._until_after = false;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.starting_with = function(pattern) {\n  var result = this._create();\n  result._starting_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype.matching = function(pattern) {\n  var result = this._create();\n  result._match_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype._create = function() {\n  return new Pattern(this._input, this);\n};\n\nPattern.prototype._update = function() {};\n\nmodule.exports.Pattern = Pattern;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Directives(start_block_pattern, end_block_pattern) {\n  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;\n  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;\n  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, 'g');\n  this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n\n  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, 'g');\n}\n\nDirectives.prototype.get_directives = function(text) {\n  if (!text.match(this.__directives_block_pattern)) {\n    return null;\n  }\n\n  var directives = {};\n  this.__directive_pattern.lastIndex = 0;\n  var directive_match = this.__directive_pattern.exec(text);\n\n  while (directive_match) {\n    directives[directive_match[1]] = directive_match[2];\n    directive_match = this.__directive_pattern.exec(text);\n  }\n\n  return directives;\n};\n\nDirectives.prototype.readIgnored = function(input) {\n  return input.readUntilAfter(this.__directives_end_ignore_pattern);\n};\n\n\nmodule.exports.Directives = Directives;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\n\nvar template_names = {\n  django: false,\n  erb: false,\n  handlebars: false,\n  php: false\n};\n\n// This lets templates appear anywhere we would do a readUntil\n// The cost is higher but it is pay to play.\nfunction TemplatablePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  this.__template_pattern = null;\n  this._disabled = Object.assign({}, template_names);\n  this._excluded = Object.assign({}, template_names);\n\n  if (parent) {\n    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n    this._excluded = Object.assign(this._excluded, parent._excluded);\n    this._disabled = Object.assign(this._disabled, parent._disabled);\n  }\n  var pattern = new Pattern(input_scanner);\n  this.__patterns = {\n    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n    handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n    php: pattern.starting_with(/<\\?(?:[=]|php)/).until_after(/\\?>/),\n    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n    // django coflicts with handlebars a bit.\n    django: pattern.starting_with(/{%/).until_after(/%}/),\n    django_value: pattern.starting_with(/{{/).until_after(/}}/),\n    django_comment: pattern.starting_with(/{#/).until_after(/#}/)\n  };\n}\nTemplatablePattern.prototype = new Pattern();\n\nTemplatablePattern.prototype._create = function() {\n  return new TemplatablePattern(this._input, this);\n};\n\nTemplatablePattern.prototype._update = function() {\n  this.__set_templated_pattern();\n};\n\nTemplatablePattern.prototype.disable = function(language) {\n  var result = this._create();\n  result._disabled[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read_options = function(options) {\n  var result = this._create();\n  for (var language in template_names) {\n    result._disabled[language] = options.templating.indexOf(language) === -1;\n  }\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.exclude = function(language) {\n  var result = this._create();\n  result._excluded[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read = function() {\n  var result = '';\n  if (this._match_pattern) {\n    result = this._input.read(this._starting_pattern);\n  } else {\n    result = this._input.read(this._starting_pattern, this.__template_pattern);\n  }\n  var next = this._read_template();\n  while (next) {\n    if (this._match_pattern) {\n      next += this._input.read(this._match_pattern);\n    } else {\n      next += this._input.readUntil(this.__template_pattern);\n    }\n    result += next;\n    next = this._read_template();\n  }\n\n  if (this._until_after) {\n    result += this._input.readUntilAfter(this._until_pattern);\n  }\n  return result;\n};\n\nTemplatablePattern.prototype.__set_templated_pattern = function() {\n  var items = [];\n\n  if (!this._disabled.php) {\n    items.push(this.__patterns.php._starting_pattern.source);\n  }\n  if (!this._disabled.handlebars) {\n    items.push(this.__patterns.handlebars._starting_pattern.source);\n  }\n  if (!this._disabled.erb) {\n    items.push(this.__patterns.erb._starting_pattern.source);\n  }\n  if (!this._disabled.django) {\n    items.push(this.__patterns.django._starting_pattern.source);\n    items.push(this.__patterns.django_value._starting_pattern.source);\n    items.push(this.__patterns.django_comment._starting_pattern.source);\n  }\n\n  if (this._until_pattern) {\n    items.push(this._until_pattern.source);\n  }\n  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');\n};\n\nTemplatablePattern.prototype._read_template = function() {\n  var resulting_string = '';\n  var c = this._input.peek();\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    //if we're in a comment, do something special\n    // We treat all comments as literals, even more than preformatted tags\n    // we just look for the appropriate close tag\n    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {\n      resulting_string = resulting_string ||\n        this.__patterns.php.read();\n    }\n    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {\n      resulting_string = resulting_string ||\n        this.__patterns.erb.read();\n    }\n  } else if (c === '{') {\n    if (!this._disabled.handlebars && !this._excluded.handlebars) {\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_comment.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_unescaped.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars.read();\n    }\n    if (!this._disabled.django) {\n      // django coflicts with handlebars a bit.\n      if (!this._excluded.django && !this._excluded.handlebars) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_value.read();\n      }\n      if (!this._excluded.django) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_comment.read();\n        resulting_string = resulting_string ||\n          this.__patterns.django.read();\n      }\n    }\n  }\n  return resulting_string;\n};\n\n\nmodule.exports.TemplatablePattern = TemplatablePattern;\n\n\n/***/ }),\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Beautifier = __webpack_require__(19).Beautifier,\n  Options = __webpack_require__(20).Options;\n\nfunction style_html(html_source, options, js_beautify, css_beautify) {\n  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);\n  return beautifier.beautify();\n}\n\nmodule.exports = style_html;\nmodule.exports.defaultOptions = function() {\n  return new Options();\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Options = __webpack_require__(20).Options;\nvar Output = __webpack_require__(2).Output;\nvar Tokenizer = __webpack_require__(21).Tokenizer;\nvar TOKEN = __webpack_require__(21).TOKEN;\n\nvar lineBreak = /\\r\\n|[\\r\\n]/;\nvar allLineBreaks = /\\r\\n|[\\r\\n]/g;\n\nvar Printer = function(options, base_indent_string) { //handles input/output and some other printing functions\n\n  this.indent_level = 0;\n  this.alignment_size = 0;\n  this.max_preserve_newlines = options.max_preserve_newlines;\n  this.preserve_newlines = options.preserve_newlines;\n\n  this._output = new Output(options, base_indent_string);\n\n};\n\nPrinter.prototype.current_line_has_match = function(pattern) {\n  return this._output.current_line.has_match(pattern);\n};\n\nPrinter.prototype.set_space_before_token = function(value, non_breaking) {\n  this._output.space_before_token = value;\n  this._output.non_breaking_space = non_breaking;\n};\n\nPrinter.prototype.set_wrap_point = function() {\n  this._output.set_indent(this.indent_level, this.alignment_size);\n  this._output.set_wrap_point();\n};\n\n\nPrinter.prototype.add_raw_token = function(token) {\n  this._output.add_raw_token(token);\n};\n\nPrinter.prototype.print_preserved_newlines = function(raw_token) {\n  var newlines = 0;\n  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {\n    newlines = raw_token.newlines ? 1 : 0;\n  }\n\n  if (this.preserve_newlines) {\n    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;\n  }\n  for (var n = 0; n < newlines; n++) {\n    this.print_newline(n > 0);\n  }\n\n  return newlines !== 0;\n};\n\nPrinter.prototype.traverse_whitespace = function(raw_token) {\n  if (raw_token.whitespace_before || raw_token.newlines) {\n    if (!this.print_preserved_newlines(raw_token)) {\n      this._output.space_before_token = true;\n    }\n    return true;\n  }\n  return false;\n};\n\nPrinter.prototype.previous_token_wrapped = function() {\n  return this._output.previous_token_wrapped;\n};\n\nPrinter.prototype.print_newline = function(force) {\n  this._output.add_new_line(force);\n};\n\nPrinter.prototype.print_token = function(token) {\n  if (token.text) {\n    this._output.set_indent(this.indent_level, this.alignment_size);\n    this._output.add_token(token.text);\n  }\n};\n\nPrinter.prototype.indent = function() {\n  this.indent_level++;\n};\n\nPrinter.prototype.get_full_indent = function(level) {\n  level = this.indent_level + (level || 0);\n  if (level < 1) {\n    return '';\n  }\n\n  return this._output.get_indent_string(level);\n};\n\nvar get_type_attribute = function(start_token) {\n  var result = null;\n  var raw_token = start_token.next;\n\n  // Search attributes for a type attribute\n  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {\n    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {\n      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&\n        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {\n        result = raw_token.next.next.text;\n      }\n      break;\n    }\n    raw_token = raw_token.next;\n  }\n\n  return result;\n};\n\nvar get_custom_beautifier_name = function(tag_check, raw_token) {\n  var typeAttribute = null;\n  var result = null;\n\n  if (!raw_token.closed) {\n    return null;\n  }\n\n  if (tag_check === 'script') {\n    typeAttribute = 'text/javascript';\n  } else if (tag_check === 'style') {\n    typeAttribute = 'text/css';\n  }\n\n  typeAttribute = get_type_attribute(raw_token) || typeAttribute;\n\n  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values\n  // For those without a type attribute use default;\n  if (typeAttribute.search('text/css') > -1) {\n    result = 'css';\n  } else if (typeAttribute.search(/(text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect)/) > -1) {\n    result = 'javascript';\n  } else if (typeAttribute.search(/(text|application|dojo)\\/(x-)?(html)/) > -1) {\n    result = 'html';\n  } else if (typeAttribute.search(/test\\/null/) > -1) {\n    // Test only mime-type for testing the beautifier when null is passed as beautifing function\n    result = 'null';\n  }\n\n  return result;\n};\n\nfunction in_array(what, arr) {\n  return arr.indexOf(what) !== -1;\n}\n\nfunction TagFrame(parent, parser_token, indent_level) {\n  this.parent = parent || null;\n  this.tag = parser_token ? parser_token.tag_name : '';\n  this.indent_level = indent_level || 0;\n  this.parser_token = parser_token || null;\n}\n\nfunction TagStack(printer) {\n  this._printer = printer;\n  this._current_frame = null;\n}\n\nTagStack.prototype.get_parser_token = function() {\n  return this._current_frame ? this._current_frame.parser_token : null;\n};\n\nTagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object\n  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);\n  this._current_frame = new_frame;\n};\n\nTagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer\n  var parser_token = null;\n\n  if (frame) {\n    parser_token = frame.parser_token;\n    this._printer.indent_level = frame.indent_level;\n    this._current_frame = frame.parent;\n  }\n\n  return parser_token;\n};\n\nTagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer\n  var frame = this._current_frame;\n\n  while (frame) { //till we reach '' (the initial value);\n    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it\n      break;\n    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {\n      frame = null;\n      break;\n    }\n    frame = frame.parent;\n  }\n\n  return frame;\n};\n\nTagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer\n  var frame = this._get_frame([tag], stop_list);\n  return this._try_pop_frame(frame);\n};\n\nTagStack.prototype.indent_to_tag = function(tag_list) {\n  var frame = this._get_frame(tag_list);\n  if (frame) {\n    this._printer.indent_level = frame.indent_level;\n  }\n};\n\nfunction Beautifier(source_text, options, js_beautify, css_beautify) {\n  //Wrapper function to invoke all the necessary constructors and deal with the output.\n  this._source_text = source_text || '';\n  options = options || {};\n  this._js_beautify = js_beautify;\n  this._css_beautify = css_beautify;\n  this._tag_stack = null;\n\n  // Allow the setting of language/file-type specific options\n  // with inheritance of overall settings\n  var optionHtml = new Options(options, 'html');\n\n  this._options = optionHtml;\n\n  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';\n  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');\n  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');\n  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');\n  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';\n  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');\n}\n\nBeautifier.prototype.beautify = function() {\n\n  // if disabled, return the input unchanged.\n  if (this._options.disabled) {\n    return this._source_text;\n  }\n\n  var source_text = this._source_text;\n  var eol = this._options.eol;\n  if (this._options.eol === 'auto') {\n    eol = '\\n';\n    if (source_text && lineBreak.test(source_text)) {\n      eol = source_text.match(lineBreak)[0];\n    }\n  }\n\n  // HACK: newline parsing inconsistent. This brute force normalizes the input.\n  source_text = source_text.replace(allLineBreaks, '\\n');\n\n  var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n\n  var last_token = {\n    text: '',\n    type: ''\n  };\n\n  var last_tag_token = new TagOpenParserToken();\n\n  var printer = new Printer(this._options, baseIndentString);\n  var tokens = new Tokenizer(source_text, this._options).tokenize();\n\n  this._tag_stack = new TagStack(printer);\n\n  var parser_token = null;\n  var raw_token = tokens.next();\n  while (raw_token.type !== TOKEN.EOF) {\n\n    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {\n      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);\n      last_tag_token = parser_token;\n    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||\n      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {\n      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);\n    } else if (raw_token.type === TOKEN.TAG_CLOSE) {\n      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);\n    } else if (raw_token.type === TOKEN.TEXT) {\n      parser_token = this._handle_text(printer, raw_token, last_tag_token);\n    } else {\n      // This should never happen, but if it does. Print the raw token\n      printer.add_raw_token(raw_token);\n    }\n\n    last_token = parser_token;\n\n    raw_token = tokens.next();\n  }\n  var sweet_code = printer._output.get_code(eol);\n\n  return sweet_code;\n};\n\nBeautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {\n  var parser_token = {\n    text: raw_token.text,\n    type: raw_token.type\n  };\n  printer.alignment_size = 0;\n  last_tag_token.tag_complete = true;\n\n  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);\n  if (last_tag_token.is_unformatted) {\n    printer.add_raw_token(raw_token);\n  } else {\n    if (last_tag_token.tag_start_char === '<') {\n      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >\n      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {\n        printer.print_newline(false);\n      }\n    }\n    printer.print_token(raw_token);\n\n  }\n\n  if (last_tag_token.indent_content &&\n    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n    printer.indent();\n\n    // only indent once per opened tag\n    last_tag_token.indent_content = false;\n  }\n\n  if (!last_tag_token.is_inline_element &&\n    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n    printer.set_wrap_point();\n  }\n\n  return parser_token;\n};\n\nBeautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {\n  var wrapped = last_tag_token.has_wrapped_attrs;\n  var parser_token = {\n    text: raw_token.text,\n    type: raw_token.type\n  };\n\n  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);\n  if (last_tag_token.is_unformatted) {\n    printer.add_raw_token(raw_token);\n  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {\n    // For the insides of handlebars allow newlines or a single space between open and contents\n    if (printer.print_preserved_newlines(raw_token)) {\n      raw_token.newlines = 0;\n      printer.add_raw_token(raw_token);\n    } else {\n      printer.print_token(raw_token);\n    }\n  } else {\n    if (raw_token.type === TOKEN.ATTRIBUTE) {\n      printer.set_space_before_token(true);\n      last_tag_token.attr_count += 1;\n    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =\n      printer.set_space_before_token(false);\n    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value\n      printer.set_space_before_token(false);\n    }\n\n    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {\n      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {\n        printer.traverse_whitespace(raw_token);\n        wrapped = wrapped || raw_token.newlines !== 0;\n      }\n\n\n      if (this._is_wrap_attributes_force) {\n        var force_attr_wrap = last_tag_token.attr_count > 1;\n        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {\n          var is_only_attribute = true;\n          var peek_index = 0;\n          var peek_token;\n          do {\n            peek_token = tokens.peek(peek_index);\n            if (peek_token.type === TOKEN.ATTRIBUTE) {\n              is_only_attribute = false;\n              break;\n            }\n            peek_index += 1;\n          } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);\n\n          force_attr_wrap = !is_only_attribute;\n        }\n\n        if (force_attr_wrap) {\n          printer.print_newline(false);\n          wrapped = true;\n        }\n      }\n    }\n    printer.print_token(raw_token);\n    wrapped = wrapped || printer.previous_token_wrapped();\n    last_tag_token.has_wrapped_attrs = wrapped;\n  }\n  return parser_token;\n};\n\nBeautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {\n  var parser_token = {\n    text: raw_token.text,\n    type: 'TK_CONTENT'\n  };\n  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript\n    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);\n  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {\n    printer.add_raw_token(raw_token);\n  } else {\n    printer.traverse_whitespace(raw_token);\n    printer.print_token(raw_token);\n  }\n  return parser_token;\n};\n\nBeautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {\n  var local = this;\n  if (raw_token.text !== '') {\n\n    var text = raw_token.text,\n      _beautifier,\n      script_indent_level = 1,\n      pre = '',\n      post = '';\n    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {\n      _beautifier = this._js_beautify;\n    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {\n      _beautifier = this._css_beautify;\n    } else if (last_tag_token.custom_beautifier_name === 'html') {\n      _beautifier = function(html_source, options) {\n        var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);\n        return beautifier.beautify();\n      };\n    }\n\n    if (this._options.indent_scripts === \"keep\") {\n      script_indent_level = 0;\n    } else if (this._options.indent_scripts === \"separate\") {\n      script_indent_level = -printer.indent_level;\n    }\n\n    var indentation = printer.get_full_indent(script_indent_level);\n\n    // if there is at least one empty line at the end of this text, strip it\n    // we'll be adding one back after the text but before the containing tag.\n    text = text.replace(/\\n[ \\t]*$/, '');\n\n    // Handle the case where content is wrapped in a comment or cdata.\n    if (last_tag_token.custom_beautifier_name !== 'html' &&\n      text[0] === '<' && text.match(/^(<!--|<!\\[CDATA\\[)/)) {\n      var matched = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)$/.exec(text);\n\n      // if we start to wrap but don't finish, print raw\n      if (!matched) {\n        printer.add_raw_token(raw_token);\n        return;\n      }\n\n      pre = indentation + matched[1] + '\\n';\n      text = matched[4];\n      if (matched[5]) {\n        post = indentation + matched[5];\n      }\n\n      // if there is at least one empty line at the end of this text, strip it\n      // we'll be adding one back after the text but before the containing tag.\n      text = text.replace(/\\n[ \\t]*$/, '');\n\n      if (matched[2] || matched[3].indexOf('\\n') !== -1) {\n        // if the first line of the non-comment text has spaces\n        // use that as the basis for indenting in null case.\n        matched = matched[3].match(/[ \\t]+$/);\n        if (matched) {\n          raw_token.whitespace_before = matched[0];\n        }\n      }\n    }\n\n    if (text) {\n      if (_beautifier) {\n\n        // call the Beautifier if avaliable\n        var Child_options = function() {\n          this.eol = '\\n';\n        };\n        Child_options.prototype = this._options.raw_options;\n        var child_options = new Child_options();\n        text = _beautifier(indentation + text, child_options);\n      } else {\n        // simply indent the string otherwise\n        var white = raw_token.whitespace_before;\n        if (white) {\n          text = text.replace(new RegExp('\\n(' + white + ')?', 'g'), '\\n');\n        }\n\n        text = indentation + text.replace(/\\n/g, '\\n' + indentation);\n      }\n    }\n\n    if (pre) {\n      if (!text) {\n        text = pre + post;\n      } else {\n        text = pre + text + '\\n' + post;\n      }\n    }\n\n    printer.print_newline(false);\n    if (text) {\n      raw_token.text = text;\n      raw_token.whitespace_before = '';\n      raw_token.newlines = 0;\n      printer.add_raw_token(raw_token);\n      printer.print_newline(true);\n    }\n  }\n};\n\nBeautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {\n  var parser_token = this._get_tag_open_token(raw_token);\n\n  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&\n    raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf('</') === 0) {\n    // End element tags for unformatted or content_unformatted elements\n    // are printed raw to keep any newlines inside them exactly the same.\n    printer.add_raw_token(raw_token);\n  } else {\n    printer.traverse_whitespace(raw_token);\n    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);\n    if (!parser_token.is_inline_element) {\n      printer.set_wrap_point();\n    }\n    printer.print_token(raw_token);\n  }\n\n  //indent attributes an auto, forced, aligned or forced-align line-wrap\n  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {\n    parser_token.alignment_size = raw_token.text.length + 1;\n  }\n\n  if (!parser_token.tag_complete && !parser_token.is_unformatted) {\n    printer.alignment_size = parser_token.alignment_size;\n  }\n\n  return parser_token;\n};\n\nvar TagOpenParserToken = function(parent, raw_token) {\n  this.parent = parent || null;\n  this.text = '';\n  this.type = 'TK_TAG_OPEN';\n  this.tag_name = '';\n  this.is_inline_element = false;\n  this.is_unformatted = false;\n  this.is_content_unformatted = false;\n  this.is_empty_element = false;\n  this.is_start_tag = false;\n  this.is_end_tag = false;\n  this.indent_content = false;\n  this.multiline_content = false;\n  this.custom_beautifier_name = null;\n  this.start_tag_token = null;\n  this.attr_count = 0;\n  this.has_wrapped_attrs = false;\n  this.alignment_size = 0;\n  this.tag_complete = false;\n  this.tag_start_char = '';\n  this.tag_check = '';\n\n  if (!raw_token) {\n    this.tag_complete = true;\n  } else {\n    var tag_check_match;\n\n    this.tag_start_char = raw_token.text[0];\n    this.text = raw_token.text;\n\n    if (this.tag_start_char === '<') {\n      tag_check_match = raw_token.text.match(/^<([^\\s>]*)/);\n      this.tag_check = tag_check_match ? tag_check_match[1] : '';\n    } else {\n      tag_check_match = raw_token.text.match(/^{{[#\\^]?([^\\s}]+)/);\n      this.tag_check = tag_check_match ? tag_check_match[1] : '';\n    }\n    this.tag_check = this.tag_check.toLowerCase();\n\n    if (raw_token.type === TOKEN.COMMENT) {\n      this.tag_complete = true;\n    }\n\n    this.is_start_tag = this.tag_check.charAt(0) !== '/';\n    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;\n    this.is_end_tag = !this.is_start_tag ||\n      (raw_token.closed && raw_token.closed.text === '/>');\n\n    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.\n    this.is_end_tag = this.is_end_tag ||\n      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\\^]/.test(this.text.charAt(2)))));\n  }\n};\n\nBeautifier.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type\n  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);\n\n  parser_token.alignment_size = this._options.wrap_attributes_indent_size;\n\n  parser_token.is_end_tag = parser_token.is_end_tag ||\n    in_array(parser_token.tag_check, this._options.void_elements);\n\n  parser_token.is_empty_element = parser_token.tag_complete ||\n    (parser_token.is_start_tag && parser_token.is_end_tag);\n\n  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);\n  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);\n  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === '{';\n\n  return parser_token;\n};\n\nBeautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {\n\n  if (!parser_token.is_empty_element) {\n    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending\n      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors\n    } else { // it's a start-tag\n      // check if this tag is starting an element that has optional end element\n      // and do an ending needed\n      if (this._do_optional_end_element(parser_token)) {\n        if (!parser_token.is_inline_element) {\n          if (parser_token.parent) {\n            parser_token.parent.multiline_content = true;\n          }\n          printer.print_newline(false);\n        }\n\n      }\n\n      this._tag_stack.record_tag(parser_token); //push it on the tag stack\n\n      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&\n        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {\n        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);\n      }\n    }\n  }\n\n  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line\n    printer.print_newline(false);\n    if (!printer._output.just_added_blankline()) {\n      printer.print_newline(true);\n    }\n  }\n\n  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)\n\n    // if you hit an else case, reset the indent level if you are inside an:\n    // 'if', 'unless', or 'each' block.\n    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {\n      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);\n      parser_token.indent_content = true;\n      // Don't add a newline if opening {{#if}} tag is on the current line\n      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);\n      if (!foundIfOnCurrentLine) {\n        printer.print_newline(false);\n      }\n    }\n\n    // Don't add a newline before elements that should remain where they are.\n    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&\n      last_tag_token.is_end_tag && parser_token.text.indexOf('\\n') === -1) {\n      //Do nothing. Leave comments on same line.\n    } else if (!parser_token.is_inline_element && !parser_token.is_unformatted) {\n      printer.print_newline(false);\n    }\n  } else if (parser_token.is_unformatted || parser_token.is_content_unformatted) {\n    if (!parser_token.is_inline_element && !parser_token.is_unformatted) {\n      printer.print_newline(false);\n    }\n  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending\n    if ((parser_token.start_tag_token && parser_token.start_tag_token.multiline_content) ||\n      !(parser_token.is_inline_element ||\n        (last_tag_token.is_inline_element) ||\n        (last_token.type === TOKEN.TAG_CLOSE &&\n          parser_token.start_tag_token === last_tag_token) ||\n        (last_token.type === 'TK_CONTENT')\n      )) {\n      printer.print_newline(false);\n    }\n  } else { // it's a start-tag\n    parser_token.indent_content = !parser_token.custom_beautifier_name;\n\n    if (parser_token.tag_start_char === '<') {\n      if (parser_token.tag_name === 'html') {\n        parser_token.indent_content = this._options.indent_inner_html;\n      } else if (parser_token.tag_name === 'head') {\n        parser_token.indent_content = this._options.indent_head_inner_html;\n      } else if (parser_token.tag_name === 'body') {\n        parser_token.indent_content = this._options.indent_body_inner_html;\n      }\n    }\n\n    if (!parser_token.is_inline_element && last_token.type !== 'TK_CONTENT') {\n      if (parser_token.parent) {\n        parser_token.parent.multiline_content = true;\n      }\n      printer.print_newline(false);\n    }\n  }\n};\n\n//To be used for <p> tag special case:\n//var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];\n\nBeautifier.prototype._do_optional_end_element = function(parser_token) {\n  var result = null;\n  // NOTE: cases of \"if there is no more content in the parent element\"\n  // are handled automatically by the beautifier.\n  // It assumes parent or ancestor close tag closes all children.\n  // https://www.w3.org/TR/html5/syntax.html#optional-tags\n  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {\n    return;\n\n  } else if (parser_token.tag_name === 'body') {\n    // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.\n    result = result || this._tag_stack.try_pop('head');\n\n    //} else if (parser_token.tag_name === 'body') {\n    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.\n\n  } else if (parser_token.tag_name === 'li') {\n    // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('li', ['ol', 'ul']);\n\n  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {\n    // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.\n    // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.\n    result = result || this._tag_stack.try_pop('dt', ['dl']);\n    result = result || this._tag_stack.try_pop('dd', ['dl']);\n\n    //} else if (p_closers.indexOf(parser_token.tag_name) !== -1) {\n    //TODO: THIS IS A BUG FARM. We are not putting this into 1.8.0 as it is likely to blow up.\n    //A p element’s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.\n    //result = result || this._tag_stack.try_pop('p', ['body']);\n\n  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {\n    // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n    // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);\n    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);\n\n  } else if (parser_token.tag_name === 'optgroup') {\n    // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.\n    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('optgroup', ['select']);\n    //result = result || this._tag_stack.try_pop('option', ['select']);\n\n  } else if (parser_token.tag_name === 'option') {\n    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);\n\n  } else if (parser_token.tag_name === 'colgroup') {\n    // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n\n  } else if (parser_token.tag_name === 'thead') {\n    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n    result = result || this._tag_stack.try_pop('colgroup', ['table']);\n\n    //} else if (parser_token.tag_name === 'caption') {\n    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.\n\n  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {\n    // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.\n    // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.\n    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n    result = result || this._tag_stack.try_pop('colgroup', ['table']);\n    result = result || this._tag_stack.try_pop('thead', ['table']);\n    result = result || this._tag_stack.try_pop('tbody', ['table']);\n\n    //} else if (parser_token.tag_name === 'tfoot') {\n    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.\n\n  } else if (parser_token.tag_name === 'tr') {\n    // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.\n    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n    result = result || this._tag_stack.try_pop('colgroup', ['table']);\n    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);\n\n  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {\n    // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.\n    // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);\n    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);\n  }\n\n  // Start element omission not handled currently\n  // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.\n  // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n  // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n\n  // Fix up the parent of the parser token\n  parser_token.parent = this._tag_stack.get_parser_token();\n\n  return result;\n};\n\nmodule.exports.Beautifier = Beautifier;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseOptions = __webpack_require__(6).Options;\n\nfunction Options(options) {\n  BaseOptions.call(this, options, 'html');\n  if (this.templating.length === 1 && this.templating[0] === 'auto') {\n    this.templating = ['django', 'erb', 'handlebars', 'php'];\n  }\n\n  this.indent_inner_html = this._get_boolean('indent_inner_html');\n  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);\n  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);\n\n  this.indent_handlebars = this._get_boolean('indent_handlebars', true);\n  this.wrap_attributes = this._get_selection('wrap_attributes',\n    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);\n  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);\n  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);\n\n  // Block vs inline elements\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n  // https://www.w3.org/TR/html5/dom.html#phrasing-content\n  this.inline = this._get_array('inline', [\n    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',\n    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',\n    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',\n    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',\n    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',\n    'video', 'wbr', 'text',\n    // obsolete inline tags\n    'acronym', 'big', 'strike', 'tt'\n  ]);\n  this.void_elements = this._get_array('void_elements', [\n    // HTLM void elements - aka self-closing tags - aka singletons\n    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',\n    // NOTE: Optional tags are too complex for a simple list\n    // they are hard coded in _do_optional_end_element\n\n    // Doctype and xml elements\n    '!doctype', '?xml',\n\n    // obsolete tags\n    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm\n    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex\n    'basefont', 'isindex'\n  ]);\n  this.unformatted = this._get_array('unformatted', []);\n  this.content_unformatted = this._get_array('content_unformatted', [\n    'pre', 'textarea'\n  ]);\n  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');\n  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);\n\n}\nOptions.prototype = new BaseOptions();\n\n\n\nmodule.exports.Options = Options;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseTokenizer = __webpack_require__(9).Tokenizer;\nvar BASETOKEN = __webpack_require__(9).TOKEN;\nvar Directives = __webpack_require__(13).Directives;\nvar TemplatablePattern = __webpack_require__(14).TemplatablePattern;\nvar Pattern = __webpack_require__(12).Pattern;\n\nvar TOKEN = {\n  TAG_OPEN: 'TK_TAG_OPEN',\n  TAG_CLOSE: 'TK_TAG_CLOSE',\n  ATTRIBUTE: 'TK_ATTRIBUTE',\n  EQUALS: 'TK_EQUALS',\n  VALUE: 'TK_VALUE',\n  COMMENT: 'TK_COMMENT',\n  TEXT: 'TK_TEXT',\n  UNKNOWN: 'TK_UNKNOWN',\n  START: BASETOKEN.START,\n  RAW: BASETOKEN.RAW,\n  EOF: BASETOKEN.EOF\n};\n\nvar directives_core = new Directives(/<\\!--/, /-->/);\n\nvar Tokenizer = function(input_string, options) {\n  BaseTokenizer.call(this, input_string, options);\n  this._current_tag_name = '';\n\n  // Words end at whitespace or when a tag starts\n  // if we are indenting handlebars, they are considered tags\n  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);\n  var pattern_reader = new Pattern(this._input);\n\n  this.__patterns = {\n    word: templatable_reader.until(/[\\n\\r\\t <]/),\n    single_quote: templatable_reader.until_after(/'/),\n    double_quote: templatable_reader.until_after(/\"/),\n    attribute: templatable_reader.until(/[\\n\\r\\t =\\/>]/),\n    element_name: templatable_reader.until(/[\\n\\r\\t >\\/]/),\n\n    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),\n    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),\n    handlebars_open: pattern_reader.until(/[\\n\\r\\t }]/),\n    handlebars_raw_close: pattern_reader.until(/}}/),\n    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),\n    cdata: pattern_reader.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/),\n    // https://en.wikipedia.org/wiki/Conditional_comment\n    conditional_comment: pattern_reader.starting_with(/<!\\[/).until_after(/]>/),\n    processing: pattern_reader.starting_with(/<\\?/).until_after(/\\?>/)\n  };\n\n  if (this._options.indent_handlebars) {\n    this.__patterns.word = this.__patterns.word.exclude('handlebars');\n  }\n\n  this._unformatted_content_delimiter = null;\n\n  if (this._options.unformatted_content_delimiter) {\n    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);\n    this.__patterns.unformatted_content_delimiter =\n      pattern_reader.matching(literal_regexp)\n      .until_after(literal_regexp);\n  }\n};\nTokenizer.prototype = new BaseTokenizer();\n\nTokenizer.prototype._is_comment = function(current_token) { // jshint unused:false\n  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;\n};\n\nTokenizer.prototype._is_opening = function(current_token) {\n  return current_token.type === TOKEN.TAG_OPEN;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) {\n  return current_token.type === TOKEN.TAG_CLOSE &&\n    (open_token && (\n      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||\n      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));\n};\n\nTokenizer.prototype._reset = function() {\n  this._current_tag_name = '';\n};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  var token = null;\n  this._readWhitespace();\n  var c = this._input.peek();\n\n  if (c === null) {\n    return this._create_token(TOKEN.EOF, '');\n  }\n\n  token = token || this._read_open_handlebars(c, open_token);\n  token = token || this._read_attribute(c, previous_token, open_token);\n  token = token || this._read_raw_content(c, previous_token, open_token);\n  token = token || this._read_close(c, open_token);\n  token = token || this._read_content_word(c);\n  token = token || this._read_comment_or_cdata(c);\n  token = token || this._read_processing(c);\n  token = token || this._read_open(c, open_token);\n  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n\n  return token;\n};\n\nTokenizer.prototype._read_comment_or_cdata = function(c) { // jshint unused:false\n  var token = null;\n  var resulting_string = null;\n  var directives = null;\n\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    // We treat all comments as literals, even more than preformatted tags\n    // we only look for the appropriate closing marker\n    if (peek1 === '!') {\n      resulting_string = this.__patterns.comment.read();\n\n      // only process directive on html comments\n      if (resulting_string) {\n        directives = directives_core.get_directives(resulting_string);\n        if (directives && directives.ignore === 'start') {\n          resulting_string += directives_core.readIgnored(this._input);\n        }\n      } else {\n        resulting_string = this.__patterns.cdata.read();\n      }\n    }\n\n    if (resulting_string) {\n      token = this._create_token(TOKEN.COMMENT, resulting_string);\n      token.directives = directives;\n    }\n  }\n\n  return token;\n};\n\nTokenizer.prototype._read_processing = function(c) { // jshint unused:false\n  var token = null;\n  var resulting_string = null;\n  var directives = null;\n\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    if (peek1 === '!' || peek1 === '?') {\n      resulting_string = this.__patterns.conditional_comment.read();\n      resulting_string = resulting_string || this.__patterns.processing.read();\n    }\n\n    if (resulting_string) {\n      token = this._create_token(TOKEN.COMMENT, resulting_string);\n      token.directives = directives;\n    }\n  }\n\n  return token;\n};\n\nTokenizer.prototype._read_open = function(c, open_token) {\n  var resulting_string = null;\n  var token = null;\n  if (!open_token) {\n    if (c === '<') {\n\n      resulting_string = this._input.next();\n      if (this._input.peek() === '/') {\n        resulting_string += this._input.next();\n      }\n      resulting_string += this.__patterns.element_name.read();\n      token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n    }\n  }\n  return token;\n};\n\nTokenizer.prototype._read_open_handlebars = function(c, open_token) {\n  var resulting_string = null;\n  var token = null;\n  if (!open_token) {\n    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {\n      if (this._input.peek(2) === '!') {\n        resulting_string = this.__patterns.handlebars_comment.read();\n        resulting_string = resulting_string || this.__patterns.handlebars.read();\n        token = this._create_token(TOKEN.COMMENT, resulting_string);\n      } else {\n        resulting_string = this.__patterns.handlebars_open.read();\n        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n      }\n    }\n  }\n  return token;\n};\n\n\nTokenizer.prototype._read_close = function(c, open_token) {\n  var resulting_string = null;\n  var token = null;\n  if (open_token) {\n    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {\n      resulting_string = this._input.next();\n      if (c === '/') { //  for close tag \"/>\"\n        resulting_string += this._input.next();\n      }\n      token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);\n    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {\n      this._input.next();\n      this._input.next();\n      token = this._create_token(TOKEN.TAG_CLOSE, '}}');\n    }\n  }\n\n  return token;\n};\n\nTokenizer.prototype._read_attribute = function(c, previous_token, open_token) {\n  var token = null;\n  var resulting_string = '';\n  if (open_token && open_token.text[0] === '<') {\n\n    if (c === '=') {\n      token = this._create_token(TOKEN.EQUALS, this._input.next());\n    } else if (c === '\"' || c === \"'\") {\n      var content = this._input.next();\n      if (c === '\"') {\n        content += this.__patterns.double_quote.read();\n      } else {\n        content += this.__patterns.single_quote.read();\n      }\n      token = this._create_token(TOKEN.VALUE, content);\n    } else {\n      resulting_string = this.__patterns.attribute.read();\n\n      if (resulting_string) {\n        if (previous_token.type === TOKEN.EQUALS) {\n          token = this._create_token(TOKEN.VALUE, resulting_string);\n        } else {\n          token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);\n        }\n      }\n    }\n  }\n  return token;\n};\n\nTokenizer.prototype._is_content_unformatted = function(tag_name) {\n  // void_elements have no content and so cannot have unformatted content\n  // script and style tags should always be read as unformatted content\n  // finally content_unformatted and unformatted element contents are unformatted\n  return this._options.void_elements.indexOf(tag_name) === -1 &&\n    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||\n      this._options.unformatted.indexOf(tag_name) !== -1);\n};\n\n\nTokenizer.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false\n  var resulting_string = '';\n  if (open_token && open_token.text[0] === '{') {\n    resulting_string = this.__patterns.handlebars_raw_close.read();\n  } else if (previous_token.type === TOKEN.TAG_CLOSE && (previous_token.opened.text[0] === '<')) {\n    var tag_name = previous_token.opened.text.substr(1).toLowerCase();\n    if (tag_name === 'script' || tag_name === 'style') {\n      // Script and style tags are allowed to have comments wrapping their content\n      // or just have regular content.\n      var token = this._read_comment_or_cdata(c);\n      if (token) {\n        token.type = TOKEN.TEXT;\n        return token;\n      }\n      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\\\n\\\\r\\\\t ]*?>', 'ig'));\n    } else if (this._is_content_unformatted(tag_name)) {\n      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\\\n\\\\r\\\\t ]*?>', 'ig'));\n    }\n  }\n\n  if (resulting_string) {\n    return this._create_token(TOKEN.TEXT, resulting_string);\n  }\n\n  return null;\n};\n\nTokenizer.prototype._read_content_word = function(c) {\n  var resulting_string = '';\n  if (this._options.unformatted_content_delimiter) {\n    if (c === this._options.unformatted_content_delimiter[0]) {\n      resulting_string = this.__patterns.unformatted_content_delimiter.read();\n    }\n  }\n\n  if (!resulting_string) {\n    resulting_string = this.__patterns.word.read();\n  }\n  if (resulting_string) {\n    return this._create_token(TOKEN.TEXT, resulting_string);\n  }\n};\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\n\n\n/***/ })\n/******/ ]);\nvar style_html = legacy_beautify_html;\n/* Footer */\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(/*! ./beautify */ \"./node_modules/js-beautify/js/lib/beautify.js\"), __webpack_require__(/*! ./beautify-css */ \"./node_modules/js-beautify/js/lib/beautify-css.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {\n        var js_beautify = __webpack_require__(/*! ./beautify */ \"./node_modules/js-beautify/js/lib/beautify.js\");\n        var css_beautify = __webpack_require__(/*! ./beautify-css */ \"./node_modules/js-beautify/js/lib/beautify-css.js\");\n\n        return {\n            html_beautify: function(html_source, options) {\n                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n            }\n        };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else { var css_beautify, js_beautify; }\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWh0bWwuanM/YTZjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNLE9BQU87QUFDekU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7O0FBRzlCLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QyxFQUFFO0FBQy9FOzs7QUFHQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEUsb0RBQW9ELG1CQUFtQjtBQUN2RSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQsMkNBQTJDLGtCQUFrQjtBQUM3RCw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQkFBa0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQSxpQkFBaUI7QUFDakIsNkNBQTZDO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOENBQThDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0Q0FBNEM7QUFDakQ7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhIQUE4SDs7QUFFOUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyxvRkFBb0Y7QUFDcEYsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0MsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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QUNBO0FBQ0E7QUFDQTs7O0FBR0EsaUZBQWlGO0FBQ2pGO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUEwQztBQUM5QztBQUNBLElBQUksaUNBQU8sQ0FBQyxtQkFBUyxFQUFFLHNGQUFZLEVBQUUsOEZBQWdCLENBQUMsbUNBQUU7QUFDeEQsMEJBQTBCLG1CQUFVLENBQUMsaUVBQVk7QUFDakQsMkJBQTJCLG1CQUFVLENBQUMseUVBQWdCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUFBLG9HQUFDO0FBQ04sQ0FBQyxNQUFNLGtDQW1CTjs7QUFFRCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gU3R5bGUgSFRNTFxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgV3JpdHRlbiBieSBOb2NodW0gU29zc29ua28sIChuc29zc29ua29AaG90bWFpbC5jb20pXG5cbiAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBiZWF1dGlmaWVyLmlvPlxuICAgIGh0dHBzOi8vYmVhdXRpZmllci5pby9cblxuICBVc2FnZTpcbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlKTtcblxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfaW5uZXJfaHRtbCAoZGVmYXVsdCBmYWxzZSkgIOKAlCBpbmRlbnQgPGhlYWQ+IGFuZCA8Ym9keT4gc2VjdGlvbnMsXG4gICAgaW5kZW50X3NpemUgKGRlZmF1bHQgNCkgICAgICAgICAg4oCUIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAg4oCUIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICB3cmFwX2xpbmVfbGVuZ3RoIChkZWZhdWx0IDI1MCkgICAgICAgICAgICAtICBtYXhpbXVtIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHBlciBsaW5lICgwID0gZGlzYWJsZSlcbiAgICBicmFjZV9zdHlsZSAoZGVmYXVsdCBcImNvbGxhcHNlXCIpIC0gXCJjb2xsYXBzZVwiIHwgXCJleHBhbmRcIiB8IFwiZW5kLWV4cGFuZFwiIHwgXCJub25lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgaW5saW5lIChkZWZhdWx0cyB0byBpbmxpbmUgdGFncykgLSBsaXN0IG9mIHRhZ3MgdG8gYmUgY29uc2lkZXJlZCBpbmxpbmUgdGFnc1xuICAgIHVuZm9ybWF0dGVkIChkZWZhdWx0cyB0byBpbmxpbmUgdGFncykgLSBsaXN0IG9mIHRhZ3MsIHRoYXQgc2hvdWxkbid0IGJlIHJlZm9ybWF0dGVkXG4gICAgY29udGVudF91bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gW1wicHJlXCIsIFwidGV4dGFyZWFcIl0gdGFncykgLSBsaXN0IG9mIHRhZ3MsIHdob3NlIGNvbnRlbnQgc2hvdWxkbid0IGJlIHJlZm9ybWF0dGVkXG4gICAgaW5kZW50X3NjcmlwdHMgKGRlZmF1bHQgbm9ybWFsKSAgLSBcImtlZXBcInxcInNlcGFyYXRlXCJ8XCJub3JtYWxcIlxuICAgIHByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHRydWUpIC0gd2hldGhlciBleGlzdGluZyBsaW5lIGJyZWFrcyBiZWZvcmUgZWxlbWVudHMgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgd29ya3MgYmVmb3JlIGVsZW1lbnRzLCBub3QgaW5zaWRlIHRhZ3Mgb3IgZm9yIHRleHQuXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rXG4gICAgaW5kZW50X2hhbmRsZWJhcnMgKGRlZmF1bHQgZmFsc2UpIC0gZm9ybWF0IGFuZCBpbmRlbnQge3sjZm9vfX0gYW5kIHt7L2Zvb319XG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgZXh0cmFfbGluZXJzIChkZWZhdWx0IFtoZWFkLGJvZHksL2h0bWxdKSAtTGlzdCBvZiB0YWdzIHRoYXQgc2hvdWxkIGhhdmUgYW4gZXh0cmEgbmV3bGluZSBiZWZvcmUgdGhlbS5cblxuICAgIGUuZy5cblxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIHtcbiAgICAgICdpbmRlbnRfaW5uZXJfaHRtbCc6IGZhbHNlLFxuICAgICAgJ2luZGVudF9zaXplJzogMixcbiAgICAgICdpbmRlbnRfY2hhcic6ICcgJyxcbiAgICAgICd3cmFwX2xpbmVfbGVuZ3RoJzogNzgsXG4gICAgICAnYnJhY2Vfc3R5bGUnOiAnZXhwYW5kJyxcbiAgICAgICdwcmVzZXJ2ZV9uZXdsaW5lcyc6IHRydWUsXG4gICAgICAnbWF4X3ByZXNlcnZlX25ld2xpbmVzJzogNSxcbiAgICAgICdpbmRlbnRfaGFuZGxlYmFycyc6IGZhbHNlLFxuICAgICAgJ2V4dHJhX2xpbmVycyc6IFsnL2h0bWwnXVxuICAgIH0pO1xuKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4vKiBHRU5FUkFURURfQlVJTERfT1VUUFVUICovXG52YXIgbGVnYWN5X2JlYXV0aWZ5X2h0bWwgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxOCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovLFxuLyogMSAqLyxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICB0aGlzLl9fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgLy8gdXNlIGluZGVudF9jb3VudCBhcyBhIG1hcmtlciBmb3IgdGhpcy5fX2xpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbiAgdGhpcy5fX2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gMDtcblxuICB0aGlzLl9faXRlbXMgPSBbXTtcbn1cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuY2xvbmVfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzLl9fcGFyZW50KTtcbiAgbGluZS5zZXRfaW5kZW50KHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICByZXR1cm4gbGluZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoICsgaW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbaW5kZXhdO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5oYXNfbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIGZvciAodmFyIGxhc3RDaGVja2VkT3V0cHV0ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDE7IGxhc3RDaGVja2VkT3V0cHV0ID49IDA7IGxhc3RDaGVja2VkT3V0cHV0LS0pIHtcbiAgICBpZiAodGhpcy5fX2l0ZW1zW2xhc3RDaGVja2VkT3V0cHV0XS5tYXRjaChwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCA9IGluZGVudCB8fCAwO1xuICAgIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSBhbGlnbm1lbnQgfHwgMDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3NpemUodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSB0aGlzLl9faXRlbXMubGVuZ3RoO1xuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19pbmRlbnRfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19hbGlnbm1lbnRfY291bnQ7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zaG91bGRfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggJiZcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoICYmXG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19jaGFyYWN0ZXJfY291bnQ7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fYWxsb3dfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc2hvdWxkX3dyYXAoKSkge1xuICAgIHRoaXMuX19wYXJlbnQuYWRkX25ld19saW5lKCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLl9fcGFyZW50LmN1cnJlbnRfbGluZTtcbiAgICBuZXh0LnNldF9pbmRlbnQodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50LCB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQpO1xuICAgIG5leHQuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSh0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG4gICAgdGhpcy5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKDAsIHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcblxuICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgKz0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuXG4gICAgaWYgKG5leHQuX19pdGVtc1swXSA9PT0gXCIgXCIpIHtcbiAgICAgIG5leHQuX19pdGVtcy5zcGxpY2UoMCwgMSk7XG4gICAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9faXRlbXMubGVuZ3RoID09PSAwO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLl9faXRlbXMucHVzaChpdGVtKTtcbiAgdmFyIGxhc3RfbmV3bGluZV9pbmRleCA9IGl0ZW0ubGFzdEluZGV4T2YoJ1xcbicpO1xuICBpZiAobGFzdF9uZXdsaW5lX2luZGV4ICE9PSAtMSkge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSBpdGVtLmxlbmd0aCAtIGxhc3RfbmV3bGluZV9pbmRleDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ICs9IGl0ZW0ubGVuZ3RoO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW0gPSBudWxsO1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCAtPSAxO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gdGhpcy5fX3BhcmVudC5pbmRlbnRfc2l6ZTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV93cmFwX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCAtPSAxO1xuICB9XG59O1xuT3V0cHV0TGluZS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5sYXN0KCkgPT09ICcgJykge1xuICAgIHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGlmICh0aGlzLl9fcGFyZW50LmluZGVudF9lbXB0eV9saW5lcykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgICByZXN1bHQgKz0gdGhpcy5fX2l0ZW1zLmpvaW4oJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19jYWNoZSA9IFsnJ107XG4gIHRoaXMuX19pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gb3B0aW9ucy5pbmRlbnRfY2hhcjtcbiAgaWYgKCFvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9zaXplICsgMSkuam9pbihvcHRpb25zLmluZGVudF9jaGFyKTtcbiAgfVxuXG4gIC8vIFNldCB0byBudWxsIHRvIGNvbnRpbnVlIHN1cHBvcnQgZm9yIGF1dG8gZGV0ZWN0aW9uIG9mIGJhc2UgaW5kZW50XG4gIGJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nIHx8ICcnO1xuICBpZiAob3B0aW9ucy5pbmRlbnRfbGV2ZWwgPiAwKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9sZXZlbCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG5cbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nID0gYmFzZUluZGVudFN0cmluZztcbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aCA9IGJhc2VJbmRlbnRTdHJpbmcubGVuZ3RoO1xufVxuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGg7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50IDwgMCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmVzdWx0ICs9IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgcmVzdWx0ICs9IGNvbHVtbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudF9sZXZlbCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmc7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50X2xldmVsIDwgMCkge1xuICAgIGluZGVudF9sZXZlbCA9IDA7XG4gICAgcmVzdWx0ID0gJyc7XG4gIH1cbiAgY29sdW1uICs9IGluZGVudF9sZXZlbCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2Vuc3VyZV9jYWNoZShjb2x1bW4pO1xuICByZXN1bHQgKz0gdGhpcy5fX2NhY2hlW2NvbHVtbl07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19lbnN1cmVfY2FjaGUgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgd2hpbGUgKGNvbHVtbiA+PSB0aGlzLl9fY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5fX2FkZF9jb2x1bW4oKTtcbiAgfVxufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fYWRkX2NvbHVtbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29sdW1uID0gdGhpcy5fX2NhY2hlLmxlbmd0aDtcbiAgdmFyIGluZGVudCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX19pbmRlbnRfc2l6ZSAmJiBjb2x1bW4gPj0gdGhpcy5fX2luZGVudF9zaXplKSB7XG4gICAgaW5kZW50ID0gTWF0aC5mbG9vcihjb2x1bW4gLyB0aGlzLl9faW5kZW50X3NpemUpO1xuICAgIGNvbHVtbiAtPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGluZGVudCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG4gIGlmIChjb2x1bW4pIHtcbiAgICByZXN1bHQgKz0gbmV3IEFycmF5KGNvbHVtbiArIDEpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHRoaXMuX19jYWNoZS5wdXNoKHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBPdXRwdXQob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9faW5kZW50X2NhY2hlID0gbmV3IEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLl9lbmRfd2l0aF9uZXdsaW5lID0gb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICB0aGlzLmluZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoO1xuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IG9wdGlvbnMuaW5kZW50X2VtcHR5X2xpbmVzO1xuICB0aGlzLl9fbGluZXMgPSBbXTtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSBudWxsO1xuICB0aGlzLm5leHRfbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbiAgLy8gaW5pdGlhbGl6ZVxuICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9vdXRwdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuY3VycmVudF9saW5lO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMubmV4dF9saW5lLmNsb25lX2VtcHR5KCk7XG4gIHRoaXMuX19saW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fbGluZXMubGVuZ3RoO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc3RyaW5nKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zaXplKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnByZXZpb3VzX2xpbmUgJiYgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX25ld19saW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSkge1xuICAvLyBuZXZlciBuZXdsaW5lIGF0IHRoZSBzdGFydCBvZiBmaWxlXG4gIC8vIG90aGVyd2lzZSwgbmV3bGluZSBvbmx5IGlmIHdlIGRpZG4ndCBqdXN0IGFkZCBvbmUgb3Igd2UncmUgZm9yY2VkXG4gIGlmICh0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAoIWZvcmNlX25ld2xpbmUgJiYgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpZiByYXcgb3V0cHV0IGlzIGVuYWJsZWQsIGRvbid0IHByaW50IGFkZGl0aW9uYWwgbmV3bGluZXMsXG4gIC8vIGJ1dCBzdGlsbCByZXR1cm4gVHJ1ZSBhcyB0aG91Z2ggeW91IGhhZFxuICBpZiAoIXRoaXMucmF3KSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9jb2RlID0gZnVuY3Rpb24oZW9sKSB7XG4gIHRoaXMudHJpbSh0cnVlKTtcblxuICAvLyBoYW5kbGUgc29tZSBlZGdlIGNhc2VzIHdoZXJlIHRoZSBsYXN0IHRva2Vuc1xuICAvLyBoYXMgdGV4dCB0aGF0IGVuZHMgd2l0aCBuZXdsaW5lKHMpXG4gIHZhciBsYXN0X2l0ZW0gPSB0aGlzLmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgaWYgKGxhc3RfaXRlbSkge1xuICAgIGlmIChsYXN0X2l0ZW1bbGFzdF9pdGVtLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgbGFzdF9pdGVtID0gbGFzdF9pdGVtLnJlcGxhY2UoL1xcbiskL2csICcnKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChsYXN0X2l0ZW0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuZF93aXRoX25ld2xpbmUpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuXG4gIHZhciBzd2VldF9jb2RlID0gdGhpcy5fX2xpbmVzLmpvaW4oJ1xcbicpO1xuXG4gIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgfVxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jdXJyZW50X2xpbmUuX3NldF93cmFwX3BvaW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgYWxpZ25tZW50ID0gYWxpZ25tZW50IHx8IDA7XG5cbiAgLy8gTmV4dCBsaW5lIHN0b3JlcyBhbGlnbm1lbnQgdmFsdWVzXG4gIHRoaXMubmV4dF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuXG4gIC8vIE5ldmVyIGluZGVudCB5b3VyIGZpcnN0IG91dHB1dCBpbmRlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gIGlmICh0aGlzLl9fbGluZXMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2VuLm5ld2xpbmVzOyB4KyspIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfdG9rZW4gPSBmdW5jdGlvbihwcmludGFibGVfdG9rZW4pIHtcbiAgdGhpcy5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4oKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChwcmludGFibGVfdG9rZW4pO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSB0aGlzLmN1cnJlbnRfbGluZS5fYWxsb3dfd3JhcCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuICYmICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKCF0aGlzLm5vbl9icmVha2luZ19zcGFjZSkge1xuICAgICAgdGhpcy5zZXRfd3JhcF9wb2ludCgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKCcgJyk7XG4gIH1cbn07XG5cbk91dHB1dC5wcm90b3R5cGUucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBvdXRwdXRfbGVuZ3RoID0gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgIHRoaXMuX19saW5lc1tpbmRleF0uX3JlbW92ZV9pbmRlbnQoKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLl9yZW1vdmVfd3JhcF9pbmRlbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKGVhdF9uZXdsaW5lcykge1xuICBlYXRfbmV3bGluZXMgPSAoZWF0X25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBlYXRfbmV3bGluZXM7XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuXG4gIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG4gIH1cblxuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSA/XG4gICAgdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXSA6IG51bGw7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfbmV3bGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICh0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpICYmIHRoaXMucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUgPSBmdW5jdGlvbihzdGFydHNfd2l0aCwgZW5kc193aXRoKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19saW5lcy5sZW5ndGggLSAyO1xuICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgIHZhciBwb3RlbnRpYWxFbXB0eUxpbmUgPSB0aGlzLl9fbGluZXNbaW5kZXhdO1xuICAgIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgwKS5pbmRleE9mKHN0YXJ0c193aXRoKSAhPT0gMCAmJlxuICAgICAgcG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oLTEpICE9PSBlbmRzX3dpdGgpIHtcbiAgICAgIHRoaXMuX19saW5lcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBuZXcgT3V0cHV0TGluZSh0aGlzKSk7XG4gICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4LS07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IE91dHB1dDtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRleHQsIG5ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgLy8gY29tbWVudHMgdGhhdCBoYXZlIGEgbmV3IGxpbmUgYmVmb3JlIHRoZW1cbiAgLy8gYW5kIG1heSBvciBtYXkgbm90IGhhdmUgYSBuZXdsaW5lIGFmdGVyXG4gIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gIHRoaXMuY29tbWVudHNfYmVmb3JlID0gbnVsbDsgLyogaW5saW5lIGNvbW1lbnQqL1xuXG5cbiAgLy8gdGhpcy5jb21tZW50c19hZnRlciA9ICBuZXcgVG9rZW5TdHJlYW0oKTsgLy8gbm8gbmV3IGxpbmUgYmVmb3JlIGFuZCBuZXdsaW5lIGFmdGVyXG4gIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlID0gd2hpdGVzcGFjZV9iZWZvcmUgfHwgJyc7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gIHRoaXMub3BlbmVkID0gbnVsbDtcbiAgdGhpcy5jbG9zZWQgPSBudWxsO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA0ICovLFxuLyogNSAqLyxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpIHtcbiAgdGhpcy5yYXdfb3B0aW9ucyA9IF9tZXJnZU9wdHMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpO1xuXG4gIC8vIFN1cHBvcnQgcGFzc2luZyB0aGUgc291cmNlIHRleHQgYmFjayB3aXRoIG5vIGNoYW5nZVxuICB0aGlzLmRpc2FibGVkID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2Rpc2FibGVkJyk7XG5cbiAgdGhpcy5lb2wgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnZW9sJywgJ2F1dG8nKTtcbiAgdGhpcy5lbmRfd2l0aF9uZXdsaW5lID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2VuZF93aXRoX25ld2xpbmUnKTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9zaXplJywgNCk7XG4gIHRoaXMuaW5kZW50X2NoYXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnaW5kZW50X2NoYXInLCAnICcpO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9sZXZlbCcpO1xuXG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbigncHJlc2VydmVfbmV3bGluZXMnLCB0cnVlKTtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfcHJlc2VydmVfbmV3bGluZXMnLCAzMjc4Nik7XG4gIGlmICghdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gMDtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X3dpdGhfdGFicyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfd2l0aF90YWJzJywgdGhpcy5pbmRlbnRfY2hhciA9PT0gJ1xcdCcpO1xuICBpZiAodGhpcy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5pbmRlbnRfY2hhciA9ICdcXHQnO1xuXG4gICAgLy8gaW5kZW50X3NpemUgYmVoYXZpb3IgY2hhbmdlZCBhZnRlciAxLjguNlxuICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBpbmRlbnRfc2l6ZSB3b3VsZCBiZVxuICAgIC8vIHNldCB0byAxIGZvciBpbmRlbnRfd2l0aF90YWJzLiBUaGF0IGlzIG5vIGxvbmdlciBuZWVkZWQgYW5kXG4gICAgLy8gYWN0dWFsbHkgZG9lc24ndCBtYWtlIHNlbnNlIC0gd2h5IG5vdCB1c2Ugc3BhY2VzPyBGdXJ0aGVyLFxuICAgIC8vIHRoYXQgbWlnaHQgcHJvZHVjZSB1bmV4cGVjdGVkIGJlaGF2aW9yIC0gdGFicyBiZWluZyB1c2VkXG4gICAgLy8gZm9yIHNpbmdsZS1jb2x1bW4gYWxpZ25tZW50LiBTbywgd2hlbiBpbmRlbnRfd2l0aF90YWJzIGlzIHRydWVcbiAgICAvLyBhbmQgaW5kZW50X3NpemUgaXMgMSwgcmVzZXQgaW5kZW50X3NpemUgdG8gNC5cbiAgICBpZiAodGhpcy5pbmRlbnRfc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IDQ7XG4gICAgfVxuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdCB3aXRoIDEuMy54XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfbGluZV9sZW5ndGgnLCB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfY2hhcicpKTtcblxuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfZW1wdHlfbGluZXMnKTtcblxuICAvLyB2YWxpZCB0ZW1wbGF0aW5nIGxhbmd1YWdlcyBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnXVxuICAvLyBGb3Igbm93LCAnYXV0bycgPSBhbGwgb2ZmIGZvciBqYXZhc2NyaXB0LCBhbGwgb24gZm9yIGh0bWwgKGFuZCBpbmxpbmUgamF2YXNjcmlwdCkuXG4gIC8vIG90aGVyIHZhbHVlcyBpZ25vcmVkXG4gIHRoaXMudGVtcGxhdGluZyA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgndGVtcGxhdGluZycsIFsnYXV0bycsICdub25lJywgJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnXSwgWydhdXRvJ10pO1xufVxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2FycmF5ID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgW107XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRpb25fdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbl92YWx1ZS5jb25jYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5jb25jYXQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuc3BsaXQoL1teYS16QS1aMC05X1xcL1xcLV0rLyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYm9vbGVhbiA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBvcHRpb25fdmFsdWUgPT09IHVuZGVmaW5lZCA/ICEhZGVmYXVsdF92YWx1ZSA6ICEhb3B0aW9uX3ZhbHVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9jaGFyYWN0ZXJzID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgJyc7XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9cXFxcdC8sICdcXHQnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9udW1iZXIgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICBkZWZhdWx0X3ZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdF92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4oZGVmYXVsdF92YWx1ZSkpIHtcbiAgICBkZWZhdWx0X3ZhbHVlID0gMDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQob3B0aW9uX3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIG9ubHkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb25fbGlzdCA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uX2xpc3QgfHwgc2VsZWN0aW9uX2xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0aW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5LlwiKTtcbiAgfVxuXG4gIGRlZmF1bHRfdmFsdWUgPSBkZWZhdWx0X3ZhbHVlIHx8IFtzZWxlY3Rpb25fbGlzdFswXV07XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKGRlZmF1bHRfdmFsdWUsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRGVmYXVsdCBWYWx1ZSFcIik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X2FycmF5KG5hbWUsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gY29udGFpbiBvbmx5IHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9pc192YWxpZF9zZWxlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSB7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICYmIHNlbGVjdGlvbl9saXN0Lmxlbmd0aCAmJlxuICAgICFyZXN1bHQuc29tZShmdW5jdGlvbihpdGVtKSB7IHJldHVybiBzZWxlY3Rpb25fbGlzdC5pbmRleE9mKGl0ZW0pID09PSAtMTsgfSk7XG59O1xuXG5cbi8vIG1lcmdlcyBjaGlsZCBvcHRpb25zIHVwIHdpdGggdGhlIHBhcmVudCBvcHRpb25zIG9iamVjdFxuLy8gRXhhbXBsZTogb2JqID0ge2E6IDEsIGI6IHthOiAyfX1cbi8vICAgICAgICAgIG1lcmdlT3B0cyhvYmosICdiJylcbi8vXG4vLyAgICAgICAgICBSZXR1cm5zOiB7YTogMn1cbmZ1bmN0aW9uIF9tZXJnZU9wdHMoYWxsT3B0aW9ucywgY2hpbGRGaWVsZE5hbWUpIHtcbiAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICBhbGxPcHRpb25zID0gX25vcm1hbGl6ZU9wdHMoYWxsT3B0aW9ucyk7XG4gIHZhciBuYW1lO1xuXG4gIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgaWYgKG5hbWUgIT09IGNoaWxkRmllbGROYW1lKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgY2hpbGRGaWVsZE5hbWVcbiAgaWYgKGNoaWxkRmllbGROYW1lICYmIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXVtuYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZU9wdHMob3B0aW9ucykge1xuICB2YXIgY29udmVydGVkT3B0cyA9IHt9O1xuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgIGNvbnZlcnRlZE9wdHNbbmV3S2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVPcHRzID0gX25vcm1hbGl6ZU9wdHM7XG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBfbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqLyxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciByZWdleHBfaGFzX3N0aWNreSA9IFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3N0aWNreScpO1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKSB7XG4gIHRoaXMuX19pbnB1dCA9IGlucHV0X3N0cmluZyB8fCAnJztcbiAgdGhpcy5fX2lucHV0X2xlbmd0aCA9IHRoaXMuX19pbnB1dC5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcG9zaXRpb24gPiAwKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uIC09IDE7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX2lucHV0X2xlbmd0aDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdCh0aGlzLl9fcG9zaXRpb24pO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvbmx5IGhlbHBlciBmdW5jdGlvbiAobm90IGluIHB5dGhvbilcbi8vIEphdmFzY3JpcHQgZG9lc24ndCBoYXZlIGEgbWF0Y2ggbWV0aG9kXG4vLyBhbmQgbm90IGFsbCBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0IFwic3RpY2t5XCIgZmxhZy5cbi8vIElmIHRoZXkgZG8gbm90IHN1cHBvcnQgc3RpY2t5IHRoZW4gYm90aCB0aGlzLm1hdGNoKCkgYW5kIHRoaXMudGVzdCgpIG1ldGhvZFxuLy8gbXVzdCBnZXQgdGhlIG1hdGNoIGFuZCBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG1hdGNoLlxuLy8gSWYgc3RpY2t5IGlzIHN1cHBvcnRlZCBhbmQgc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHVzZSBpdC5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGNoZWNrIHRoYXQgZ2xvYmFsIGlzIHNldCwgYW5kIGZhbGwgYmFjayB0byB0aGUgc2xvd2VyIG1ldGhvZC5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuX19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gaW5kZXg7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG5cbiAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgIShyZWdleHBfaGFzX3N0aWNreSAmJiBwYXR0ZXJuLnN0aWNreSkpIHtcbiAgICBpZiAocGF0dGVybl9tYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG5cbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fX21hdGNoKHBhdHRlcm4sIGluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAvLyB0ZXN0IG9uZSBjaGFyYWN0ZXIgcmVnZXggbWF0Y2hcbiAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gdGhpcy5fX21hdGNoKHBhdHRlcm4sIHRoaXMuX19wb3NpdGlvbik7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oc3RhcnRpbmdfcGF0dGVybiwgdW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2g7XG4gIGlmIChzdGFydGluZ19wYXR0ZXJuKSB7XG4gICAgbWF0Y2ggPSB0aGlzLm1hdGNoKHN0YXJ0aW5nX3BhdHRlcm4pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFsICs9IG1hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBpZiAodW50aWxfcGF0dGVybiAmJiAobWF0Y2ggfHwgIXN0YXJ0aW5nX3BhdHRlcm4pKSB7XG4gICAgdmFsICs9IHRoaXMucmVhZFVudGlsKHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaF9pbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgbWF0Y2hfaW5kZXggPSBwYXR0ZXJuX21hdGNoLmluZGV4O1xuICAgIGlmICh1bnRpbF9hZnRlcikge1xuICAgICAgbWF0Y2hfaW5kZXggKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdGNoX2luZGV4ID0gdGhpcy5fX2lucHV0X2xlbmd0aDtcbiAgfVxuXG4gIHZhbCA9IHRoaXMuX19pbnB1dC5zdWJzdHJpbmcodGhpcy5fX3Bvc2l0aW9uLCBtYXRjaF9pbmRleCk7XG4gIHRoaXMuX19wb3NpdGlvbiA9IG1hdGNoX2luZGV4O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVudGlsKHBhdHRlcm4sIHRydWUpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybiwgbWF0Y2hfZnJvbSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGZsYWdzID0gJ2cnO1xuICBpZiAobWF0Y2hfZnJvbSAmJiByZWdleHBfaGFzX3N0aWNreSkge1xuICAgIGZsYWdzID0gJ3knO1xuICB9XG4gIC8vIHN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byByZWdleHBcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gIT09ICcnKSB7XG4gICAgLy8gcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCBmbGFncyk7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gZWxzZSBpZiAocGF0dGVybikge1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfbGl0ZXJhbF9yZWdleHAgPSBmdW5jdGlvbihsaXRlcmFsX3N0cmluZykge1xuICByZXR1cm4gUmVnRXhwKGxpdGVyYWxfc3RyaW5nLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpKTtcbn07XG5cbi8qIGNzcyBiZWF1dGlmaWVyIGxlZ2FjeSBoZWxwZXJzICovXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWtVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRVbnRpbEFmdGVyKHBhdHRlcm4pO1xuICB0aGlzLl9fcG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubG9va0JhY2sgPSBmdW5jdGlvbih0ZXN0VmFsKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbiAtIDE7XG4gIHJldHVybiBzdGFydCA+PSB0ZXN0VmFsLmxlbmd0aCAmJiB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHN0YXJ0IC0gdGVzdFZhbC5sZW5ndGgsIHN0YXJ0KVxuICAgIC50b0xvd2VyQ2FzZSgpID09PSB0ZXN0VmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyO1xudmFyIFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5Ub2tlbjtcbnZhciBUb2tlblN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLlRva2VuU3RyZWFtO1xudmFyIFdoaXRlc3BhY2VQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkuV2hpdGVzcGFjZVBhdHRlcm47XG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlQ6ICdUS19TVEFSVCcsXG4gIFJBVzogJ1RLX1JBVycsXG4gIEVPRjogJ1RLX0VPRidcbn07XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9fdG9rZW5zID0gbnVsbDtcblxuICB0aGlzLl9wYXR0ZXJucyA9IHt9O1xuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5wdXQucmVzdGFydCgpO1xuICB0aGlzLl9fdG9rZW5zID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgdGhpcy5fcmVzZXQoKTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIHByZXZpb3VzID0gbmV3IFRva2VuKFRPS0VOLlNUQVJULCAnJyk7XG4gIHZhciBvcGVuX3Rva2VuID0gbnVsbDtcbiAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgdmFyIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgd2hpbGUgKHByZXZpb3VzLnR5cGUgIT09IFRPS0VOLkVPRikge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgd2hpbGUgKHRoaXMuX2lzX2NvbW1lbnQoY3VycmVudCkpIHtcbiAgICAgIGNvbW1lbnRzLmFkZChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50cy5pc0VtcHR5KCkpIHtcbiAgICAgIGN1cnJlbnQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuICAgIH1cblxuICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcblxuICAgIGlmICh0aGlzLl9pc19vcGVuaW5nKGN1cnJlbnQpKSB7XG4gICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbl90b2tlbik7XG4gICAgICBvcGVuX3Rva2VuID0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4gJiYgdGhpcy5faXNfY2xvc2luZyhjdXJyZW50LCBvcGVuX3Rva2VuKSkge1xuICAgICAgY3VycmVudC5vcGVuZWQgPSBvcGVuX3Rva2VuO1xuICAgICAgb3Blbl90b2tlbi5jbG9zZWQgPSBjdXJyZW50O1xuICAgICAgb3Blbl90b2tlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG4gICAgfVxuXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50O1xuXG4gICAgdGhpcy5fX3Rva2Vucy5hZGQoY3VycmVudCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190b2tlbnM7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2ZpcnN0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zLmlzRW1wdHkoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7fTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCgvLisvZyk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SQVcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZV90b2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRleHQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5uZXdsaW5lX2NvdW50LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2Uud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5yZWFkKCk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBUb2tlblN0cmVhbShwYXJlbnRfdG9rZW4pIHtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9fdG9rZW5zID0gW107XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoID0gdGhpcy5fX3Rva2Vucy5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gIHRoaXMuX19wYXJlbnRfdG9rZW4gPSBwYXJlbnRfdG9rZW47XG59XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vuc19sZW5ndGggPT09IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX3Rva2Vuc19sZW5ndGg7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX3Rva2Vuc1t0aGlzLl9fcG9zaXRpb25dO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9fdG9rZW5zX2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbaW5kZXhdO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYgKHRoaXMuX19wYXJlbnRfdG9rZW4pIHtcbiAgICB0b2tlbi5wYXJlbnQgPSB0aGlzLl9fcGFyZW50X3Rva2VuO1xuICB9XG4gIHRoaXMuX190b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoICs9IDE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlblN0cmVhbSA9IFRva2VuU3RyZWFtO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICB0aGlzLl9pbnB1dCA9IGlucHV0X3NjYW5uZXI7XG4gIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX2FmdGVyID0gZmFsc2U7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fc3RhcnRpbmdfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9tYXRjaF9wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3VudGlsX3BhdHRlcm4pO1xuICAgIHRoaXMuX3VudGlsX2FmdGVyID0gcGFyZW50Ll91bnRpbF9hZnRlcjtcbiAgfVxufVxuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICBpZiAoIXRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gfHwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybiwgdGhpcy5fdW50aWxfcGF0dGVybiwgdGhpcy5fdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkX21hdGNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsX2FmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSB0cnVlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IGZhbHNlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuc3RhcnRpbmdfd2l0aCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUubWF0Y2hpbmcgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXR0ZXJuID0gUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxuXG52YXIgdGVtcGxhdGVfbmFtZXMgPSB7XG4gIGRqYW5nbzogZmFsc2UsXG4gIGVyYjogZmFsc2UsXG4gIGhhbmRsZWJhcnM6IGZhbHNlLFxuICBwaHA6IGZhbHNlXG59O1xuXG4vLyBUaGlzIGxldHMgdGVtcGxhdGVzIGFwcGVhciBhbnl3aGVyZSB3ZSB3b3VsZCBkbyBhIHJlYWRVbnRpbFxuLy8gVGhlIGNvc3QgaXMgaGlnaGVyIGJ1dCBpdCBpcyBwYXkgdG8gcGxheS5cbmZ1bmN0aW9uIFRlbXBsYXRhYmxlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG4gIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2V4Y2x1ZGVkLCBwYXJlbnQuX2V4Y2x1ZGVkKTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZGlzYWJsZWQsIHBhcmVudC5fZGlzYWJsZWQpO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oaW5wdXRfc2Nhbm5lcik7XG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnNfdW5lc2NhcGVkOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7ey8pLnVudGlsX2FmdGVyKC99fX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgcGhwOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzxcXD8oPzpbPV18cGhwKS8pLnVudGlsX2FmdGVyKC9cXD8+LyksXG4gICAgZXJiOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzwlW14lXS8pLnVudGlsX2FmdGVyKC9bXiVdJT4vKSxcbiAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgIGRqYW5nbzogcGF0dGVybi5zdGFydGluZ193aXRoKC97JS8pLnVudGlsX2FmdGVyKC8lfS8pLFxuICAgIGRqYW5nb192YWx1ZTogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIGRqYW5nb19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3sjLykudW50aWxfYWZ0ZXIoLyN9LylcbiAgfTtcbn1cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4oKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkX29wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gdGVtcGxhdGVfbmFtZXMpIHtcbiAgICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IG9wdGlvbnMudGVtcGxhdGluZy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTE7XG4gIH1cbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9leGNsdWRlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybiwgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICB9XG4gIHZhciBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB3aGlsZSAobmV4dCkge1xuICAgIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsKHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9hZnRlcikge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl91bnRpbF9wYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnBocC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmVyYi5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9wYXR0ZXJuKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl91bnRpbF9wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKCcoPzonICsgaXRlbXMuam9pbignfCcpICsgJyknKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3JlYWRfdGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCAmJiAhdGhpcy5fZXhjbHVkZWQucGhwICYmIHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5waHAucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYiAmJiAhdGhpcy5fZXhjbHVkZWQuZXJiICYmIHBlZWsxID09PSAnJScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5lcmIucmVhZCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMgJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfdW5lc2NhcGVkLnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5kamFuZ28pIHtcbiAgICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUucmVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28pIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ28ucmVhZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuVGVtcGxhdGFibGVQYXR0ZXJuID0gVGVtcGxhdGFibGVQYXR0ZXJuO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi8sXG4vKiAxNiAqLyxcbi8qIDE3ICovLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSkuQmVhdXRpZmllcixcbiAgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVfaHRtbDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLk9wdGlvbnM7XG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5PdXRwdXQ7XG52YXIgVG9rZW5pemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSkuVG9rZW5pemVyO1xudmFyIFRPS0VOID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSkuVE9LRU47XG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXHJcXG5dLztcbnZhciBhbGxMaW5lQnJlYWtzID0gL1xcclxcbnxbXFxyXFxuXS9nO1xuXG52YXIgUHJpbnRlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGJhc2VfaW5kZW50X3N0cmluZykgeyAvL2hhbmRsZXMgaW5wdXQvb3V0cHV0IGFuZCBzb21lIG90aGVyIHByaW50aW5nIGZ1bmN0aW9uc1xuXG4gIHRoaXMuaW5kZW50X2xldmVsID0gMDtcbiAgdGhpcy5hbGlnbm1lbnRfc2l6ZSA9IDA7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXM7XG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuXG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQob3B0aW9ucywgYmFzZV9pbmRlbnRfc3RyaW5nKTtcblxufTtcblxuUHJpbnRlci5wcm90b3R5cGUuY3VycmVudF9saW5lX2hhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUuaGFzX21hdGNoKHBhdHRlcm4pO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUuc2V0X3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKHZhbHVlLCBub25fYnJlYWtpbmcpIHtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHZhbHVlO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gbm9uX2JyZWFraW5nO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUuc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5pbmRlbnRfbGV2ZWwsIHRoaXMuYWxpZ25tZW50X3NpemUpO1xuICB0aGlzLl9vdXRwdXQuc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cblxuUHJpbnRlci5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIHRoaXMuX291dHB1dC5hZGRfcmF3X3Rva2VuKHRva2VuKTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyA9IGZ1bmN0aW9uKHJhd190b2tlbikge1xuICB2YXIgbmV3bGluZXMgPSAwO1xuICBpZiAocmF3X3Rva2VuLnR5cGUgIT09IFRPS0VOLlRFWFQgJiYgcmF3X3Rva2VuLnByZXZpb3VzLnR5cGUgIT09IFRPS0VOLlRFWFQpIHtcbiAgICBuZXdsaW5lcyA9IHJhd190b2tlbi5uZXdsaW5lcyA/IDEgOiAwO1xuICB9XG5cbiAgaWYgKHRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICBuZXdsaW5lcyA9IHJhd190b2tlbi5uZXdsaW5lcyA8IHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzICsgMSA/IHJhd190b2tlbi5uZXdsaW5lcyA6IHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzICsgMTtcbiAgfVxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5ld2xpbmVzOyBuKyspIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUobiA+IDApO1xuICB9XG5cbiAgcmV0dXJuIG5ld2xpbmVzICE9PSAwO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUudHJhdmVyc2Vfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHJhd190b2tlbikge1xuICBpZiAocmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlIHx8IHJhd190b2tlbi5uZXdsaW5lcykge1xuICAgIGlmICghdGhpcy5wcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMocmF3X3Rva2VuKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX291dHB1dC5wcmV2aW91c190b2tlbl93cmFwcGVkO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJpbnRfbmV3bGluZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2UpO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJpbnRfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICBpZiAodG9rZW4udGV4dCkge1xuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuaW5kZW50X2xldmVsLCB0aGlzLmFsaWdubWVudF9zaXplKTtcbiAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKHRva2VuLnRleHQpO1xuICB9XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwrKztcbn07XG5cblByaW50ZXIucHJvdG90eXBlLmdldF9mdWxsX2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIGxldmVsID0gdGhpcy5pbmRlbnRfbGV2ZWwgKyAobGV2ZWwgfHwgMCk7XG4gIGlmIChsZXZlbCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fb3V0cHV0LmdldF9pbmRlbnRfc3RyaW5nKGxldmVsKTtcbn07XG5cbnZhciBnZXRfdHlwZV9hdHRyaWJ1dGUgPSBmdW5jdGlvbihzdGFydF90b2tlbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIHJhd190b2tlbiA9IHN0YXJ0X3Rva2VuLm5leHQ7XG5cbiAgLy8gU2VhcmNoIGF0dHJpYnV0ZXMgZm9yIGEgdHlwZSBhdHRyaWJ1dGVcbiAgd2hpbGUgKHJhd190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiYgc3RhcnRfdG9rZW4uY2xvc2VkICE9PSByYXdfdG9rZW4pIHtcbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSAmJiByYXdfdG9rZW4udGV4dCA9PT0gJ3R5cGUnKSB7XG4gICAgICBpZiAocmF3X3Rva2VuLm5leHQgJiYgcmF3X3Rva2VuLm5leHQudHlwZSA9PT0gVE9LRU4uRVFVQUxTICYmXG4gICAgICAgIHJhd190b2tlbi5uZXh0Lm5leHQgJiYgcmF3X3Rva2VuLm5leHQubmV4dC50eXBlID09PSBUT0tFTi5WQUxVRSkge1xuICAgICAgICByZXN1bHQgPSByYXdfdG9rZW4ubmV4dC5uZXh0LnRleHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmF3X3Rva2VuID0gcmF3X3Rva2VuLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdldF9jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gZnVuY3Rpb24odGFnX2NoZWNrLCByYXdfdG9rZW4pIHtcbiAgdmFyIHR5cGVBdHRyaWJ1dGUgPSBudWxsO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICBpZiAoIXJhd190b2tlbi5jbG9zZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0YWdfY2hlY2sgPT09ICdzY3JpcHQnKSB7XG4gICAgdHlwZUF0dHJpYnV0ZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3N0eWxlJykge1xuICAgIHR5cGVBdHRyaWJ1dGUgPSAndGV4dC9jc3MnO1xuICB9XG5cbiAgdHlwZUF0dHJpYnV0ZSA9IGdldF90eXBlX2F0dHJpYnV0ZShyYXdfdG9rZW4pIHx8IHR5cGVBdHRyaWJ1dGU7XG5cbiAgLy8gRm9yIHNjcmlwdCBhbmQgc3R5bGUgdGFncyB0aGF0IGhhdmUgYSB0eXBlIGF0dHJpYnV0ZSwgb25seSBlbmFibGUgY3VzdG9tIGJlYXV0aWZpZXJzIGZvciBtYXRjaGluZyB2YWx1ZXNcbiAgLy8gRm9yIHRob3NlIHdpdGhvdXQgYSB0eXBlIGF0dHJpYnV0ZSB1c2UgZGVmYXVsdDtcbiAgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKCd0ZXh0L2NzcycpID4gLTEpIHtcbiAgICByZXN1bHQgPSAnY3NzJztcbiAgfSBlbHNlIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgvKHRleHR8YXBwbGljYXRpb258ZG9qbylcXC8oeC0pPyhqYXZhc2NyaXB0fGVjbWFzY3JpcHR8anNjcmlwdHxsaXZlc2NyaXB0fChsZFxcKyk/anNvbnxtZXRob2R8YXNwZWN0KS8pID4gLTEpIHtcbiAgICByZXN1bHQgPSAnamF2YXNjcmlwdCc7XG4gIH0gZWxzZSBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goLyh0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oaHRtbCkvKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2h0bWwnO1xuICB9IGVsc2UgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKC90ZXN0XFwvbnVsbC8pID4gLTEpIHtcbiAgICAvLyBUZXN0IG9ubHkgbWltZS10eXBlIGZvciB0ZXN0aW5nIHRoZSBiZWF1dGlmaWVyIHdoZW4gbnVsbCBpcyBwYXNzZWQgYXMgYmVhdXRpZmluZyBmdW5jdGlvblxuICAgIHJlc3VsdCA9ICdudWxsJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gVGFnRnJhbWUocGFyZW50LCBwYXJzZXJfdG9rZW4sIGluZGVudF9sZXZlbCkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB0aGlzLnRhZyA9IHBhcnNlcl90b2tlbiA/IHBhcnNlcl90b2tlbi50YWdfbmFtZSA6ICcnO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IGluZGVudF9sZXZlbCB8fCAwO1xuICB0aGlzLnBhcnNlcl90b2tlbiA9IHBhcnNlcl90b2tlbiB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBUYWdTdGFjayhwcmludGVyKSB7XG4gIHRoaXMuX3ByaW50ZXIgPSBwcmludGVyO1xuICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gbnVsbDtcbn1cblxuVGFnU3RhY2sucHJvdG90eXBlLmdldF9wYXJzZXJfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N1cnJlbnRfZnJhbWUgPyB0aGlzLl9jdXJyZW50X2ZyYW1lLnBhcnNlcl90b2tlbiA6IG51bGw7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUucmVjb3JkX3RhZyA9IGZ1bmN0aW9uKHBhcnNlcl90b2tlbikgeyAvL2Z1bmN0aW9uIHRvIHJlY29yZCBhIHRhZyBhbmQgaXRzIHBhcmVudCBpbiB0aGlzLnRhZ3MgT2JqZWN0XG4gIHZhciBuZXdfZnJhbWUgPSBuZXcgVGFnRnJhbWUodGhpcy5fY3VycmVudF9mcmFtZSwgcGFyc2VyX3Rva2VuLCB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCk7XG4gIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBuZXdfZnJhbWU7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuX3RyeV9wb3BfZnJhbWUgPSBmdW5jdGlvbihmcmFtZSkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIHBhcnNlcl90b2tlbiA9IG51bGw7XG5cbiAgaWYgKGZyYW1lKSB7XG4gICAgcGFyc2VyX3Rva2VuID0gZnJhbWUucGFyc2VyX3Rva2VuO1xuICAgIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsID0gZnJhbWUuaW5kZW50X2xldmVsO1xuICAgIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBmcmFtZS5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLl9nZXRfZnJhbWUgPSBmdW5jdGlvbih0YWdfbGlzdCwgc3RvcF9saXN0KSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICB2YXIgZnJhbWUgPSB0aGlzLl9jdXJyZW50X2ZyYW1lO1xuXG4gIHdoaWxlIChmcmFtZSkgeyAvL3RpbGwgd2UgcmVhY2ggJycgKHRoZSBpbml0aWFsIHZhbHVlKTtcbiAgICBpZiAodGFnX2xpc3QuaW5kZXhPZihmcmFtZS50YWcpICE9PSAtMSkgeyAvL2lmIHRoaXMgaXMgaXQgdXNlIGl0XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHN0b3BfbGlzdCAmJiBzdG9wX2xpc3QuaW5kZXhPZihmcmFtZS50YWcpICE9PSAtMSkge1xuICAgICAgZnJhbWUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZyYW1lID0gZnJhbWUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLnRyeV9wb3AgPSBmdW5jdGlvbih0YWcsIHN0b3BfbGlzdCkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIGZyYW1lID0gdGhpcy5fZ2V0X2ZyYW1lKFt0YWddLCBzdG9wX2xpc3QpO1xuICByZXR1cm4gdGhpcy5fdHJ5X3BvcF9mcmFtZShmcmFtZSk7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuaW5kZW50X3RvX3RhZyA9IGZ1bmN0aW9uKHRhZ19saXN0KSB7XG4gIHZhciBmcmFtZSA9IHRoaXMuX2dldF9mcmFtZSh0YWdfbGlzdCk7XG4gIGlmIChmcmFtZSkge1xuICAgIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsID0gZnJhbWUuaW5kZW50X2xldmVsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KSB7XG4gIC8vV3JhcHBlciBmdW5jdGlvbiB0byBpbnZva2UgYWxsIHRoZSBuZWNlc3NhcnkgY29uc3RydWN0b3JzIGFuZCBkZWFsIHdpdGggdGhlIG91dHB1dC5cbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2pzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG4gIHRoaXMuX2Nzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbiAgdGhpcy5fdGFnX3N0YWNrID0gbnVsbDtcblxuICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgdmFyIG9wdGlvbkh0bWwgPSBuZXcgT3B0aW9ucyhvcHRpb25zLCAnaHRtbCcpO1xuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25IdG1sO1xuXG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAnZm9yY2UnLmxlbmd0aCkgPT09ICdmb3JjZSc7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScpO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWFsaWduZWQnKTtcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2FsaWduZWRfbXVsdGlwbGUgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdhbGlnbmVkLW11bHRpcGxlJyk7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAncHJlc2VydmUnLmxlbmd0aCkgPT09ICdwcmVzZXJ2ZSc7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAncHJlc2VydmUtYWxpZ25lZCcpO1xufVxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGlmIGRpc2FibGVkLCByZXR1cm4gdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAodGhpcy5fb3B0aW9ucy5lb2wgPT09ICdhdXRvJykge1xuICAgIGVvbCA9ICdcXG4nO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCkpIHtcbiAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgfVxuICB9XG5cbiAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHZhciBsYXN0X3Rva2VuID0ge1xuICAgIHRleHQ6ICcnLFxuICAgIHR5cGU6ICcnXG4gIH07XG5cbiAgdmFyIGxhc3RfdGFnX3Rva2VuID0gbmV3IFRhZ09wZW5QYXJzZXJUb2tlbigpO1xuXG4gIHZhciBwcmludGVyID0gbmV3IFByaW50ZXIodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHZhciB0b2tlbnMgPSBuZXcgVG9rZW5pemVyKHNvdXJjZV90ZXh0LCB0aGlzLl9vcHRpb25zKS50b2tlbml6ZSgpO1xuXG4gIHRoaXMuX3RhZ19zdGFjayA9IG5ldyBUYWdTdGFjayhwcmludGVyKTtcblxuICB2YXIgcGFyc2VyX3Rva2VuID0gbnVsbDtcbiAgdmFyIHJhd190b2tlbiA9IHRva2Vucy5uZXh0KCk7XG4gIHdoaWxlIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GKSB7XG5cbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGFnX29wZW4ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbik7XG4gICAgICBsYXN0X3RhZ190b2tlbiA9IHBhcnNlcl90b2tlbjtcbiAgICB9IGVsc2UgaWYgKChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlZBTFVFKSB8fFxuICAgICAgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUICYmICFsYXN0X3RhZ190b2tlbi50YWdfY29tcGxldGUpKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfaW5zaWRlX3RhZyhwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCB0b2tlbnMpO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RhZ19jbG9zZShwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGV4dChwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgaWYgaXQgZG9lcy4gUHJpbnQgdGhlIHJhdyB0b2tlblxuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgfVxuXG4gICAgbGFzdF90b2tlbiA9IHBhcnNlcl90b2tlbjtcblxuICAgIHJhd190b2tlbiA9IHRva2Vucy5uZXh0KCk7XG4gIH1cbiAgdmFyIHN3ZWV0X2NvZGUgPSBwcmludGVyLl9vdXRwdXQuZ2V0X2NvZGUoZW9sKTtcblxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9oYW5kbGVfdGFnX2Nsb3NlID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6IHJhd190b2tlbi50eXBlXG4gIH07XG4gIHByaW50ZXIuYWxpZ25tZW50X3NpemUgPSAwO1xuICBsYXN0X3RhZ190b2tlbi50YWdfY29tcGxldGUgPSB0cnVlO1xuXG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIGlmIChsYXN0X3RhZ190b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLnRleHRbMF0gPT09ICcvJywgdHJ1ZSk7IC8vIHNwYWNlIGJlZm9yZSAvPiwgbm8gc3BhY2UgYmVmb3JlID5cbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSAmJiBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycykge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG5cbiAgfVxuXG4gIGlmIChsYXN0X3RhZ190b2tlbi5pbmRlbnRfY29udGVudCAmJlxuICAgICEobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICBwcmludGVyLmluZGVudCgpO1xuXG4gICAgLy8gb25seSBpbmRlbnQgb25jZSBwZXIgb3BlbmVkIHRhZ1xuICAgIGxhc3RfdGFnX3Rva2VuLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWxhc3RfdGFnX3Rva2VuLmlzX2lubGluZV9lbGVtZW50ICYmXG4gICAgIShsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgIHByaW50ZXIuc2V0X3dyYXBfcG9pbnQoKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX2luc2lkZV90YWcgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCB0b2tlbnMpIHtcbiAgdmFyIHdyYXBwZWQgPSBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycztcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiByYXdfdG9rZW4udHlwZVxuICB9O1xuXG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRFWFQpIHtcbiAgICAvLyBGb3IgdGhlIGluc2lkZXMgb2YgaGFuZGxlYmFycyBhbGxvdyBuZXdsaW5lcyBvciBhIHNpbmdsZSBzcGFjZSBiZXR3ZWVuIG9wZW4gYW5kIGNvbnRlbnRzXG4gICAgaWYgKHByaW50ZXIucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbikpIHtcbiAgICAgIHJhd190b2tlbi5uZXdsaW5lcyA9IDA7XG4gICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSkge1xuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHRydWUpO1xuICAgICAgbGFzdF90YWdfdG9rZW4uYXR0cl9jb3VudCArPSAxO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykgeyAvL25vIHNwYWNlIGJlZm9yZSA9XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4oZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlZBTFVFICYmIHJhd190b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5FUVVBTFMpIHsgLy9ubyBzcGFjZSBiZWZvcmUgdmFsdWVcbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUgJiYgbGFzdF90YWdfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZSB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCkge1xuICAgICAgICBwcmludGVyLnRyYXZlcnNlX3doaXRlc3BhY2UocmF3X3Rva2VuKTtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQgfHwgcmF3X3Rva2VuLm5ld2xpbmVzICE9PSAwO1xuICAgICAgfVxuXG5cbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UpIHtcbiAgICAgICAgdmFyIGZvcmNlX2F0dHJfd3JhcCA9IGxhc3RfdGFnX3Rva2VuLmF0dHJfY291bnQgPiAxO1xuICAgICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgbGFzdF90YWdfdG9rZW4uYXR0cl9jb3VudCA9PT0gMSkge1xuICAgICAgICAgIHZhciBpc19vbmx5X2F0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgdmFyIHBlZWtfaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBwZWVrX3Rva2VuO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBlZWtfdG9rZW4gPSB0b2tlbnMucGVlayhwZWVrX2luZGV4KTtcbiAgICAgICAgICAgIGlmIChwZWVrX3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSkge1xuICAgICAgICAgICAgICBpc19vbmx5X2F0dHJpYnV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZWtfaW5kZXggKz0gMTtcbiAgICAgICAgICB9IHdoaWxlIChwZWVrX2luZGV4IDwgNCAmJiBwZWVrX3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRiAmJiBwZWVrX3Rva2VuLnR5cGUgIT09IFRPS0VOLlRBR19DTE9TRSk7XG5cbiAgICAgICAgICBmb3JjZV9hdHRyX3dyYXAgPSAhaXNfb25seV9hdHRyaWJ1dGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VfYXR0cl93cmFwKSB7XG4gICAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgICAgICB3cmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gICAgd3JhcHBlZCA9IHdyYXBwZWQgfHwgcHJpbnRlci5wcmV2aW91c190b2tlbl93cmFwcGVkKCk7XG4gICAgbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnMgPSB3cmFwcGVkO1xuICB9XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RleHQgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKSB7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogJ1RLX0NPTlRFTlQnXG4gIH07XG4gIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lKSB7IC8vY2hlY2sgaWYgd2UgbmVlZCB0byBmb3JtYXQgamF2YXNjcmlwdFxuICAgIHRoaXMuX3ByaW50X2N1c3RvbV9iZWF0aWZpZXJfdGV4dChwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICB9XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fcHJpbnRfY3VzdG9tX2JlYXRpZmllcl90ZXh0ID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgbG9jYWwgPSB0aGlzO1xuICBpZiAocmF3X3Rva2VuLnRleHQgIT09ICcnKSB7XG5cbiAgICB2YXIgdGV4dCA9IHJhd190b2tlbi50ZXh0LFxuICAgICAgX2JlYXV0aWZpZXIsXG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMSxcbiAgICAgIHByZSA9ICcnLFxuICAgICAgcG9zdCA9ICcnO1xuICAgIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnamF2YXNjcmlwdCcgJiYgdHlwZW9mIHRoaXMuX2pzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfYmVhdXRpZmllciA9IHRoaXMuX2pzX2JlYXV0aWZ5O1xuICAgIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2NzcycgJiYgdHlwZW9mIHRoaXMuX2Nzc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX2JlYXV0aWZpZXIgPSB0aGlzLl9jc3NfYmVhdXRpZnk7XG4gICAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgIF9iZWF1dGlmaWVyID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywgbG9jYWwuX2pzX2JlYXV0aWZ5LCBsb2NhbC5fY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwia2VlcFwiKSB7XG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IC1wcmludGVyLmluZGVudF9sZXZlbDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50YXRpb24gPSBwcmludGVyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbXB0eSBsaW5lIGF0IHRoZSBlbmQgb2YgdGhpcyB0ZXh0LCBzdHJpcCBpdFxuICAgIC8vIHdlJ2xsIGJlIGFkZGluZyBvbmUgYmFjayBhZnRlciB0aGUgdGV4dCBidXQgYmVmb3JlIHRoZSBjb250YWluaW5nIHRhZy5cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKTtcblxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBjb250ZW50IGlzIHdyYXBwZWQgaW4gYSBjb21tZW50IG9yIGNkYXRhLlxuICAgIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lICE9PSAnaHRtbCcgJiZcbiAgICAgIHRleHRbMF0gPT09ICc8JyAmJiB0ZXh0Lm1hdGNoKC9eKDwhLS18PCFcXFtDREFUQVxcWykvKSkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAvXig8IS0tW15cXG5dKnw8IVxcW0NEQVRBXFxbKShcXG4/KShbIFxcdFxcbl0qKShbXFxzXFxTXSopKC0tPnxdXT4pJC8uZXhlYyh0ZXh0KTtcblxuICAgICAgLy8gaWYgd2Ugc3RhcnQgdG8gd3JhcCBidXQgZG9uJ3QgZmluaXNoLCBwcmludCByYXdcbiAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmUgPSBpbmRlbnRhdGlvbiArIG1hdGNoZWRbMV0gKyAnXFxuJztcbiAgICAgIHRleHQgPSBtYXRjaGVkWzRdO1xuICAgICAgaWYgKG1hdGNoZWRbNV0pIHtcbiAgICAgICAgcG9zdCA9IGluZGVudGF0aW9uICsgbWF0Y2hlZFs1XTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVtcHR5IGxpbmUgYXQgdGhlIGVuZCBvZiB0aGlzIHRleHQsIHN0cmlwIGl0XG4gICAgICAvLyB3ZSdsbCBiZSBhZGRpbmcgb25lIGJhY2sgYWZ0ZXIgdGhlIHRleHQgYnV0IGJlZm9yZSB0aGUgY29udGFpbmluZyB0YWcuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKTtcblxuICAgICAgaWYgKG1hdGNoZWRbMl0gfHwgbWF0Y2hlZFszXS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIG5vbi1jb21tZW50IHRleHQgaGFzIHNwYWNlc1xuICAgICAgICAvLyB1c2UgdGhhdCBhcyB0aGUgYmFzaXMgZm9yIGluZGVudGluZyBpbiBudWxsIGNhc2UuXG4gICAgICAgIG1hdGNoZWQgPSBtYXRjaGVkWzNdLm1hdGNoKC9bIFxcdF0rJC8pO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9IG1hdGNoZWRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgaWYgKF9iZWF1dGlmaWVyKSB7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgQmVhdXRpZmllciBpZiBhdmFsaWFibGVcbiAgICAgICAgdmFyIENoaWxkX29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmVvbCA9ICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICBDaGlsZF9vcHRpb25zLnByb3RvdHlwZSA9IHRoaXMuX29wdGlvbnMucmF3X29wdGlvbnM7XG4gICAgICAgIHZhciBjaGlsZF9vcHRpb25zID0gbmV3IENoaWxkX29wdGlvbnMoKTtcbiAgICAgICAgdGV4dCA9IF9iZWF1dGlmaWVyKGluZGVudGF0aW9uICsgdGV4dCwgY2hpbGRfb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW1wbHkgaW5kZW50IHRoZSBzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICAgIHZhciB3aGl0ZSA9IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZTtcbiAgICAgICAgaWYgKHdoaXRlKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKCdcXG4oJyArIHdoaXRlICsgJyk/JywgJ2cnKSwgJ1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IGluZGVudGF0aW9uICsgdGV4dC5yZXBsYWNlKC9cXG4vZywgJ1xcbicgKyBpbmRlbnRhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZSkge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRleHQgPSBwcmUgKyBwb3N0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZSArIHRleHQgKyAnXFxuJyArIHBvc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgcmF3X3Rva2VuLnRleHQgPSB0ZXh0O1xuICAgICAgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlID0gJyc7XG4gICAgICByYXdfdG9rZW4ubmV3bGluZXMgPSAwO1xuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RhZ19vcGVuID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0gdGhpcy5fZ2V0X3RhZ19vcGVuX3Rva2VuKHJhd190b2tlbik7XG5cbiAgaWYgKChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSAmJlxuICAgIHJhd190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTiAmJiByYXdfdG9rZW4udGV4dC5pbmRleE9mKCc8LycpID09PSAwKSB7XG4gICAgLy8gRW5kIGVsZW1lbnQgdGFncyBmb3IgdW5mb3JtYXR0ZWQgb3IgY29udGVudF91bmZvcm1hdHRlZCBlbGVtZW50c1xuICAgIC8vIGFyZSBwcmludGVkIHJhdyB0byBrZWVwIGFueSBuZXdsaW5lcyBpbnNpZGUgdGhlbSBleGFjdGx5IHRoZSBzYW1lLlxuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHByaW50ZXIudHJhdmVyc2Vfd2hpdGVzcGFjZShyYXdfdG9rZW4pO1xuICAgIHRoaXMuX3NldF90YWdfcG9zaXRpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBwYXJzZXJfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuKTtcbiAgICBpZiAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCkge1xuICAgICAgcHJpbnRlci5zZXRfd3JhcF9wb2ludCgpO1xuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gIH1cblxuICAvL2luZGVudCBhdHRyaWJ1dGVzIGFuIGF1dG8sIGZvcmNlZCwgYWxpZ25lZCBvciBmb3JjZWQtYWxpZ24gbGluZS13cmFwXG4gIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfYWxpZ25lZF9tdWx0aXBsZSB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCkge1xuICAgIHBhcnNlcl90b2tlbi5hbGlnbm1lbnRfc2l6ZSA9IHJhd190b2tlbi50ZXh0Lmxlbmd0aCArIDE7XG4gIH1cblxuICBpZiAoIXBhcnNlcl90b2tlbi50YWdfY29tcGxldGUgJiYgIXBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWxpZ25tZW50X3NpemUgPSBwYXJzZXJfdG9rZW4uYWxpZ25tZW50X3NpemU7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxudmFyIFRhZ09wZW5QYXJzZXJUb2tlbiA9IGZ1bmN0aW9uKHBhcmVudCwgcmF3X3Rva2VuKSB7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHRoaXMudGV4dCA9ICcnO1xuICB0aGlzLnR5cGUgPSAnVEtfVEFHX09QRU4nO1xuICB0aGlzLnRhZ19uYW1lID0gJyc7XG4gIHRoaXMuaXNfaW5saW5lX2VsZW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc191bmZvcm1hdHRlZCA9IGZhbHNlO1xuICB0aGlzLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5pc19lbXB0eV9lbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNfc3RhcnRfdGFnID0gZmFsc2U7XG4gIHRoaXMuaXNfZW5kX3RhZyA9IGZhbHNlO1xuICB0aGlzLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gIHRoaXMubXVsdGlsaW5lX2NvbnRlbnQgPSBmYWxzZTtcbiAgdGhpcy5jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gbnVsbDtcbiAgdGhpcy5zdGFydF90YWdfdG9rZW4gPSBudWxsO1xuICB0aGlzLmF0dHJfY291bnQgPSAwO1xuICB0aGlzLmhhc193cmFwcGVkX2F0dHJzID0gZmFsc2U7XG4gIHRoaXMuYWxpZ25tZW50X3NpemUgPSAwO1xuICB0aGlzLnRhZ19jb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLnRhZ19zdGFydF9jaGFyID0gJyc7XG4gIHRoaXMudGFnX2NoZWNrID0gJyc7XG5cbiAgaWYgKCFyYXdfdG9rZW4pIHtcbiAgICB0aGlzLnRhZ19jb21wbGV0ZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZ19jaGVja19tYXRjaDtcblxuICAgIHRoaXMudGFnX3N0YXJ0X2NoYXIgPSByYXdfdG9rZW4udGV4dFswXTtcbiAgICB0aGlzLnRleHQgPSByYXdfdG9rZW4udGV4dDtcblxuICAgIGlmICh0aGlzLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIHRhZ19jaGVja19tYXRjaCA9IHJhd190b2tlbi50ZXh0Lm1hdGNoKC9ePChbXlxccz5dKikvKTtcbiAgICAgIHRoaXMudGFnX2NoZWNrID0gdGFnX2NoZWNrX21hdGNoID8gdGFnX2NoZWNrX21hdGNoWzFdIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ19jaGVja19tYXRjaCA9IHJhd190b2tlbi50ZXh0Lm1hdGNoKC9ee3tbI1xcXl0/KFteXFxzfV0rKS8pO1xuICAgICAgdGhpcy50YWdfY2hlY2sgPSB0YWdfY2hlY2tfbWF0Y2ggPyB0YWdfY2hlY2tfbWF0Y2hbMV0gOiAnJztcbiAgICB9XG4gICAgdGhpcy50YWdfY2hlY2sgPSB0aGlzLnRhZ19jaGVjay50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgICB0aGlzLnRhZ19jb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc19zdGFydF90YWcgPSB0aGlzLnRhZ19jaGVjay5jaGFyQXQoMCkgIT09ICcvJztcbiAgICB0aGlzLnRhZ19uYW1lID0gIXRoaXMuaXNfc3RhcnRfdGFnID8gdGhpcy50YWdfY2hlY2suc3Vic3RyKDEpIDogdGhpcy50YWdfY2hlY2s7XG4gICAgdGhpcy5pc19lbmRfdGFnID0gIXRoaXMuaXNfc3RhcnRfdGFnIHx8XG4gICAgICAocmF3X3Rva2VuLmNsb3NlZCAmJiByYXdfdG9rZW4uY2xvc2VkLnRleHQgPT09ICcvPicpO1xuXG4gICAgLy8gaGFuZGxlYmFycyB0YWdzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCAjIG9yIF4gYXJlIHNpbmdsZV90YWdzLCBhbmQgc28gYWxzbyBzdGFydCBhbmQgZW5kLlxuICAgIHRoaXMuaXNfZW5kX3RhZyA9IHRoaXMuaXNfZW5kX3RhZyB8fFxuICAgICAgKHRoaXMudGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiAodGhpcy50ZXh0Lmxlbmd0aCA8IDMgfHwgKC9bXiNcXF5dLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoMikpKSkpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fZ2V0X3RhZ19vcGVuX3Rva2VuID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7IC8vZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCB0YWcgYW5kIHBhcnNlIGl0cyB0eXBlXG4gIHZhciBwYXJzZXJfdG9rZW4gPSBuZXcgVGFnT3BlblBhcnNlclRva2VuKHRoaXMuX3RhZ19zdGFjay5nZXRfcGFyc2VyX3Rva2VuKCksIHJhd190b2tlbik7XG5cbiAgcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplID0gdGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemU7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcgPSBwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZyB8fFxuICAgIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMudm9pZF9lbGVtZW50cyk7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgPSBwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlIHx8XG4gICAgKHBhcnNlcl90b2tlbi5pc19zdGFydF90YWcgJiYgcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcpO1xuXG4gIHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCA9ICFwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlICYmIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWQpO1xuICBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCA9ICFwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCAmJiBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLmNvbnRlbnRfdW5mb3JtYXR0ZWQpO1xuICBwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgPSBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX25hbWUsIHRoaXMuX29wdGlvbnMuaW5saW5lKSB8fCBwYXJzZXJfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICd7JztcblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3NldF90YWdfcG9zaXRpb24gPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIHBhcnNlcl90b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pIHtcblxuICBpZiAoIXBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50KSB7XG4gICAgaWYgKHBhcnNlcl90b2tlbi5pc19lbmRfdGFnKSB7IC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgICBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuID0gdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AocGFyc2VyX3Rva2VuLnRhZ19uYW1lKTsgLy9yZW1vdmUgaXQgYW5kIGFsbCBhbmNlc3RvcnNcbiAgICB9IGVsc2UgeyAvLyBpdCdzIGEgc3RhcnQtdGFnXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIHRhZyBpcyBzdGFydGluZyBhbiBlbGVtZW50IHRoYXQgaGFzIG9wdGlvbmFsIGVuZCBlbGVtZW50XG4gICAgICAvLyBhbmQgZG8gYW4gZW5kaW5nIG5lZWRlZFxuICAgICAgaWYgKHRoaXMuX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50KHBhcnNlcl90b2tlbikpIHtcbiAgICAgICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQpIHtcbiAgICAgICAgICBpZiAocGFyc2VyX3Rva2VuLnBhcmVudCkge1xuICAgICAgICAgICAgcGFyc2VyX3Rva2VuLnBhcmVudC5tdWx0aWxpbmVfY29udGVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLl90YWdfc3RhY2sucmVjb3JkX3RhZyhwYXJzZXJfdG9rZW4pOyAvL3B1c2ggaXQgb24gdGhlIHRhZyBzdGFja1xuXG4gICAgICBpZiAoKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3NjcmlwdCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnc3R5bGUnKSAmJlxuICAgICAgICAhKHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCB8fCBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPSBnZXRfY3VzdG9tX2JlYXV0aWZpZXJfbmFtZShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCByYXdfdG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLmV4dHJhX2xpbmVycykpIHsgLy9jaGVjayBpZiB0aGlzIGRvdWJsZSBuZWVkcyBhbiBleHRyYSBsaW5lXG4gICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICBpZiAoIXByaW50ZXIuX291dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpKSB7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50KSB7IC8vaWYgdGhpcyB0YWcgbmFtZSBpcyBhIHNpbmdsZSB0YWcgdHlwZSAoZWl0aGVyIGluIHRoZSBsaXN0IG9yIGhhcyBhIGNsb3NpbmcgLylcblxuICAgIC8vIGlmIHlvdSBoaXQgYW4gZWxzZSBjYXNlLCByZXNldCB0aGUgaW5kZW50IGxldmVsIGlmIHlvdSBhcmUgaW5zaWRlIGFuOlxuICAgIC8vICdpZicsICd1bmxlc3MnLCBvciAnZWFjaCcgYmxvY2suXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmIHBhcnNlcl90b2tlbi50YWdfY2hlY2sgPT09ICdlbHNlJykge1xuICAgICAgdGhpcy5fdGFnX3N0YWNrLmluZGVudF90b190YWcoWydpZicsICd1bmxlc3MnLCAnZWFjaCddKTtcbiAgICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9IHRydWU7XG4gICAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGlmIG9wZW5pbmcge3sjaWZ9fSB0YWcgaXMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgdmFyIGZvdW5kSWZPbkN1cnJlbnRMaW5lID0gcHJpbnRlci5jdXJyZW50X2xpbmVfaGFzX21hdGNoKC97eyNpZi8pO1xuICAgICAgaWYgKCFmb3VuZElmT25DdXJyZW50TGluZSkge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgYmVmb3JlIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlbWFpbiB3aGVyZSB0aGV5IGFyZS5cbiAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnIS0tJyAmJiBsYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJlxuICAgICAgbGFzdF90YWdfdG9rZW4uaXNfZW5kX3RhZyAmJiBwYXJzZXJfdG9rZW4udGV4dC5pbmRleE9mKCdcXG4nKSA9PT0gLTEpIHtcbiAgICAgIC8vRG8gbm90aGluZy4gTGVhdmUgY29tbWVudHMgb24gc2FtZSBsaW5lLlxuICAgIH0gZWxzZSBpZiAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJiAhcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgcGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpIHtcbiAgICBpZiAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJiAhcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZykgeyAvL3RoaXMgdGFnIGlzIGEgZG91YmxlIHRhZyBzbyBjaGVjayBmb3IgdGFnLWVuZGluZ1xuICAgIGlmICgocGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiAmJiBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuLm11bHRpbGluZV9jb250ZW50KSB8fFxuICAgICAgIShwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgfHxcbiAgICAgICAgKGxhc3RfdGFnX3Rva2VuLmlzX2lubGluZV9lbGVtZW50KSB8fFxuICAgICAgICAobGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICAgICAgICBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuID09PSBsYXN0X3RhZ190b2tlbikgfHxcbiAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gJ1RLX0NPTlRFTlQnKVxuICAgICAgKSkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIGl0J3MgYSBzdGFydC10YWdcbiAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSAhcGFyc2VyX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWU7XG5cbiAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdodG1sJykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9pbm5lcl9odG1sO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdoZWFkJykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9oZWFkX2lubmVyX2h0bWw7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9IHRoaXMuX29wdGlvbnMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJiBsYXN0X3Rva2VuLnR5cGUgIT09ICdUS19DT05URU5UJykge1xuICAgICAgaWYgKHBhcnNlcl90b2tlbi5wYXJlbnQpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLnBhcmVudC5tdWx0aWxpbmVfY29udGVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIH1cbiAgfVxufTtcblxuLy9UbyBiZSB1c2VkIGZvciA8cD4gdGFnIHNwZWNpYWwgY2FzZTpcbi8vdmFyIHBfY2xvc2VycyA9IFsnYWRkcmVzcycsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jsb2NrcXVvdGUnLCAnZGV0YWlscycsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2hyJywgJ21haW4nLCAnbmF2JywgJ29sJywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50ID0gZnVuY3Rpb24ocGFyc2VyX3Rva2VuKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICAvLyBOT1RFOiBjYXNlcyBvZiBcImlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnRcIlxuICAvLyBhcmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBiZWF1dGlmaWVyLlxuICAvLyBJdCBhc3N1bWVzIHBhcmVudCBvciBhbmNlc3RvciBjbG9zZSB0YWcgY2xvc2VzIGFsbCBjaGlsZHJlbi5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3NcbiAgaWYgKHBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50IHx8ICFwYXJzZXJfdG9rZW4uaXNfc3RhcnRfdGFnIHx8ICFwYXJzZXJfdG9rZW4ucGFyZW50KSB7XG4gICAgcmV0dXJuO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnYm9keScpIHtcbiAgICAvLyBBIGhlYWQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgaGVhZCBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNwYWNlIGNoYXJhY3RlciBvciBhIGNvbW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdoZWFkJyk7XG5cbiAgICAvL30gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnYm9keScpIHtcbiAgICAvLyBET05FOiBBIGJvZHkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgYm9keSBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIGNvbW1lbnQuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdsaScpIHtcbiAgICAvLyBBbiBsaSBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBsaSBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgbGkgZWxlbWVudCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnbGknLCBbJ29sJywgJ3VsJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnZGQnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2R0Jykge1xuICAgIC8vIEEgZGQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZGQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGRkIGVsZW1lbnQgb3IgYSBkdCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgZHQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZHQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGR0IGVsZW1lbnQgb3IgYSBkZCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnZHQnLCBbJ2RsJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnZGQnLCBbJ2RsJ10pO1xuXG4gICAgLy99IGVsc2UgaWYgKHBfY2xvc2Vycy5pbmRleE9mKHBhcnNlcl90b2tlbi50YWdfbmFtZSkgIT09IC0xKSB7XG4gICAgLy9UT0RPOiBUSElTIElTIEEgQlVHIEZBUk0uIFdlIGFyZSBub3QgcHV0dGluZyB0aGlzIGludG8gMS44LjAgYXMgaXQgaXMgbGlrZWx5IHRvIGJsb3cgdXAuXG4gICAgLy9BIHAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgcCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIGFkZHJlc3MsIGFydGljbGUsIGFzaWRlLCBibG9ja3F1b3RlLCBkZXRhaWxzLCBkaXYsIGRsLCBmaWVsZHNldCwgZmlnY2FwdGlvbiwgZmlndXJlLCBmb290ZXIsIGZvcm0sIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIGhlYWRlciwgaHIsIG1haW4sIG5hdiwgb2wsIHAsIHByZSwgc2VjdGlvbiwgdGFibGUsIG9yIHVsIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQgYW5kIHRoZSBwYXJlbnQgZWxlbWVudCBpcyBhbiBIVE1MIGVsZW1lbnQgdGhhdCBpcyBub3QgYW4gYSwgYXVkaW8sIGRlbCwgaW5zLCBtYXAsIG5vc2NyaXB0LCBvciB2aWRlbyBlbGVtZW50LCBvciBhbiBhdXRvbm9tb3VzIGN1c3RvbSBlbGVtZW50LlxuICAgIC8vcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdwJywgWydib2R5J10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAncnAnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3J0Jykge1xuICAgIC8vIEFuIHJ0IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHJ0IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gcnQgb3IgcnAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBbiBycCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBycCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIHJ0IG9yIHJwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdydCcsIFsncnVieScsICdydGMnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdycCcsIFsncnVieScsICdydGMnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdvcHRncm91cCcpIHtcbiAgICAvLyBBbiBvcHRncm91cCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBvcHRncm91cCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgb3B0Z3JvdXAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBbiBvcHRpb24gZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgb3B0aW9uIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBvcHRpb24gZWxlbWVudCwgb3IgaWYgaXQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb3B0Z3JvdXAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ29wdGdyb3VwJywgWydzZWxlY3QnXSk7XG4gICAgLy9yZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ29wdGlvbicsIFsnc2VsZWN0J10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnb3B0aW9uJykge1xuICAgIC8vIEFuIG9wdGlvbiBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBvcHRpb24gZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIG9wdGlvbiBlbGVtZW50LCBvciBpZiBpdCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvcHRncm91cCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnb3B0aW9uJywgWydzZWxlY3QnLCAnZGF0YWxpc3QnLCAnb3B0Z3JvdXAnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdjb2xncm91cCcpIHtcbiAgICAvLyBET05FOiBBIGNvbGdyb3VwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGNvbGdyb3VwIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgc3BhY2UgY2hhcmFjdGVyIG9yIGEgY29tbWVudC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGhlYWQnKSB7XG4gICAgLy8gQSBjb2xncm91cCBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NvbGdyb3VwJywgWyd0YWJsZSddKTtcblxuICAgIC8vfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdjYXB0aW9uJykge1xuICAgIC8vIERPTkU6IEEgY2FwdGlvbiBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBjYXB0aW9uIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgc3BhY2UgY2hhcmFjdGVyIG9yIGEgY29tbWVudC5cblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3Rib2R5JyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0Zm9vdCcpIHtcbiAgICAvLyBBIHRoZWFkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRoZWFkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0Ym9keSBvciB0Zm9vdCBlbGVtZW50LlxuICAgIC8vIEEgdGJvZHkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGJvZHkgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRib2R5IG9yIHRmb290IGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSBjb2xncm91cCBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NvbGdyb3VwJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RoZWFkJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3Rib2R5JywgWyd0YWJsZSddKTtcblxuICAgIC8vfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0Zm9vdCcpIHtcbiAgICAvLyBET05FOiBBIHRmb290IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RyJykge1xuICAgIC8vIEEgdHIgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdHIgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIHRyIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSBjb2xncm91cCBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NvbGdyb3VwJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RyJywgWyd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RoJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0ZCcpIHtcbiAgICAvLyBBIHRkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0ZCBvciB0aCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgdGggZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGggZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRkIG9yIHRoIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0ZCcsIFsndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnLCAndHInXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0aCcsIFsndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnLCAndHInXSk7XG4gIH1cblxuICAvLyBTdGFydCBlbGVtZW50IG9taXNzaW9uIG5vdCBoYW5kbGVkIGN1cnJlbnRseVxuICAvLyBBIGhlYWQgZWxlbWVudOKAmXMgc3RhcnQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5LCBvciBpZiB0aGUgZmlyc3QgdGhpbmcgaW5zaWRlIHRoZSBoZWFkIGVsZW1lbnQgaXMgYW4gZWxlbWVudC5cbiAgLy8gQSB0Ym9keSBlbGVtZW504oCZcyBzdGFydCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGZpcnN0IHRoaW5nIGluc2lkZSB0aGUgdGJvZHkgZWxlbWVudCBpcyBhIHRyIGVsZW1lbnQsIGFuZCBpZiB0aGUgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYnkgYSB0Ym9keSwgdGhlYWQsIG9yIHRmb290IGVsZW1lbnQgd2hvc2UgZW5kIHRhZyBoYXMgYmVlbiBvbWl0dGVkLiAoSXQgY2Fu4oCZdCBiZSBvbWl0dGVkIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5LilcbiAgLy8gQSBjb2xncm91cCBlbGVtZW504oCZcyBzdGFydCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGZpcnN0IHRoaW5nIGluc2lkZSB0aGUgY29sZ3JvdXAgZWxlbWVudCBpcyBhIGNvbCBlbGVtZW50LCBhbmQgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IHByZWNlZGVkIGJ5IGFub3RoZXIgY29sZ3JvdXAgZWxlbWVudCB3aG9zZSBlbmQgdGFnIGhhcyBiZWVuIG9taXR0ZWQuIChJdCBjYW7igJl0IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHkuKVxuXG4gIC8vIEZpeCB1cCB0aGUgcGFyZW50IG9mIHRoZSBwYXJzZXIgdG9rZW5cbiAgcGFyc2VyX3Rva2VuLnBhcmVudCA9IHRoaXMuX3RhZ19zdGFjay5nZXRfcGFyc2VyX3Rva2VuKCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuT3B0aW9ucztcblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zKSB7XG4gIEJhc2VPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucywgJ2h0bWwnKTtcbiAgaWYgKHRoaXMudGVtcGxhdGluZy5sZW5ndGggPT09IDEgJiYgdGhpcy50ZW1wbGF0aW5nWzBdID09PSAnYXV0bycpIHtcbiAgICB0aGlzLnRlbXBsYXRpbmcgPSBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnXTtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X2lubmVyX2h0bWwgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2lubmVyX2h0bWwnKTtcbiAgdGhpcy5pbmRlbnRfYm9keV9pbm5lcl9odG1sID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9ib2R5X2lubmVyX2h0bWwnLCB0cnVlKTtcbiAgdGhpcy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9oZWFkX2lubmVyX2h0bWwnLCB0cnVlKTtcblxuICB0aGlzLmluZGVudF9oYW5kbGViYXJzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9oYW5kbGViYXJzJywgdHJ1ZSk7XG4gIHRoaXMud3JhcF9hdHRyaWJ1dGVzID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignd3JhcF9hdHRyaWJ1dGVzJyxcbiAgICBbJ2F1dG8nLCAnZm9yY2UnLCAnZm9yY2UtYWxpZ25lZCcsICdmb3JjZS1leHBhbmQtbXVsdGlsaW5lJywgJ2FsaWduZWQtbXVsdGlwbGUnLCAncHJlc2VydmUnLCAncHJlc2VydmUtYWxpZ25lZCddKTtcbiAgdGhpcy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUnLCB0aGlzLmluZGVudF9zaXplKTtcbiAgdGhpcy5leHRyYV9saW5lcnMgPSB0aGlzLl9nZXRfYXJyYXkoJ2V4dHJhX2xpbmVycycsIFsnaGVhZCcsICdib2R5JywgJy9odG1sJ10pO1xuXG4gIC8vIEJsb2NrIHZzIGlubGluZSBlbGVtZW50c1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0Jsb2NrLWxldmVsX2VsZW1lbnRzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvSW5saW5lX2VsZW1lbnRzXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG4gIHRoaXMuaW5saW5lID0gdGhpcy5fZ2V0X2FycmF5KCdpbmxpbmUnLCBbXG4gICAgJ2EnLCAnYWJicicsICdhcmVhJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NpdGUnLFxuICAgICdjb2RlJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGVsJywgJ2RmbicsICdlbScsICdlbWJlZCcsICdpJywgJ2lmcmFtZScsICdpbWcnLFxuICAgICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdtYXAnLCAnbWFyaycsICdtYXRoJywgJ21ldGVyJywgJ25vc2NyaXB0JyxcbiAgICAnb2JqZWN0JywgJ291dHB1dCcsICdwcm9ncmVzcycsICdxJywgJ3J1YnknLCAncycsICdzYW1wJywgLyogJ3NjcmlwdCcsICovICdzZWxlY3QnLCAnc21hbGwnLFxuICAgICdzcGFuJywgJ3N0cm9uZycsICdzdWInLCAnc3VwJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0aW1lJywgJ3UnLCAndmFyJyxcbiAgICAndmlkZW8nLCAnd2JyJywgJ3RleHQnLFxuICAgIC8vIG9ic29sZXRlIGlubGluZSB0YWdzXG4gICAgJ2Fjcm9ueW0nLCAnYmlnJywgJ3N0cmlrZScsICd0dCdcbiAgXSk7XG4gIHRoaXMudm9pZF9lbGVtZW50cyA9IHRoaXMuX2dldF9hcnJheSgndm9pZF9lbGVtZW50cycsIFtcbiAgICAvLyBIVExNIHZvaWQgZWxlbWVudHMgLSBha2Egc2VsZi1jbG9zaW5nIHRhZ3MgLSBha2Egc2luZ2xldG9uc1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9zeW50YXguaHRtbCN2b2lkLWVsZW1lbnRzXG4gICAgJ2FyZWEnLCAnYmFzZScsICdicicsICdjb2wnLCAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsXG4gICAgJ2xpbmsnLCAnbWVudWl0ZW0nLCAnbWV0YScsICdwYXJhbScsICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJyxcbiAgICAvLyBOT1RFOiBPcHRpb25hbCB0YWdzIGFyZSB0b28gY29tcGxleCBmb3IgYSBzaW1wbGUgbGlzdFxuICAgIC8vIHRoZXkgYXJlIGhhcmQgY29kZWQgaW4gX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50XG5cbiAgICAvLyBEb2N0eXBlIGFuZCB4bWwgZWxlbWVudHNcbiAgICAnIWRvY3R5cGUnLCAnP3htbCcsXG5cbiAgICAvLyBvYnNvbGV0ZSB0YWdzXG4gICAgLy8gYmFzZWZvbnQ6IGh0dHBzOi8vd3d3LmNvbXB1dGVyaG9wZS5jb20vamFyZ29uL2gvaHRtbC1iYXNlZm9udC10YWcuaHRtXG4gICAgLy8gaXNuZGV4OiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaXNpbmRleFxuICAgICdiYXNlZm9udCcsICdpc2luZGV4J1xuICBdKTtcbiAgdGhpcy51bmZvcm1hdHRlZCA9IHRoaXMuX2dldF9hcnJheSgndW5mb3JtYXR0ZWQnLCBbXSk7XG4gIHRoaXMuY29udGVudF91bmZvcm1hdHRlZCA9IHRoaXMuX2dldF9hcnJheSgnY29udGVudF91bmZvcm1hdHRlZCcsIFtcbiAgICAncHJlJywgJ3RleHRhcmVhJ1xuICBdKTtcbiAgdGhpcy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCd1bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcicpO1xuICB0aGlzLmluZGVudF9zY3JpcHRzID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignaW5kZW50X3NjcmlwdHMnLCBbJ25vcm1hbCcsICdrZWVwJywgJ3NlcGFyYXRlJ10pO1xuXG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VUb2tlbml6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLlRva2VuaXplcjtcbnZhciBCQVNFVE9LRU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLlRPS0VOO1xudmFyIERpcmVjdGl2ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5EaXJlY3RpdmVzO1xudmFyIFRlbXBsYXRhYmxlUGF0dGVybiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLlRlbXBsYXRhYmxlUGF0dGVybjtcbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxudmFyIFRPS0VOID0ge1xuICBUQUdfT1BFTjogJ1RLX1RBR19PUEVOJyxcbiAgVEFHX0NMT1NFOiAnVEtfVEFHX0NMT1NFJyxcbiAgQVRUUklCVVRFOiAnVEtfQVRUUklCVVRFJyxcbiAgRVFVQUxTOiAnVEtfRVFVQUxTJyxcbiAgVkFMVUU6ICdUS19WQUxVRScsXG4gIENPTU1FTlQ6ICdUS19DT01NRU5UJyxcbiAgVEVYVDogJ1RLX1RFWFQnLFxuICBVTktOT1dOOiAnVEtfVU5LTk9XTicsXG4gIFNUQVJUOiBCQVNFVE9LRU4uU1RBUlQsXG4gIFJBVzogQkFTRVRPS0VOLlJBVyxcbiAgRU9GOiBCQVNFVE9LRU4uRU9GXG59O1xuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoLzxcXCEtLS8sIC8tLT4vKTtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICBCYXNlVG9rZW5pemVyLmNhbGwodGhpcywgaW5wdXRfc3RyaW5nLCBvcHRpb25zKTtcbiAgdGhpcy5fY3VycmVudF90YWdfbmFtZSA9ICcnO1xuXG4gIC8vIFdvcmRzIGVuZCBhdCB3aGl0ZXNwYWNlIG9yIHdoZW4gYSB0YWcgc3RhcnRzXG4gIC8vIGlmIHdlIGFyZSBpbmRlbnRpbmcgaGFuZGxlYmFycywgdGhleSBhcmUgY29uc2lkZXJlZCB0YWdzXG4gIHZhciB0ZW1wbGF0YWJsZV9yZWFkZXIgPSBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0KS5yZWFkX29wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gIHZhciBwYXR0ZXJuX3JlYWRlciA9IG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0KTtcblxuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgd29yZDogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0IDxdLyksXG4gICAgc2luZ2xlX3F1b3RlOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWxfYWZ0ZXIoLycvKSxcbiAgICBkb3VibGVfcXVvdGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbF9hZnRlcigvXCIvKSxcbiAgICBhdHRyaWJ1dGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCA9XFwvPl0vKSxcbiAgICBlbGVtZW50X25hbWU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCA+XFwvXS8pLFxuXG4gICAgaGFuZGxlYmFyc19jb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC97eyEtLS8pLnVudGlsX2FmdGVyKC8tLX19LyksXG4gICAgaGFuZGxlYmFyczogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgve3svKS51bnRpbF9hZnRlcigvfX0vKSxcbiAgICBoYW5kbGViYXJzX29wZW46IHBhdHRlcm5fcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0IH1dLyksXG4gICAgaGFuZGxlYmFyc19yYXdfY2xvc2U6IHBhdHRlcm5fcmVhZGVyLnVudGlsKC99fS8pLFxuICAgIGNvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzwhLS0vKS51bnRpbF9hZnRlcigvLS0+LyksXG4gICAgY2RhdGE6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzwhXFxbQ0RBVEFcXFsvKS51bnRpbF9hZnRlcigvXV0+LyksXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudFxuICAgIGNvbmRpdGlvbmFsX2NvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzwhXFxbLykudW50aWxfYWZ0ZXIoL10+LyksXG4gICAgcHJvY2Vzc2luZzogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvPFxcPy8pLnVudGlsX2FmdGVyKC9cXD8+LylcbiAgfTtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycykge1xuICAgIHRoaXMuX19wYXR0ZXJucy53b3JkID0gdGhpcy5fX3BhdHRlcm5zLndvcmQuZXhjbHVkZSgnaGFuZGxlYmFycycpO1xuICB9XG5cbiAgdGhpcy5fdW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIgPSBudWxsO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKSB7XG4gICAgdmFyIGxpdGVyYWxfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X2xpdGVyYWxfcmVnZXhwKHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIpO1xuICAgIHRoaXMuX19wYXR0ZXJucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciA9XG4gICAgICBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZyhsaXRlcmFsX3JlZ2V4cClcbiAgICAgIC51bnRpbF9hZnRlcihsaXRlcmFsX3JlZ2V4cCk7XG4gIH1cbn07XG5Ub2tlbml6ZXIucHJvdG90eXBlID0gbmV3IEJhc2VUb2tlbml6ZXIoKTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7IC8vY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVU5LTk9XTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY2xvc2luZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIG9wZW5fdG9rZW4pIHtcbiAgcmV0dXJuIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmXG4gICAgKG9wZW5fdG9rZW4gJiYgKFxuICAgICAgKChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc+JyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcvPicpICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJzwnKSB8fFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ319JyAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICd7JyAmJiBvcGVuX3Rva2VuLnRleHRbMV0gPT09ICd7JykpKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N1cnJlbnRfdGFnX25hbWUgPSAnJztcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICBpZiAoYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cblxuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfb3Blbl9oYW5kbGViYXJzKGMsIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfYXR0cmlidXRlKGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3Jhd19jb250ZW50KGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2Nsb3NlKGMsIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY29udGVudF93b3JkKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY29tbWVudF9vcl9jZGF0YShjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3Byb2Nlc3NpbmcoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9vcGVuKGMsIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29tbWVudF9vcl9jZGF0YSA9IGZ1bmN0aW9uKGMpIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciBkaXJlY3RpdmVzID0gbnVsbDtcblxuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgLy8gd2Ugb25seSBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2luZyBtYXJrZXJcbiAgICBpZiAocGVlazEgPT09ICchJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5jb21tZW50LnJlYWQoKTtcblxuICAgICAgLy8gb25seSBwcm9jZXNzIGRpcmVjdGl2ZSBvbiBodG1sIGNvbW1lbnRzXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICBkaXJlY3RpdmVzID0gZGlyZWN0aXZlc19jb3JlLmdldF9kaXJlY3RpdmVzKHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5jZGF0YS5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgdG9rZW4uZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9wcm9jZXNzaW5nID0gZnVuY3Rpb24oYykgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIGRpcmVjdGl2ZXMgPSBudWxsO1xuXG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIGlmIChwZWVrMSA9PT0gJyEnIHx8IHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuY29uZGl0aW9uYWxfY29tbWVudC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fCB0aGlzLl9fcGF0dGVybnMucHJvY2Vzc2luZy5yZWFkKCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgdG9rZW4uZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9vcGVuID0gZnVuY3Rpb24oYywgb3Blbl90b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmICghb3Blbl90b2tlbikge1xuICAgIGlmIChjID09PSAnPCcpIHtcblxuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICcvJykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5fX3BhdHRlcm5zLmVsZW1lbnRfbmFtZS5yZWFkKCk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfT1BFTiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfb3Blbl9oYW5kbGViYXJzID0gZnVuY3Rpb24oYywgb3Blbl90b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmICghb3Blbl90b2tlbikge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9oYW5kbGViYXJzICYmIGMgPT09ICd7JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAneycpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKDIpID09PSAnIScpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fCB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFycy5yZWFkKCk7XG4gICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX29wZW4ucmVhZCgpO1xuICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfT1BFTiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jbG9zZSA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAob3Blbl90b2tlbikge1xuICAgIGlmIChvcGVuX3Rva2VuLnRleHRbMF0gPT09ICc8JyAmJiAoYyA9PT0gJz4nIHx8IChjID09PSAnLycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJz4nKSkpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAoYyA9PT0gJy8nKSB7IC8vICBmb3IgY2xvc2UgdGFnIFwiLz5cIlxuICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19DTE9TRSwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfSBlbHNlIGlmIChvcGVuX3Rva2VuLnRleHRbMF0gPT09ICd7JyAmJiBjID09PSAnfScgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ30nKSB7XG4gICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfQ0xPU0UsICd9fScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfYXR0cmlidXRlID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgaWYgKG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAnPCcpIHtcblxuICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVRVUFMUywgdGhpcy5faW5wdXQubmV4dCgpKTtcbiAgICB9IGVsc2UgaWYgKGMgPT09ICdcIicgfHwgYyA9PT0gXCInXCIpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgY29udGVudCArPSB0aGlzLl9fcGF0dGVybnMuZG91YmxlX3F1b3RlLnJlYWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgKz0gdGhpcy5fX3BhdHRlcm5zLnNpbmdsZV9xdW90ZS5yZWFkKCk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5WQUxVRSwgY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuYXR0cmlidXRlLnJlYWQoKTtcblxuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlZBTFVFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5BVFRSSUJVVEUsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgPSBmdW5jdGlvbih0YWdfbmFtZSkge1xuICAvLyB2b2lkX2VsZW1lbnRzIGhhdmUgbm8gY29udGVudCBhbmQgc28gY2Fubm90IGhhdmUgdW5mb3JtYXR0ZWQgY29udGVudFxuICAvLyBzY3JpcHQgYW5kIHN0eWxlIHRhZ3Mgc2hvdWxkIGFsd2F5cyBiZSByZWFkIGFzIHVuZm9ybWF0dGVkIGNvbnRlbnRcbiAgLy8gZmluYWxseSBjb250ZW50X3VuZm9ybWF0dGVkIGFuZCB1bmZvcm1hdHRlZCBlbGVtZW50IGNvbnRlbnRzIGFyZSB1bmZvcm1hdHRlZFxuICByZXR1cm4gdGhpcy5fb3B0aW9ucy52b2lkX2VsZW1lbnRzLmluZGV4T2YodGFnX25hbWUpID09PSAtMSAmJlxuICAgICh0aGlzLl9vcHRpb25zLmNvbnRlbnRfdW5mb3JtYXR0ZWQuaW5kZXhPZih0YWdfbmFtZSkgIT09IC0xIHx8XG4gICAgICB0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkLmluZGV4T2YodGFnX25hbWUpICE9PSAtMSk7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcmF3X2NvbnRlbnQgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmIChvcGVuX3Rva2VuICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJ3snKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX3Jhd19jbG9zZS5yZWFkKCk7XG4gIH0gZWxzZSBpZiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmIChwcmV2aW91c190b2tlbi5vcGVuZWQudGV4dFswXSA9PT0gJzwnKSkge1xuICAgIHZhciB0YWdfbmFtZSA9IHByZXZpb3VzX3Rva2VuLm9wZW5lZC50ZXh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0YWdfbmFtZSA9PT0gJ3NjcmlwdCcgfHwgdGFnX25hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgIC8vIFNjcmlwdCBhbmQgc3R5bGUgdGFncyBhcmUgYWxsb3dlZCB0byBoYXZlIGNvbW1lbnRzIHdyYXBwaW5nIHRoZWlyIGNvbnRlbnRcbiAgICAgIC8vIG9yIGp1c3QgaGF2ZSByZWd1bGFyIGNvbnRlbnQuXG4gICAgICB2YXIgdG9rZW4gPSB0aGlzLl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEoYyk7XG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgdG9rZW4udHlwZSA9IFRPS0VOLlRFWFQ7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkVW50aWwobmV3IFJlZ0V4cCgnPC8nICsgdGFnX25hbWUgKyAnW1xcXFxuXFxcXHJcXFxcdCBdKj8+JywgJ2lnJykpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNfY29udGVudF91bmZvcm1hdHRlZCh0YWdfbmFtZSkpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkVW50aWwobmV3IFJlZ0V4cCgnPC8nICsgdGFnX25hbWUgKyAnW1xcXFxuXFxcXHJcXFxcdCBdKj8+JywgJ2lnJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5URVhULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jb250ZW50X3dvcmQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmICh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKSB7XG4gICAgaWYgKGMgPT09IHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXJbMF0pIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIucmVhZCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMud29yZC5yZWFkKCk7XG4gIH1cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRFWFQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBzdHlsZV9odG1sID0gbGVnYWN5X2JlYXV0aWZ5X2h0bWw7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiLi9iZWF1dGlmeVwiLCBcIi4vYmVhdXRpZnktY3NzXCJdLCBmdW5jdGlvbihyZXF1aXJlYW1kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5XCIpO1xuICAgICAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnktY3NzXCIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBodG1sX2JlYXV0aWZ5OiBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LmpzJyk7XG4gICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnktY3NzLmpzJyk7XG5cbiAgICBleHBvcnRzLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93Lmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgd2luZG93LmpzX2JlYXV0aWZ5LCB3aW5kb3cuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBnbG9iYWwuanNfYmVhdXRpZnksIGdsb2JhbC5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59XG5cbn0oKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/lib/beautify-html.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/lib/beautify.js":
/*!*****************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@beautifier.io>\n      https://beautifier.io/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\" | any of the former + \",preserve-inline\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n            preserve-inline will try to preserve inline blocks of curly braces\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/\n\n(function() {\n\n/* GENERATED_BUILD_OUTPUT */\nvar legacy_beautify_js =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Beautifier = __webpack_require__(1).Beautifier,\n  Options = __webpack_require__(5).Options;\n\nfunction js_beautify(js_source_text, options) {\n  var beautifier = new Beautifier(js_source_text, options);\n  return beautifier.beautify();\n}\n\nmodule.exports = js_beautify;\nmodule.exports.defaultOptions = function() {\n  return new Options();\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Output = __webpack_require__(2).Output;\nvar Token = __webpack_require__(3).Token;\nvar acorn = __webpack_require__(4);\nvar Options = __webpack_require__(5).Options;\nvar Tokenizer = __webpack_require__(7).Tokenizer;\nvar line_starters = __webpack_require__(7).line_starters;\nvar positionable_operators = __webpack_require__(7).positionable_operators;\nvar TOKEN = __webpack_require__(7).TOKEN;\n\n\nfunction in_array(what, arr) {\n  return arr.indexOf(what) !== -1;\n}\n\nfunction ltrim(s) {\n  return s.replace(/^\\s+/g, '');\n}\n\nfunction generateMapFromStrings(list) {\n  var result = {};\n  for (var x = 0; x < list.length; x++) {\n    // make the mapped names underscored instead of dash\n    result[list[x].replace(/-/g, '_')] = list[x];\n  }\n  return result;\n}\n\nfunction reserved_word(token, word) {\n  return token && token.type === TOKEN.RESERVED && token.text === word;\n}\n\nfunction reserved_array(token, words) {\n  return token && token.type === TOKEN.RESERVED && in_array(token.text, words);\n}\n// Unsure of what they mean, but they work. Worth cleaning up in future.\nvar special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];\n\nvar validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];\n\n// Generate map from array\nvar OPERATOR_POSITION = generateMapFromStrings(validPositionValues);\n\nvar OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];\n\nvar MODE = {\n  BlockStatement: 'BlockStatement', // 'BLOCK'\n  Statement: 'Statement', // 'STATEMENT'\n  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\n  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\n  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\n  Conditional: 'Conditional', //'(COND-EXPRESSION)',\n  Expression: 'Expression' //'(EXPRESSION)'\n};\n\nfunction remove_redundant_indentation(output, frame) {\n  // This implementation is effective but has some issues:\n  //     - can cause line wrap to happen too soon due to indent removal\n  //           after wrap points are calculated\n  // These issues are minor compared to ugly indentation.\n\n  if (frame.multiline_frame ||\n    frame.mode === MODE.ForInitializer ||\n    frame.mode === MODE.Conditional) {\n    return;\n  }\n\n  // remove one indent from each line inside this section\n  output.remove_indent(frame.start_line_index);\n}\n\n// we could use just string.split, but\n// IE doesn't like returning empty strings\nfunction split_linebreaks(s) {\n  //return s.split(/\\x0d\\x0a|\\x0a/);\n\n  s = s.replace(acorn.allLineBreaks, '\\n');\n  var out = [],\n    idx = s.indexOf(\"\\n\");\n  while (idx !== -1) {\n    out.push(s.substring(0, idx));\n    s = s.substring(idx + 1);\n    idx = s.indexOf(\"\\n\");\n  }\n  if (s.length) {\n    out.push(s);\n  }\n  return out;\n}\n\nfunction is_array(mode) {\n  return mode === MODE.ArrayLiteral;\n}\n\nfunction is_expression(mode) {\n  return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);\n}\n\nfunction all_lines_start_with(lines, c) {\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i].trim();\n    if (line.charAt(0) !== c) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction each_line_matches_indent(lines, indent) {\n  var i = 0,\n    len = lines.length,\n    line;\n  for (; i < len; i++) {\n    line = lines[i];\n    // allow empty lines to pass through\n    if (line && line.indexOf(indent) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nfunction Beautifier(source_text, options) {\n  options = options || {};\n  this._source_text = source_text || '';\n\n  this._output = null;\n  this._tokens = null;\n  this._last_last_text = null;\n  this._flags = null;\n  this._previous_flags = null;\n\n  this._flag_store = null;\n  this._options = new Options(options);\n}\n\nBeautifier.prototype.create_flags = function(flags_base, mode) {\n  var next_indent_level = 0;\n  if (flags_base) {\n    next_indent_level = flags_base.indentation_level;\n    if (!this._output.just_added_newline() &&\n      flags_base.line_indent_level > next_indent_level) {\n      next_indent_level = flags_base.line_indent_level;\n    }\n  }\n\n  var next_flags = {\n    mode: mode,\n    parent: flags_base,\n    last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ''), // last token text\n    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed\n    declaration_statement: false,\n    declaration_assignment: false,\n    multiline_frame: false,\n    inline_frame: false,\n    if_block: false,\n    else_block: false,\n    do_block: false,\n    do_while: false,\n    import_block: false,\n    in_case_statement: false, // switch(..){ INSIDE HERE }\n    in_case: false, // we're on the exact line with \"case 0:\"\n    case_body: false, // the indented case-action block\n    indentation_level: next_indent_level,\n    alignment: 0,\n    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n    start_line_index: this._output.get_line_number(),\n    ternary_depth: 0\n  };\n  return next_flags;\n};\n\nBeautifier.prototype._reset = function(source_text) {\n  var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n\n  this._last_last_text = ''; // pre-last token text\n  this._output = new Output(this._options, baseIndentString);\n\n  // If testing the ignore directive, start with output disable set to true\n  this._output.raw = this._options.test_output_raw;\n\n\n  // Stack of parsing/formatting states, including MODE.\n  // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n  // and formatted output.  This makes the beautifier less accurate than full parsers\n  // but also far more tolerant of syntax errors.\n  //\n  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n  // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n  // most full parsers would die, but the beautifier gracefully falls back to\n  // MODE.BlockStatement and continues on.\n  this._flag_store = [];\n  this.set_mode(MODE.BlockStatement);\n  var tokenizer = new Tokenizer(source_text, this._options);\n  this._tokens = tokenizer.tokenize();\n  return source_text;\n};\n\nBeautifier.prototype.beautify = function() {\n  // if disabled, return the input unchanged.\n  if (this._options.disabled) {\n    return this._source_text;\n  }\n\n  var sweet_code;\n  var source_text = this._reset(this._source_text);\n\n  var eol = this._options.eol;\n  if (this._options.eol === 'auto') {\n    eol = '\\n';\n    if (source_text && acorn.lineBreak.test(source_text || '')) {\n      eol = source_text.match(acorn.lineBreak)[0];\n    }\n  }\n\n  var current_token = this._tokens.next();\n  while (current_token) {\n    this.handle_token(current_token);\n\n    this._last_last_text = this._flags.last_token.text;\n    this._flags.last_token = current_token;\n\n    current_token = this._tokens.next();\n  }\n\n  sweet_code = this._output.get_code(eol);\n\n  return sweet_code;\n};\n\nBeautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {\n  if (current_token.type === TOKEN.START_EXPR) {\n    this.handle_start_expr(current_token);\n  } else if (current_token.type === TOKEN.END_EXPR) {\n    this.handle_end_expr(current_token);\n  } else if (current_token.type === TOKEN.START_BLOCK) {\n    this.handle_start_block(current_token);\n  } else if (current_token.type === TOKEN.END_BLOCK) {\n    this.handle_end_block(current_token);\n  } else if (current_token.type === TOKEN.WORD) {\n    this.handle_word(current_token);\n  } else if (current_token.type === TOKEN.RESERVED) {\n    this.handle_word(current_token);\n  } else if (current_token.type === TOKEN.SEMICOLON) {\n    this.handle_semicolon(current_token);\n  } else if (current_token.type === TOKEN.STRING) {\n    this.handle_string(current_token);\n  } else if (current_token.type === TOKEN.EQUALS) {\n    this.handle_equals(current_token);\n  } else if (current_token.type === TOKEN.OPERATOR) {\n    this.handle_operator(current_token);\n  } else if (current_token.type === TOKEN.COMMA) {\n    this.handle_comma(current_token);\n  } else if (current_token.type === TOKEN.BLOCK_COMMENT) {\n    this.handle_block_comment(current_token, preserve_statement_flags);\n  } else if (current_token.type === TOKEN.COMMENT) {\n    this.handle_comment(current_token, preserve_statement_flags);\n  } else if (current_token.type === TOKEN.DOT) {\n    this.handle_dot(current_token);\n  } else if (current_token.type === TOKEN.EOF) {\n    this.handle_eof(current_token);\n  } else if (current_token.type === TOKEN.UNKNOWN) {\n    this.handle_unknown(current_token, preserve_statement_flags);\n  } else {\n    this.handle_unknown(current_token, preserve_statement_flags);\n  }\n};\n\nBeautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {\n  var newlines = current_token.newlines;\n  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);\n\n  if (current_token.comments_before) {\n    var comment_token = current_token.comments_before.next();\n    while (comment_token) {\n      // The cleanest handling of inline comments is to treat them as though they aren't there.\n      // Just continue formatting and the behavior should be logical.\n      // Also ignore unknown tokens.  Again, this should result in better behavior.\n      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);\n      this.handle_token(comment_token, preserve_statement_flags);\n      comment_token = current_token.comments_before.next();\n    }\n  }\n\n  if (keep_whitespace) {\n    for (var i = 0; i < newlines; i += 1) {\n      this.print_newline(i > 0, preserve_statement_flags);\n    }\n  } else {\n    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {\n      newlines = this._options.max_preserve_newlines;\n    }\n\n    if (this._options.preserve_newlines) {\n      if (newlines > 1) {\n        this.print_newline(false, preserve_statement_flags);\n        for (var j = 1; j < newlines; j += 1) {\n          this.print_newline(true, preserve_statement_flags);\n        }\n      }\n    }\n  }\n\n};\n\nvar newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];\n\nBeautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {\n  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;\n\n  // Never wrap the first token on a line\n  if (this._output.just_added_newline()) {\n    return;\n  }\n\n  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;\n  var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) ||\n    in_array(current_token.text, positionable_operators);\n\n  if (operatorLogicApplies) {\n    var shouldPrintOperatorNewline = (\n        in_array(this._flags.last_token.text, positionable_operators) &&\n        in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)\n      ) ||\n      in_array(current_token.text, positionable_operators);\n    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;\n  }\n\n  if (shouldPreserveOrForce) {\n    this.print_newline(false, true);\n  } else if (this._options.wrap_line_length) {\n    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n      // These tokens should never have a newline inserted\n      // between them and the following expression.\n      return;\n    }\n    this._output.set_wrap_point();\n  }\n};\n\nBeautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {\n  if (!preserve_statement_flags) {\n    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {\n      var next_token = this._tokens.peek();\n      while (this._flags.mode === MODE.Statement &&\n        !(this._flags.if_block && reserved_word(next_token, 'else')) &&\n        !this._flags.do_block) {\n        this.restore_mode();\n      }\n    }\n  }\n\n  if (this._output.add_new_line(force_newline)) {\n    this._flags.multiline_frame = true;\n  }\n};\n\nBeautifier.prototype.print_token_line_indentation = function(current_token) {\n  if (this._output.just_added_newline()) {\n    if (this._options.keep_array_indentation &&\n      current_token.newlines &&\n      (current_token.text === '[' || is_array(this._flags.mode))) {\n      this._output.current_line.set_indent(-1);\n      this._output.current_line.push(current_token.whitespace_before);\n      this._output.space_before_token = false;\n    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {\n      this._flags.line_indent_level = this._flags.indentation_level;\n    }\n  }\n};\n\nBeautifier.prototype.print_token = function(current_token) {\n  if (this._output.raw) {\n    this._output.add_raw_token(current_token);\n    return;\n  }\n\n  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA &&\n    this._output.just_added_newline()) {\n    if (this._output.previous_line.last() === ',') {\n      var popped = this._output.previous_line.pop();\n      // if the comma was already at the start of the line,\n      // pull back onto that line and reprint the indentation\n      if (this._output.previous_line.is_empty()) {\n        this._output.previous_line.push(popped);\n        this._output.trim(true);\n        this._output.current_line.pop();\n        this._output.trim();\n      }\n\n      // add the comma in front of the next token\n      this.print_token_line_indentation(current_token);\n      this._output.add_token(',');\n      this._output.space_before_token = true;\n    }\n  }\n\n  this.print_token_line_indentation(current_token);\n  this._output.non_breaking_space = true;\n  this._output.add_token(current_token.text);\n  if (this._output.previous_token_wrapped) {\n    this._flags.multiline_frame = true;\n  }\n};\n\nBeautifier.prototype.indent = function() {\n  this._flags.indentation_level += 1;\n  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n};\n\nBeautifier.prototype.deindent = function() {\n  if (this._flags.indentation_level > 0 &&\n    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {\n    this._flags.indentation_level -= 1;\n    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n  }\n};\n\nBeautifier.prototype.set_mode = function(mode) {\n  if (this._flags) {\n    this._flag_store.push(this._flags);\n    this._previous_flags = this._flags;\n  } else {\n    this._previous_flags = this.create_flags(null, mode);\n  }\n\n  this._flags = this.create_flags(this._previous_flags, mode);\n  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n};\n\n\nBeautifier.prototype.restore_mode = function() {\n  if (this._flag_store.length > 0) {\n    this._previous_flags = this._flags;\n    this._flags = this._flag_store.pop();\n    if (this._previous_flags.mode === MODE.Statement) {\n      remove_redundant_indentation(this._output, this._previous_flags);\n    }\n    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n  }\n};\n\nBeautifier.prototype.start_of_object_property = function() {\n  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (\n    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));\n};\n\nBeautifier.prototype.start_of_statement = function(current_token) {\n  var start = false;\n  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD;\n  start = start || reserved_word(this._flags.last_token, 'do');\n  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;\n  start = start || reserved_word(this._flags.last_token, 'else') &&\n    !(reserved_word(current_token, 'if') && !current_token.comments_before);\n  start = start || (this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));\n  start = start || (this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement &&\n    !this._flags.in_case &&\n    !(current_token.text === '--' || current_token.text === '++') &&\n    this._last_last_text !== 'function' &&\n    current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED);\n  start = start || (this._flags.mode === MODE.ObjectLiteral && (\n    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));\n\n  if (start) {\n    this.set_mode(MODE.Statement);\n    this.indent();\n\n    this.handle_whitespace_and_comments(current_token, true);\n\n    // Issue #276:\n    // If starting a new statement with [if, for, while, do], push to a new line.\n    // if (a) if (b) if(c) d(); else e(); else f();\n    if (!this.start_of_object_property()) {\n      this.allow_wrap_or_preserved_newline(current_token,\n        reserved_array(current_token, ['do', 'for', 'if', 'while']));\n    }\n    return true;\n  }\n  return false;\n};\n\nBeautifier.prototype.handle_start_expr = function(current_token) {\n  // The conditional starts the statement if appropriate.\n  if (!this.start_of_statement(current_token)) {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  var next_mode = MODE.Expression;\n  if (current_token.text === '[') {\n\n    if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ')') {\n      // this is array index specifier, break immediately\n      // a[x], fn()[x]\n      if (reserved_array(this._flags.last_token, line_starters)) {\n        this._output.space_before_token = true;\n      }\n      this.print_token(current_token);\n      this.set_mode(next_mode);\n      this.indent();\n      if (this._options.space_in_paren) {\n        this._output.space_before_token = true;\n      }\n      return;\n    }\n\n    next_mode = MODE.ArrayLiteral;\n    if (is_array(this._flags.mode)) {\n      if (this._flags.last_token.text === '[' ||\n        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {\n        // ], [ goes to new line\n        // }, [ goes to new line\n        if (!this._options.keep_array_indentation) {\n          this.print_newline();\n        }\n      }\n    }\n\n    if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR])) {\n      this._output.space_before_token = true;\n    }\n  } else {\n    if (this._flags.last_token.type === TOKEN.RESERVED) {\n      if (this._flags.last_token.text === 'for') {\n        this._output.space_before_token = this._options.space_before_conditional;\n        next_mode = MODE.ForInitializer;\n      } else if (in_array(this._flags.last_token.text, ['if', 'while'])) {\n        this._output.space_before_token = this._options.space_before_conditional;\n        next_mode = MODE.Conditional;\n      } else if (in_array(this._flags.last_word, ['await', 'async'])) {\n        // Should be a space between await and an IIFE, or async and an arrow function\n        this._output.space_before_token = true;\n      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {\n        this._output.space_before_token = false;\n      } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {\n        this._output.space_before_token = true;\n      }\n    } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n      // Support of this kind of newline preservation.\n      // a = (b &&\n      //     (c || d));\n      if (!this.start_of_object_property()) {\n        this.allow_wrap_or_preserved_newline(current_token);\n      }\n    } else if (this._flags.last_token.type === TOKEN.WORD) {\n      this._output.space_before_token = false;\n\n      // function name() vs function name ()\n      // function* name() vs function* name ()\n      // async name() vs async name ()\n      // In ES6, you can also define the method properties of an object\n      // var obj = {a: function() {}}\n      // It can be abbreviated\n      // var obj = {a() {}}\n      // var obj = { a() {}} vs var obj = { a () {}}\n      // var obj = { * a() {}} vs var obj = { * a () {}}\n      var peek_back_two = this._tokens.peek(-3);\n      if (this._options.space_after_named_function && peek_back_two) {\n        // peek starts at next character so -1 is current token\n        var peek_back_three = this._tokens.peek(-4);\n        if (reserved_array(peek_back_two, ['async', 'function']) ||\n          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {\n          this._output.space_before_token = true;\n        } else if (this._flags.mode === MODE.ObjectLiteral) {\n          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||\n            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {\n            this._output.space_before_token = true;\n          }\n        }\n      }\n    } else {\n      // Support preserving wrapped arrow function expressions\n      // a.b('c',\n      //     () => d.e\n      // )\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n\n    // function() vs function ()\n    // yield*() vs yield* ()\n    // function*() vs function* ()\n    if ((this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||\n      (this._flags.last_token.text === '*' &&\n        (in_array(this._last_last_text, ['function', 'yield']) ||\n          (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {\n      this._output.space_before_token = this._options.space_after_anon_function;\n    }\n  }\n\n  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN.START_BLOCK) {\n    this.print_newline();\n  } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN.COMMA) {\n    // do nothing on (( and )( and ][ and ]( and .(\n    // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);\n  }\n\n  this.print_token(current_token);\n  this.set_mode(next_mode);\n  if (this._options.space_in_paren) {\n    this._output.space_before_token = true;\n  }\n\n  // In all cases, if we newline while inside an expression it should be indented.\n  this.indent();\n};\n\nBeautifier.prototype.handle_end_expr = function(current_token) {\n  // statements inside expressions are not valid syntax, but...\n  // statements must all be closed when their container closes\n  while (this._flags.mode === MODE.Statement) {\n    this.restore_mode();\n  }\n\n  this.handle_whitespace_and_comments(current_token);\n\n  if (this._flags.multiline_frame) {\n    this.allow_wrap_or_preserved_newline(current_token,\n      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);\n  }\n\n  if (this._options.space_in_paren) {\n    if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {\n      // () [] no inner space in empty parens like these, ever, ref #320\n      this._output.trim();\n      this._output.space_before_token = false;\n    } else {\n      this._output.space_before_token = true;\n    }\n  }\n  this.deindent();\n  this.print_token(current_token);\n  this.restore_mode();\n\n  remove_redundant_indentation(this._output, this._previous_flags);\n\n  // do {} while () // no statement required after\n  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {\n    this._previous_flags.mode = MODE.Expression;\n    this._flags.do_block = false;\n    this._flags.do_while = false;\n\n  }\n};\n\nBeautifier.prototype.handle_start_block = function(current_token) {\n  this.handle_whitespace_and_comments(current_token);\n\n  // Check if this is should be treated as a ObjectLiteral\n  var next_token = this._tokens.peek();\n  var second_token = this._tokens.peek(1);\n  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN.END_EXPR) {\n    this.set_mode(MODE.BlockStatement);\n    this._flags.in_case_statement = true;\n  } else if (this._flags.case_body) {\n    this.set_mode(MODE.BlockStatement);\n  } else if (second_token && (\n      (in_array(second_token.text, [':', ',']) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED])) ||\n      (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))\n    )) {\n    // We don't support TypeScript,but we didn't break it for a very long time.\n    // We'll try to keep not breaking it.\n    if (!in_array(this._last_last_text, ['class', 'interface'])) {\n      this.set_mode(MODE.ObjectLiteral);\n    } else {\n      this.set_mode(MODE.BlockStatement);\n    }\n  } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === '=>') {\n    // arrow function: (param1, paramN) => { statements }\n    this.set_mode(MODE.BlockStatement);\n  } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) ||\n    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])\n  ) {\n    // Detecting shorthand function syntax is difficult by scanning forward,\n    //     so check the surrounding context.\n    // If the block is being returned, imported, export default, passed as arg,\n    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\n    this.set_mode(MODE.ObjectLiteral);\n  } else {\n    this.set_mode(MODE.BlockStatement);\n  }\n\n  var empty_braces = !next_token.comments_before && next_token.text === '}';\n  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&\n    this._flags.last_token.type === TOKEN.END_EXPR;\n\n  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so\n  {\n    // search forward for a newline wanted inside this block\n    var index = 0;\n    var check_token = null;\n    this._flags.inline_frame = true;\n    do {\n      index += 1;\n      check_token = this._tokens.peek(index - 1);\n      if (check_token.newlines) {\n        this._flags.inline_frame = false;\n        break;\n      }\n    } while (check_token.type !== TOKEN.EOF &&\n      !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));\n  }\n\n  if ((this._options.brace_style === \"expand\" ||\n      (this._options.brace_style === \"none\" && current_token.newlines)) &&\n    !this._flags.inline_frame) {\n    if (this._flags.last_token.type !== TOKEN.OPERATOR &&\n      (empty_anonymous_function ||\n        this._flags.last_token.type === TOKEN.EQUALS ||\n        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {\n      this._output.space_before_token = true;\n    } else {\n      this.print_newline(false, true);\n    }\n  } else { // collapse || inline_frame\n    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {\n      if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {\n        this._output.space_before_token = true;\n      }\n\n      if (this._flags.last_token.type === TOKEN.COMMA || (this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame)) {\n        this.allow_wrap_or_preserved_newline(current_token);\n        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;\n        this._flags.multiline_frame = false;\n      }\n    }\n    if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {\n      if (this._flags.last_token.type === TOKEN.START_BLOCK && !this._flags.inline_frame) {\n        this.print_newline();\n      } else {\n        this._output.space_before_token = true;\n      }\n    }\n  }\n  this.print_token(current_token);\n  this.indent();\n\n  // Except for specific cases, open braces are followed by a new line.\n  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {\n    this.print_newline();\n  }\n};\n\nBeautifier.prototype.handle_end_block = function(current_token) {\n  // statements must all be closed when their container closes\n  this.handle_whitespace_and_comments(current_token);\n\n  while (this._flags.mode === MODE.Statement) {\n    this.restore_mode();\n  }\n\n  var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;\n\n  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first\n    this._output.space_before_token = true;\n  } else if (this._options.brace_style === \"expand\") {\n    if (!empty_braces) {\n      this.print_newline();\n    }\n  } else {\n    // skip {}\n    if (!empty_braces) {\n      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {\n        // we REALLY need a newline here, but newliner would skip that\n        this._options.keep_array_indentation = false;\n        this.print_newline();\n        this._options.keep_array_indentation = true;\n\n      } else {\n        this.print_newline();\n      }\n    }\n  }\n  this.restore_mode();\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_word = function(current_token) {\n  if (current_token.type === TOKEN.RESERVED) {\n    if (in_array(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {\n      current_token.type = TOKEN.WORD;\n    } else if (current_token.text === 'import' && this._tokens.peek().text === '(') {\n      current_token.type = TOKEN.WORD;\n    } else if (in_array(current_token.text, ['as', 'from']) && !this._flags.import_block) {\n      current_token.type = TOKEN.WORD;\n    } else if (this._flags.mode === MODE.ObjectLiteral) {\n      var next_token = this._tokens.peek();\n      if (next_token.text === ':') {\n        current_token.type = TOKEN.WORD;\n      }\n    }\n  }\n\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD) {\n      this._flags.declaration_statement = true;\n    }\n  } else if (current_token.newlines && !is_expression(this._flags.mode) &&\n    (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&\n    this._flags.last_token.type !== TOKEN.EQUALS &&\n    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {\n    this.handle_whitespace_and_comments(current_token);\n    this.print_newline();\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  if (this._flags.do_block && !this._flags.do_while) {\n    if (reserved_word(current_token, 'while')) {\n      // do {} ## while ()\n      this._output.space_before_token = true;\n      this.print_token(current_token);\n      this._output.space_before_token = true;\n      this._flags.do_while = true;\n      return;\n    } else {\n      // do {} should always have while as the next word.\n      // if we don't see the expected while, recover\n      this.print_newline();\n      this._flags.do_block = false;\n    }\n  }\n\n  // if may be followed by else, or not\n  // Bare/inline ifs are tricky\n  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n  if (this._flags.if_block) {\n    if (!this._flags.else_block && reserved_word(current_token, 'else')) {\n      this._flags.else_block = true;\n    } else {\n      while (this._flags.mode === MODE.Statement) {\n        this.restore_mode();\n      }\n      this._flags.if_block = false;\n      this._flags.else_block = false;\n    }\n  }\n\n  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {\n    this.print_newline();\n    if (this._flags.last_token.type !== TOKEN.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {\n      // switch cases following one another\n      this.deindent();\n    }\n    this._flags.case_body = false;\n\n    this.print_token(current_token);\n    this._flags.in_case = true;\n    return;\n  }\n\n  if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n    if (!this.start_of_object_property()) {\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n  }\n\n  if (reserved_word(current_token, 'function')) {\n    if (in_array(this._flags.last_token.text, ['}', ';']) ||\n      (this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN.OPERATOR))) {\n      // make sure there is a nice clean space of at least one blank line\n      // before a new function definition\n      if (!this._output.just_added_blankline() && !current_token.comments_before) {\n        this.print_newline();\n        this.print_newline(true);\n      }\n    }\n    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {\n      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||\n        reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n        this._output.space_before_token = true;\n      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {\n        this._output.space_before_token = true;\n      } else if (this._flags.last_token.text === 'declare') {\n        // accomodates Typescript declare function formatting\n        this._output.space_before_token = true;\n      } else {\n        this.print_newline();\n      }\n    } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === '=') {\n      // foo = function\n      this._output.space_before_token = true;\n    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {\n      // (function\n    } else {\n      this.print_newline();\n    }\n\n    this.print_token(current_token);\n    this._flags.last_word = current_token.text;\n    return;\n  }\n\n  var prefix = 'NONE';\n\n  if (this._flags.last_token.type === TOKEN.END_BLOCK) {\n\n    if (this._previous_flags.inline_frame) {\n      prefix = 'SPACE';\n    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {\n      prefix = 'NEWLINE';\n    } else {\n      if (this._options.brace_style === \"expand\" ||\n        this._options.brace_style === \"end-expand\" ||\n        (this._options.brace_style === \"none\" && current_token.newlines)) {\n        prefix = 'NEWLINE';\n      } else {\n        prefix = 'SPACE';\n        this._output.space_before_token = true;\n      }\n    }\n  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {\n    // TODO: Should this be for STATEMENT as well?\n    prefix = 'NEWLINE';\n  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {\n    prefix = 'SPACE';\n  } else if (this._flags.last_token.type === TOKEN.STRING) {\n    prefix = 'NEWLINE';\n  } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD ||\n    (this._flags.last_token.text === '*' &&\n      (in_array(this._last_last_text, ['function', 'yield']) ||\n        (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {\n    prefix = 'SPACE';\n  } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {\n    if (this._flags.inline_frame) {\n      prefix = 'SPACE';\n    } else {\n      prefix = 'NEWLINE';\n    }\n  } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n    this._output.space_before_token = true;\n    prefix = 'NEWLINE';\n  }\n\n  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {\n    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {\n      prefix = 'SPACE';\n    } else {\n      prefix = 'NEWLINE';\n    }\n\n  }\n\n  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {\n    if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||\n        this._options.brace_style === \"expand\" ||\n        this._options.brace_style === \"end-expand\" ||\n        (this._options.brace_style === \"none\" && current_token.newlines)) &&\n      !this._flags.inline_frame) {\n      this.print_newline();\n    } else {\n      this._output.trim(true);\n      var line = this._output.current_line;\n      // If we trimmed and there's something other than a close block before us\n      // put a newline back in.  Handles '} // comment' scenario.\n      if (line.last() !== '}') {\n        this.print_newline();\n      }\n      this._output.space_before_token = true;\n    }\n  } else if (prefix === 'NEWLINE') {\n    if (reserved_array(this._flags.last_token, special_words)) {\n      // no newline between 'return nnn'\n      this._output.space_before_token = true;\n    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {\n      // accomodates Typescript declare formatting\n      this._output.space_before_token = true;\n    } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {\n      if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {\n        // no need to force newline on 'var': for (var x = 0...)\n        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {\n          // no newline for } else if {\n          this._output.space_before_token = true;\n        } else {\n          this.print_newline();\n        }\n      }\n    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {\n      this.print_newline();\n    }\n  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {\n    this.print_newline(); // }, in lists get a newline treatment\n  } else if (prefix === 'SPACE') {\n    this._output.space_before_token = true;\n  }\n  if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {\n    this._output.space_before_token = true;\n  }\n  this.print_token(current_token);\n  this._flags.last_word = current_token.text;\n\n  if (current_token.type === TOKEN.RESERVED) {\n    if (current_token.text === 'do') {\n      this._flags.do_block = true;\n    } else if (current_token.text === 'if') {\n      this._flags.if_block = true;\n    } else if (current_token.text === 'import') {\n      this._flags.import_block = true;\n    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {\n      this._flags.import_block = false;\n    }\n  }\n};\n\nBeautifier.prototype.handle_semicolon = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n    // Semicolon can be the start (and end) of a statement\n    this._output.space_before_token = false;\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  var next_token = this._tokens.peek();\n  while (this._flags.mode === MODE.Statement &&\n    !(this._flags.if_block && reserved_word(next_token, 'else')) &&\n    !this._flags.do_block) {\n    this.restore_mode();\n  }\n\n  // hacky but effective for the moment\n  if (this._flags.import_block) {\n    this._flags.import_block = false;\n  }\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_string = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n    // One difference - strings want at least a space before\n    this._output.space_before_token = true;\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {\n      this._output.space_before_token = true;\n    } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n      if (!this.start_of_object_property()) {\n        this.allow_wrap_or_preserved_newline(current_token);\n      }\n    } else {\n      this.print_newline();\n    }\n  }\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_equals = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  if (this._flags.declaration_statement) {\n    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n    this._flags.declaration_assignment = true;\n  }\n  this._output.space_before_token = true;\n  this.print_token(current_token);\n  this._output.space_before_token = true;\n};\n\nBeautifier.prototype.handle_comma = function(current_token) {\n  this.handle_whitespace_and_comments(current_token, true);\n\n  this.print_token(current_token);\n  this._output.space_before_token = true;\n  if (this._flags.declaration_statement) {\n    if (is_expression(this._flags.parent.mode)) {\n      // do not break on comma, for(var a = 1, b = 2)\n      this._flags.declaration_assignment = false;\n    }\n\n    if (this._flags.declaration_assignment) {\n      this._flags.declaration_assignment = false;\n      this.print_newline(false, true);\n    } else if (this._options.comma_first) {\n      // for comma-first, we want to allow a newline before the comma\n      // to turn into a newline after the comma, which we will fixup later\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n  } else if (this._flags.mode === MODE.ObjectLiteral ||\n    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {\n    if (this._flags.mode === MODE.Statement) {\n      this.restore_mode();\n    }\n\n    if (!this._flags.inline_frame) {\n      this.print_newline();\n    }\n  } else if (this._options.comma_first) {\n    // EXPR or DO_BLOCK\n    // for comma-first, we want to allow a newline before the comma\n    // to turn into a newline after the comma, which we will fixup later\n    this.allow_wrap_or_preserved_newline(current_token);\n  }\n};\n\nBeautifier.prototype.handle_operator = function(current_token) {\n  var isGeneratorAsterisk = current_token.text === '*' &&\n    (reserved_array(this._flags.last_token, ['function', 'yield']) ||\n      (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]))\n    );\n  var isUnary = in_array(current_token.text, ['-', '+']) && (\n    in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) ||\n    in_array(this._flags.last_token.text, line_starters) ||\n    this._flags.last_token.text === ','\n  );\n\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n  } else {\n    var preserve_statement_flags = !isGeneratorAsterisk;\n    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);\n  }\n\n  if (reserved_array(this._flags.last_token, special_words)) {\n    // \"return\" had a special handling in TK_WORD. Now we need to return the favor\n    this._output.space_before_token = true;\n    this.print_token(current_token);\n    return;\n  }\n\n  // hack for actionscript's import .*;\n  if (current_token.text === '*' && this._flags.last_token.type === TOKEN.DOT) {\n    this.print_token(current_token);\n    return;\n  }\n\n  if (current_token.text === '::') {\n    // no spaces around exotic namespacing syntax operator\n    this.print_token(current_token);\n    return;\n  }\n\n  // Allow line wrapping between operators when operator_position is\n  //   set to before or preserve\n  if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {\n    this.allow_wrap_or_preserved_newline(current_token);\n  }\n\n  if (current_token.text === ':' && this._flags.in_case) {\n    this.print_token(current_token);\n\n    this._flags.in_case = false;\n    this._flags.case_body = true;\n    if (this._tokens.peek().type !== TOKEN.START_BLOCK) {\n      this.indent();\n      this.print_newline();\n    } else {\n      this._output.space_before_token = true;\n    }\n    return;\n  }\n\n  var space_before = true;\n  var space_after = true;\n  var in_ternary = false;\n  if (current_token.text === ':') {\n    if (this._flags.ternary_depth === 0) {\n      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n      space_before = false;\n    } else {\n      this._flags.ternary_depth -= 1;\n      in_ternary = true;\n    }\n  } else if (current_token.text === '?') {\n    this._flags.ternary_depth += 1;\n  }\n\n  // let's handle the operator_position option prior to any conflicting logic\n  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {\n    var isColon = current_token.text === ':';\n    var isTernaryColon = (isColon && in_ternary);\n    var isOtherColon = (isColon && !in_ternary);\n\n    switch (this._options.operator_position) {\n      case OPERATOR_POSITION.before_newline:\n        // if the current token is : and it's not a ternary statement then we set space_before to false\n        this._output.space_before_token = !isOtherColon;\n\n        this.print_token(current_token);\n\n        if (!isColon || isTernaryColon) {\n          this.allow_wrap_or_preserved_newline(current_token);\n        }\n\n        this._output.space_before_token = true;\n        return;\n\n      case OPERATOR_POSITION.after_newline:\n        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,\n        //   then print a newline.\n\n        this._output.space_before_token = true;\n\n        if (!isColon || isTernaryColon) {\n          if (this._tokens.peek().newlines) {\n            this.print_newline(false, true);\n          } else {\n            this.allow_wrap_or_preserved_newline(current_token);\n          }\n        } else {\n          this._output.space_before_token = false;\n        }\n\n        this.print_token(current_token);\n\n        this._output.space_before_token = true;\n        return;\n\n      case OPERATOR_POSITION.preserve_newline:\n        if (!isOtherColon) {\n          this.allow_wrap_or_preserved_newline(current_token);\n        }\n\n        // if we just added a newline, or the current token is : and it's not a ternary statement,\n        //   then we set space_before to false\n        space_before = !(this._output.just_added_newline() || isOtherColon);\n\n        this._output.space_before_token = space_before;\n        this.print_token(current_token);\n        this._output.space_before_token = true;\n        return;\n    }\n  }\n\n  if (isGeneratorAsterisk) {\n    this.allow_wrap_or_preserved_newline(current_token);\n    space_before = false;\n    var next_token = this._tokens.peek();\n    space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);\n  } else if (current_token.text === '...') {\n    this.allow_wrap_or_preserved_newline(current_token);\n    space_before = this._flags.last_token.type === TOKEN.START_BLOCK;\n    space_after = false;\n  } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {\n    // unary operators (and binary +/- pretending to be unary) special cases\n    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n\n    space_before = false;\n    space_after = false;\n\n    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n    // if there is a newline between -- or ++ and anything else we should preserve it.\n    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++')) {\n      this.print_newline(false, true);\n    }\n\n    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {\n      // for (;; ++i)\n      //        ^^^\n      space_before = true;\n    }\n\n    if (this._flags.last_token.type === TOKEN.RESERVED) {\n      space_before = true;\n    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));\n    } else if (this._flags.last_token.type === TOKEN.OPERATOR) {\n      // a++ + ++b;\n      // a - -b\n      space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(this._flags.last_token.text, ['--', '-', '++', '+']);\n      // + and - are not unary when preceeded by -- or ++ operator\n      // a-- + b\n      // a * +b\n      // a - -b\n      if (in_array(current_token.text, ['+', '-']) && in_array(this._flags.last_token.text, ['--', '++'])) {\n        space_after = true;\n      }\n    }\n\n\n    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&\n      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {\n      // { foo; --i }\n      // foo(); --bar;\n      this.print_newline();\n    }\n  }\n\n  this._output.space_before_token = this._output.space_before_token || space_before;\n  this.print_token(current_token);\n  this._output.space_before_token = space_after;\n};\n\nBeautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {\n  if (this._output.raw) {\n    this._output.add_raw_token(current_token);\n    if (current_token.directives && current_token.directives.preserve === 'end') {\n      // If we're testing the raw output behavior, do not allow a directive to turn it off.\n      this._output.raw = this._options.test_output_raw;\n    }\n    return;\n  }\n\n  if (current_token.directives) {\n    this.print_newline(false, preserve_statement_flags);\n    this.print_token(current_token);\n    if (current_token.directives.preserve === 'start') {\n      this._output.raw = true;\n    }\n    this.print_newline(false, true);\n    return;\n  }\n\n  // inline block\n  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {\n    this._output.space_before_token = true;\n    this.print_token(current_token);\n    this._output.space_before_token = true;\n    return;\n  } else {\n    this.print_block_commment(current_token, preserve_statement_flags);\n  }\n};\n\nBeautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {\n  var lines = split_linebreaks(current_token.text);\n  var j; // iterator for this case\n  var javadoc = false;\n  var starless = false;\n  var lastIndent = current_token.whitespace_before;\n  var lastIndentLength = lastIndent.length;\n\n  // block comment starts with a new line\n  this.print_newline(false, preserve_statement_flags);\n\n  // first line always indented\n  this.print_token_line_indentation(current_token);\n  this._output.add_token(lines[0]);\n  this.print_newline(false, preserve_statement_flags);\n\n\n  if (lines.length > 1) {\n    lines = lines.slice(1);\n    javadoc = all_lines_start_with(lines, '*');\n    starless = each_line_matches_indent(lines, lastIndent);\n\n    if (javadoc) {\n      this._flags.alignment = 1;\n    }\n\n    for (j = 0; j < lines.length; j++) {\n      if (javadoc) {\n        // javadoc: reformat and re-indent\n        this.print_token_line_indentation(current_token);\n        this._output.add_token(ltrim(lines[j]));\n      } else if (starless && lines[j]) {\n        // starless: re-indent non-empty content, avoiding trim\n        this.print_token_line_indentation(current_token);\n        this._output.add_token(lines[j].substring(lastIndentLength));\n      } else {\n        // normal comments output raw\n        this._output.current_line.set_indent(-1);\n        this._output.add_token(lines[j]);\n      }\n\n      // for comments on their own line or  more than one line, make sure there's a new line after\n      this.print_newline(false, preserve_statement_flags);\n    }\n\n    this._flags.alignment = 0;\n  }\n};\n\n\nBeautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {\n  if (current_token.newlines) {\n    this.print_newline(false, preserve_statement_flags);\n  } else {\n    this._output.trim(true);\n  }\n\n  this._output.space_before_token = true;\n  this.print_token(current_token);\n  this.print_newline(false, preserve_statement_flags);\n};\n\nBeautifier.prototype.handle_dot = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n  } else {\n    this.handle_whitespace_and_comments(current_token, true);\n  }\n\n  if (reserved_array(this._flags.last_token, special_words)) {\n    this._output.space_before_token = false;\n  } else {\n    // allow preserved newlines before dots in general\n    // force newlines on dots after close paren when break_chained - for bar().baz()\n    this.allow_wrap_or_preserved_newline(current_token,\n      this._flags.last_token.text === ')' && this._options.break_chained_methods);\n  }\n\n  // Only unindent chained method dot if this dot starts a new line.\n  // Otherwise the automatic extra indentation removal will handle the over indent\n  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {\n    this.deindent();\n  }\n\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {\n  this.print_token(current_token);\n\n  if (current_token.text[current_token.text.length - 1] === '\\n') {\n    this.print_newline(false, preserve_statement_flags);\n  }\n};\n\nBeautifier.prototype.handle_eof = function(current_token) {\n  // Unwind any open statements\n  while (this._flags.mode === MODE.Statement) {\n    this.restore_mode();\n  }\n  this.handle_whitespace_and_comments(current_token);\n};\n\nmodule.exports.Beautifier = Beautifier;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction OutputLine(parent) {\n  this.__parent = parent;\n  this.__character_count = 0;\n  // use indent_count as a marker for this.__lines that have preserved indentation\n  this.__indent_count = -1;\n  this.__alignment_count = 0;\n  this.__wrap_point_index = 0;\n  this.__wrap_point_character_count = 0;\n  this.__wrap_point_indent_count = -1;\n  this.__wrap_point_alignment_count = 0;\n\n  this.__items = [];\n}\n\nOutputLine.prototype.clone_empty = function() {\n  var line = new OutputLine(this.__parent);\n  line.set_indent(this.__indent_count, this.__alignment_count);\n  return line;\n};\n\nOutputLine.prototype.item = function(index) {\n  if (index < 0) {\n    return this.__items[this.__items.length + index];\n  } else {\n    return this.__items[index];\n  }\n};\n\nOutputLine.prototype.has_match = function(pattern) {\n  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n    if (this.__items[lastCheckedOutput].match(pattern)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nOutputLine.prototype.set_indent = function(indent, alignment) {\n  if (this.is_empty()) {\n    this.__indent_count = indent || 0;\n    this.__alignment_count = alignment || 0;\n    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n  }\n};\n\nOutputLine.prototype._set_wrap_point = function() {\n  if (this.__parent.wrap_line_length) {\n    this.__wrap_point_index = this.__items.length;\n    this.__wrap_point_character_count = this.__character_count;\n    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n  }\n};\n\nOutputLine.prototype._should_wrap = function() {\n  return this.__wrap_point_index &&\n    this.__character_count > this.__parent.wrap_line_length &&\n    this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n};\n\nOutputLine.prototype._allow_wrap = function() {\n  if (this._should_wrap()) {\n    this.__parent.add_new_line();\n    var next = this.__parent.current_line;\n    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n    next.__items = this.__items.slice(this.__wrap_point_index);\n    this.__items = this.__items.slice(0, this.__wrap_point_index);\n\n    next.__character_count += this.__character_count - this.__wrap_point_character_count;\n    this.__character_count = this.__wrap_point_character_count;\n\n    if (next.__items[0] === \" \") {\n      next.__items.splice(0, 1);\n      next.__character_count -= 1;\n    }\n    return true;\n  }\n  return false;\n};\n\nOutputLine.prototype.is_empty = function() {\n  return this.__items.length === 0;\n};\n\nOutputLine.prototype.last = function() {\n  if (!this.is_empty()) {\n    return this.__items[this.__items.length - 1];\n  } else {\n    return null;\n  }\n};\n\nOutputLine.prototype.push = function(item) {\n  this.__items.push(item);\n  var last_newline_index = item.lastIndexOf('\\n');\n  if (last_newline_index !== -1) {\n    this.__character_count = item.length - last_newline_index;\n  } else {\n    this.__character_count += item.length;\n  }\n};\n\nOutputLine.prototype.pop = function() {\n  var item = null;\n  if (!this.is_empty()) {\n    item = this.__items.pop();\n    this.__character_count -= item.length;\n  }\n  return item;\n};\n\n\nOutputLine.prototype._remove_indent = function() {\n  if (this.__indent_count > 0) {\n    this.__indent_count -= 1;\n    this.__character_count -= this.__parent.indent_size;\n  }\n};\n\nOutputLine.prototype._remove_wrap_indent = function() {\n  if (this.__wrap_point_indent_count > 0) {\n    this.__wrap_point_indent_count -= 1;\n  }\n};\nOutputLine.prototype.trim = function() {\n  while (this.last() === ' ') {\n    this.__items.pop();\n    this.__character_count -= 1;\n  }\n};\n\nOutputLine.prototype.toString = function() {\n  var result = '';\n  if (this.is_empty()) {\n    if (this.__parent.indent_empty_lines) {\n      result = this.__parent.get_indent_string(this.__indent_count);\n    }\n  } else {\n    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n    result += this.__items.join('');\n  }\n  return result;\n};\n\nfunction IndentStringCache(options, baseIndentString) {\n  this.__cache = [''];\n  this.__indent_size = options.indent_size;\n  this.__indent_string = options.indent_char;\n  if (!options.indent_with_tabs) {\n    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n  }\n\n  // Set to null to continue support for auto detection of base indent\n  baseIndentString = baseIndentString || '';\n  if (options.indent_level > 0) {\n    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n  }\n\n  this.__base_string = baseIndentString;\n  this.__base_string_length = baseIndentString.length;\n}\n\nIndentStringCache.prototype.get_indent_size = function(indent, column) {\n  var result = this.__base_string_length;\n  column = column || 0;\n  if (indent < 0) {\n    result = 0;\n  }\n  result += indent * this.__indent_size;\n  result += column;\n  return result;\n};\n\nIndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n  var result = this.__base_string;\n  column = column || 0;\n  if (indent_level < 0) {\n    indent_level = 0;\n    result = '';\n  }\n  column += indent_level * this.__indent_size;\n  this.__ensure_cache(column);\n  result += this.__cache[column];\n  return result;\n};\n\nIndentStringCache.prototype.__ensure_cache = function(column) {\n  while (column >= this.__cache.length) {\n    this.__add_column();\n  }\n};\n\nIndentStringCache.prototype.__add_column = function() {\n  var column = this.__cache.length;\n  var indent = 0;\n  var result = '';\n  if (this.__indent_size && column >= this.__indent_size) {\n    indent = Math.floor(column / this.__indent_size);\n    column -= indent * this.__indent_size;\n    result = new Array(indent + 1).join(this.__indent_string);\n  }\n  if (column) {\n    result += new Array(column + 1).join(' ');\n  }\n\n  this.__cache.push(result);\n};\n\nfunction Output(options, baseIndentString) {\n  this.__indent_cache = new IndentStringCache(options, baseIndentString);\n  this.raw = false;\n  this._end_with_newline = options.end_with_newline;\n  this.indent_size = options.indent_size;\n  this.wrap_line_length = options.wrap_line_length;\n  this.indent_empty_lines = options.indent_empty_lines;\n  this.__lines = [];\n  this.previous_line = null;\n  this.current_line = null;\n  this.next_line = new OutputLine(this);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n  // initialize\n  this.__add_outputline();\n}\n\nOutput.prototype.__add_outputline = function() {\n  this.previous_line = this.current_line;\n  this.current_line = this.next_line.clone_empty();\n  this.__lines.push(this.current_line);\n};\n\nOutput.prototype.get_line_number = function() {\n  return this.__lines.length;\n};\n\nOutput.prototype.get_indent_string = function(indent, column) {\n  return this.__indent_cache.get_indent_string(indent, column);\n};\n\nOutput.prototype.get_indent_size = function(indent, column) {\n  return this.__indent_cache.get_indent_size(indent, column);\n};\n\nOutput.prototype.is_empty = function() {\n  return !this.previous_line && this.current_line.is_empty();\n};\n\nOutput.prototype.add_new_line = function(force_newline) {\n  // never newline at the start of file\n  // otherwise, newline only if we didn't just add one or we're forced\n  if (this.is_empty() ||\n    (!force_newline && this.just_added_newline())) {\n    return false;\n  }\n\n  // if raw output is enabled, don't print additional newlines,\n  // but still return True as though you had\n  if (!this.raw) {\n    this.__add_outputline();\n  }\n  return true;\n};\n\nOutput.prototype.get_code = function(eol) {\n  this.trim(true);\n\n  // handle some edge cases where the last tokens\n  // has text that ends with newline(s)\n  var last_item = this.current_line.pop();\n  if (last_item) {\n    if (last_item[last_item.length - 1] === '\\n') {\n      last_item = last_item.replace(/\\n+$/g, '');\n    }\n    this.current_line.push(last_item);\n  }\n\n  if (this._end_with_newline) {\n    this.__add_outputline();\n  }\n\n  var sweet_code = this.__lines.join('\\n');\n\n  if (eol !== '\\n') {\n    sweet_code = sweet_code.replace(/[\\n]/g, eol);\n  }\n  return sweet_code;\n};\n\nOutput.prototype.set_wrap_point = function() {\n  this.current_line._set_wrap_point();\n};\n\nOutput.prototype.set_indent = function(indent, alignment) {\n  indent = indent || 0;\n  alignment = alignment || 0;\n\n  // Next line stores alignment values\n  this.next_line.set_indent(indent, alignment);\n\n  // Never indent your first output indent at the start of the file\n  if (this.__lines.length > 1) {\n    this.current_line.set_indent(indent, alignment);\n    return true;\n  }\n\n  this.current_line.set_indent();\n  return false;\n};\n\nOutput.prototype.add_raw_token = function(token) {\n  for (var x = 0; x < token.newlines; x++) {\n    this.__add_outputline();\n  }\n  this.current_line.set_indent(-1);\n  this.current_line.push(token.whitespace_before);\n  this.current_line.push(token.text);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n};\n\nOutput.prototype.add_token = function(printable_token) {\n  this.__add_space_before_token();\n  this.current_line.push(printable_token);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = this.current_line._allow_wrap();\n};\n\nOutput.prototype.__add_space_before_token = function() {\n  if (this.space_before_token && !this.just_added_newline()) {\n    if (!this.non_breaking_space) {\n      this.set_wrap_point();\n    }\n    this.current_line.push(' ');\n  }\n};\n\nOutput.prototype.remove_indent = function(index) {\n  var output_length = this.__lines.length;\n  while (index < output_length) {\n    this.__lines[index]._remove_indent();\n    index++;\n  }\n  this.current_line._remove_wrap_indent();\n};\n\nOutput.prototype.trim = function(eat_newlines) {\n  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n  this.current_line.trim();\n\n  while (eat_newlines && this.__lines.length > 1 &&\n    this.current_line.is_empty()) {\n    this.__lines.pop();\n    this.current_line = this.__lines[this.__lines.length - 1];\n    this.current_line.trim();\n  }\n\n  this.previous_line = this.__lines.length > 1 ?\n    this.__lines[this.__lines.length - 2] : null;\n};\n\nOutput.prototype.just_added_newline = function() {\n  return this.current_line.is_empty();\n};\n\nOutput.prototype.just_added_blankline = function() {\n  return this.is_empty() ||\n    (this.current_line.is_empty() && this.previous_line.is_empty());\n};\n\nOutput.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n  var index = this.__lines.length - 2;\n  while (index >= 0) {\n    var potentialEmptyLine = this.__lines[index];\n    if (potentialEmptyLine.is_empty()) {\n      break;\n    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&\n      potentialEmptyLine.item(-1) !== ends_with) {\n      this.__lines.splice(index + 1, 0, new OutputLine(this));\n      this.previous_line = this.__lines[this.__lines.length - 2];\n      break;\n    }\n    index--;\n  }\n};\n\nmodule.exports.Output = Output;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Token(type, text, newlines, whitespace_before) {\n  this.type = type;\n  this.text = text;\n\n  // comments_before are\n  // comments that have a new line before them\n  // and may or may not have a newline after\n  // this is a set of comments before\n  this.comments_before = null; /* inline comment*/\n\n\n  // this.comments_after =  new TokenStream(); // no new line before and newline after\n  this.newlines = newlines || 0;\n  this.whitespace_before = whitespace_before || '';\n  this.parent = null;\n  this.next = null;\n  this.previous = null;\n  this.opened = null;\n  this.closed = null;\n  this.directives = null;\n}\n\n\nmodule.exports.Token = Token;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* jshint node: true, curly: false */\n// Parts of this section of code is taken from acorn.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n\n// ## Character categories\n\n\n\n\n// acorn used char codes to squeeze the last bit of performance out\n// Beautifier is okay without that, so we're using regex\n// permit $ (36) and @ (64). @ is used in ES7 decorators.\n// 65 through 91 are uppercase letters.\n// permit _ (95).\n// 97 through 123 are lowercase letters.\nvar baseASCIIidentifierStartChars = \"\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n\n// inside an identifier @ is not allowed but 0-9 are.\nvar baseASCIIidentifierChars = \"\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\nvar nonASCIIidentifierStartChars = \"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\";\nvar nonASCIIidentifierChars = \"\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\";\n//var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n//var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nvar identifierStart = \"(?:\\\\\\\\u[0-9a-fA-F]{4}|[\" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + \"])\";\nvar identifierChars = \"(?:\\\\\\\\u[0-9a-fA-F]{4}|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])*\";\n\nexports.identifier = new RegExp(identifierStart + identifierChars, 'g');\nexports.identifierStart = new RegExp(identifierStart);\nexports.identifierMatch = new RegExp(\"(?:\\\\\\\\u[0-9a-fA-F]{4}|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])+\");\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/; // jshint ignore:line\n\n// Whether a single character denotes a newline.\n\nexports.newline = /[\\n\\r\\u2028\\u2029]/;\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\n// in javascript, these two differ\n// in python they are the same, different methods are called on them\nexports.lineBreak = new RegExp('\\r\\n|' + exports.newline.source);\nexports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseOptions = __webpack_require__(6).Options;\n\nvar validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];\n\nfunction Options(options) {\n  BaseOptions.call(this, options, 'js');\n\n  // compatibility, re\n  var raw_brace_style = this.raw_options.brace_style || null;\n  if (raw_brace_style === \"expand-strict\") { //graceful handling of deprecated option\n    this.raw_options.brace_style = \"expand\";\n  } else if (raw_brace_style === \"collapse-preserve-inline\") { //graceful handling of deprecated option\n    this.raw_options.brace_style = \"collapse,preserve-inline\";\n  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\n    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? \"expand\" : \"collapse\";\n    // } else if (!raw_brace_style) { //Nothing exists to set it\n    //   raw_brace_style = \"collapse\";\n  }\n\n  //preserve-inline in delimited string will trigger brace_preserve_inline, everything\n  //else is considered a brace_style and the last one only will have an effect\n\n  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);\n\n  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option\n  this.brace_style = \"collapse\";\n\n  for (var bs = 0; bs < brace_style_split.length; bs++) {\n    if (brace_style_split[bs] === \"preserve-inline\") {\n      this.brace_preserve_inline = true;\n    } else {\n      this.brace_style = brace_style_split[bs];\n    }\n  }\n\n  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');\n  this.break_chained_methods = this._get_boolean('break_chained_methods');\n  this.space_in_paren = this._get_boolean('space_in_paren');\n  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');\n  this.jslint_happy = this._get_boolean('jslint_happy');\n  this.space_after_anon_function = this._get_boolean('space_after_anon_function');\n  this.space_after_named_function = this._get_boolean('space_after_named_function');\n  this.keep_array_indentation = this._get_boolean('keep_array_indentation');\n  this.space_before_conditional = this._get_boolean('space_before_conditional', true);\n  this.unescape_strings = this._get_boolean('unescape_strings');\n  this.e4x = this._get_boolean('e4x');\n  this.comma_first = this._get_boolean('comma_first');\n  this.operator_position = this._get_selection('operator_position', validPositionValues);\n\n  // For testing of beautify preserve:start directive\n  this.test_output_raw = this._get_boolean('test_output_raw');\n\n  // force this._options.space_after_anon_function to true if this._options.jslint_happy\n  if (this.jslint_happy) {\n    this.space_after_anon_function = true;\n  }\n\n}\nOptions.prototype = new BaseOptions();\n\n\n\nmodule.exports.Options = Options;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Options(options, merge_child_field) {\n  this.raw_options = _mergeOpts(options, merge_child_field);\n\n  // Support passing the source text back with no change\n  this.disabled = this._get_boolean('disabled');\n\n  this.eol = this._get_characters('eol', 'auto');\n  this.end_with_newline = this._get_boolean('end_with_newline');\n  this.indent_size = this._get_number('indent_size', 4);\n  this.indent_char = this._get_characters('indent_char', ' ');\n  this.indent_level = this._get_number('indent_level');\n\n  this.preserve_newlines = this._get_boolean('preserve_newlines', true);\n  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);\n  if (!this.preserve_newlines) {\n    this.max_preserve_newlines = 0;\n  }\n\n  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\\t');\n  if (this.indent_with_tabs) {\n    this.indent_char = '\\t';\n\n    // indent_size behavior changed after 1.8.6\n    // It used to be that indent_size would be\n    // set to 1 for indent_with_tabs. That is no longer needed and\n    // actually doesn't make sense - why not use spaces? Further,\n    // that might produce unexpected behavior - tabs being used\n    // for single-column alignment. So, when indent_with_tabs is true\n    // and indent_size is 1, reset indent_size to 4.\n    if (this.indent_size === 1) {\n      this.indent_size = 4;\n    }\n  }\n\n  // Backwards compat with 1.3.x\n  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));\n\n  this.indent_empty_lines = this._get_boolean('indent_empty_lines');\n\n  // valid templating languages ['django', 'erb', 'handlebars', 'php']\n  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n  // other values ignored\n  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);\n}\n\nOptions.prototype._get_array = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || [];\n  if (typeof option_value === 'object') {\n    if (option_value !== null && typeof option_value.concat === 'function') {\n      result = option_value.concat();\n    }\n  } else if (typeof option_value === 'string') {\n    result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n  }\n  return result;\n};\n\nOptions.prototype._get_boolean = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = option_value === undefined ? !!default_value : !!option_value;\n  return result;\n};\n\nOptions.prototype._get_characters = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || '';\n  if (typeof option_value === 'string') {\n    result = option_value.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n').replace(/\\\\t/, '\\t');\n  }\n  return result;\n};\n\nOptions.prototype._get_number = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  default_value = parseInt(default_value, 10);\n  if (isNaN(default_value)) {\n    default_value = 0;\n  }\n  var result = parseInt(option_value, 10);\n  if (isNaN(result)) {\n    result = default_value;\n  }\n  return result;\n};\n\nOptions.prototype._get_selection = function(name, selection_list, default_value) {\n  var result = this._get_selection_list(name, selection_list, default_value);\n  if (result.length !== 1) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result[0];\n};\n\n\nOptions.prototype._get_selection_list = function(name, selection_list, default_value) {\n  if (!selection_list || selection_list.length === 0) {\n    throw new Error(\"Selection list cannot be empty.\");\n  }\n\n  default_value = default_value || [selection_list[0]];\n  if (!this._is_valid_selection(default_value, selection_list)) {\n    throw new Error(\"Invalid Default Value!\");\n  }\n\n  var result = this._get_array(name, default_value);\n  if (!this._is_valid_selection(result, selection_list)) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result;\n};\n\nOptions.prototype._is_valid_selection = function(result, selection_list) {\n  return result.length && selection_list.length &&\n    !result.some(function(item) { return selection_list.indexOf(item) === -1; });\n};\n\n\n// merges child options up with the parent options object\n// Example: obj = {a: 1, b: {a: 2}}\n//          mergeOpts(obj, 'b')\n//\n//          Returns: {a: 2}\nfunction _mergeOpts(allOptions, childFieldName) {\n  var finalOpts = {};\n  allOptions = _normalizeOpts(allOptions);\n  var name;\n\n  for (name in allOptions) {\n    if (name !== childFieldName) {\n      finalOpts[name] = allOptions[name];\n    }\n  }\n\n  //merge in the per type settings for the childFieldName\n  if (childFieldName && allOptions[childFieldName]) {\n    for (name in allOptions[childFieldName]) {\n      finalOpts[name] = allOptions[childFieldName][name];\n    }\n  }\n  return finalOpts;\n}\n\nfunction _normalizeOpts(options) {\n  var convertedOpts = {};\n  var key;\n\n  for (key in options) {\n    var newKey = key.replace(/-/g, \"_\");\n    convertedOpts[newKey] = options[key];\n  }\n  return convertedOpts;\n}\n\nmodule.exports.Options = Options;\nmodule.exports.normalizeOpts = _normalizeOpts;\nmodule.exports.mergeOpts = _mergeOpts;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar BaseTokenizer = __webpack_require__(9).Tokenizer;\nvar BASETOKEN = __webpack_require__(9).TOKEN;\nvar Directives = __webpack_require__(13).Directives;\nvar acorn = __webpack_require__(4);\nvar Pattern = __webpack_require__(12).Pattern;\nvar TemplatablePattern = __webpack_require__(14).TemplatablePattern;\n\n\nfunction in_array(what, arr) {\n  return arr.indexOf(what) !== -1;\n}\n\n\nvar TOKEN = {\n  START_EXPR: 'TK_START_EXPR',\n  END_EXPR: 'TK_END_EXPR',\n  START_BLOCK: 'TK_START_BLOCK',\n  END_BLOCK: 'TK_END_BLOCK',\n  WORD: 'TK_WORD',\n  RESERVED: 'TK_RESERVED',\n  SEMICOLON: 'TK_SEMICOLON',\n  STRING: 'TK_STRING',\n  EQUALS: 'TK_EQUALS',\n  OPERATOR: 'TK_OPERATOR',\n  COMMA: 'TK_COMMA',\n  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',\n  COMMENT: 'TK_COMMENT',\n  DOT: 'TK_DOT',\n  UNKNOWN: 'TK_UNKNOWN',\n  START: BASETOKEN.START,\n  RAW: BASETOKEN.RAW,\n  EOF: BASETOKEN.EOF\n};\n\n\nvar directives_core = new Directives(/\\/\\*/, /\\*\\//);\n\nvar number_pattern = /0[xX][0123456789abcdefABCDEF]*|0[oO][01234567]*|0[bB][01]*|\\d+n|(?:\\.\\d+|\\d+\\.?\\d*)(?:[eE][+-]?\\d+)?/;\n\nvar digit = /[0-9]/;\n\n// Dot \".\" must be distinguished from \"...\" and decimal\nvar dot_pattern = /[^\\d\\.]/;\n\nvar positionable_operators = (\n  \">>> === !== \" +\n  \"<< && >= ** != == <= >> || \" +\n  \"< / - + > : & % ? ^ | *\").split(' ');\n\n// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.\n// Also, you must update possitionable operators separately from punct\nvar punct =\n  \">>>= \" +\n  \"... >>= <<= === >>> !== **= \" +\n  \"=> ^= :: /= << <= == && -= >= >> != -- += ** || ++ %= &= *= |= \" +\n  \"= ! ? > < : / ^ - + * & % ~ |\";\n\npunct = punct.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\npunct = punct.replace(/ /g, '|');\n\nvar punct_pattern = new RegExp(punct);\n\n// words which should always start on new line.\nvar line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');\nvar reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);\nvar reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');\n\n// var template_pattern = /(?:(?:<\\?php|<\\?=)[\\s\\S]*?\\?>)|(?:<%[\\s\\S]*?%>)/g;\n\nvar in_html_comment;\n\nvar Tokenizer = function(input_string, options) {\n  BaseTokenizer.call(this, input_string, options);\n\n  this._patterns.whitespace = this._patterns.whitespace.matching(\n    /\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source,\n    /\\u2028\\u2029/.source);\n\n  var pattern_reader = new Pattern(this._input);\n  var templatable = new TemplatablePattern(this._input)\n    .read_options(this._options);\n\n  this.__patterns = {\n    template: templatable,\n    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),\n    number: pattern_reader.matching(number_pattern),\n    punct: pattern_reader.matching(punct_pattern),\n    // comment ends just before nearest linefeed or end of file\n    comment: pattern_reader.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/),\n    //  /* ... */ comment ends with nearest */ or end of file\n    block_comment: pattern_reader.starting_with(/\\/\\*/).until_after(/\\*\\//),\n    html_comment_start: pattern_reader.matching(/<!--/),\n    html_comment_end: pattern_reader.matching(/-->/),\n    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),\n    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),\n    xml: pattern_reader.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[\\s\\S]+?}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+{[\\s\\S]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{[\\s\\S]+?}))*\\s*(\\/?)\\s*>/),\n    single_quote: templatable.until(/['\\\\\\n\\r\\u2028\\u2029]/),\n    double_quote: templatable.until(/[\"\\\\\\n\\r\\u2028\\u2029]/),\n    template_text: templatable.until(/[`\\\\$]/),\n    template_expression: templatable.until(/[`}\\\\]/)\n  };\n\n};\nTokenizer.prototype = new BaseTokenizer();\n\nTokenizer.prototype._is_comment = function(current_token) {\n  return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;\n};\n\nTokenizer.prototype._is_opening = function(current_token) {\n  return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) {\n  return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) &&\n    (open_token && (\n      (current_token.text === ']' && open_token.text === '[') ||\n      (current_token.text === ')' && open_token.text === '(') ||\n      (current_token.text === '}' && open_token.text === '{')));\n};\n\nTokenizer.prototype._reset = function() {\n  in_html_comment = false;\n};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  var token = null;\n  this._readWhitespace();\n  var c = this._input.peek();\n\n  if (c === null) {\n    return this._create_token(TOKEN.EOF, '');\n  }\n\n  token = token || this._read_string(c);\n  token = token || this._read_word(previous_token);\n  token = token || this._read_singles(c);\n  token = token || this._read_comment(c);\n  token = token || this._read_regexp(c, previous_token);\n  token = token || this._read_xml(c, previous_token);\n  token = token || this._read_non_javascript(c);\n  token = token || this._read_punctuation();\n  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n\n  return token;\n};\n\nTokenizer.prototype._read_word = function(previous_token) {\n  var resulting_string;\n  resulting_string = this.__patterns.identifier.read();\n  if (resulting_string !== '') {\n    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\\n');\n    if (!(previous_token.type === TOKEN.DOT ||\n        (previous_token.type === TOKEN.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&\n      reserved_word_pattern.test(resulting_string)) {\n      if (resulting_string === 'in' || resulting_string === 'of') { // hack for 'in' and 'of' operators\n        return this._create_token(TOKEN.OPERATOR, resulting_string);\n      }\n      return this._create_token(TOKEN.RESERVED, resulting_string);\n    }\n    return this._create_token(TOKEN.WORD, resulting_string);\n  }\n\n  resulting_string = this.__patterns.number.read();\n  if (resulting_string !== '') {\n    return this._create_token(TOKEN.WORD, resulting_string);\n  }\n};\n\nTokenizer.prototype._read_singles = function(c) {\n  var token = null;\n  if (c === '(' || c === '[') {\n    token = this._create_token(TOKEN.START_EXPR, c);\n  } else if (c === ')' || c === ']') {\n    token = this._create_token(TOKEN.END_EXPR, c);\n  } else if (c === '{') {\n    token = this._create_token(TOKEN.START_BLOCK, c);\n  } else if (c === '}') {\n    token = this._create_token(TOKEN.END_BLOCK, c);\n  } else if (c === ';') {\n    token = this._create_token(TOKEN.SEMICOLON, c);\n  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {\n    token = this._create_token(TOKEN.DOT, c);\n  } else if (c === ',') {\n    token = this._create_token(TOKEN.COMMA, c);\n  }\n\n  if (token) {\n    this._input.next();\n  }\n  return token;\n};\n\nTokenizer.prototype._read_punctuation = function() {\n  var resulting_string = this.__patterns.punct.read();\n\n  if (resulting_string !== '') {\n    if (resulting_string === '=') {\n      return this._create_token(TOKEN.EQUALS, resulting_string);\n    } else {\n      return this._create_token(TOKEN.OPERATOR, resulting_string);\n    }\n  }\n};\n\nTokenizer.prototype._read_non_javascript = function(c) {\n  var resulting_string = '';\n\n  if (c === '#') {\n    if (this._is_first_token()) {\n      resulting_string = this.__patterns.shebang.read();\n\n      if (resulting_string) {\n        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\\n');\n      }\n    }\n\n    // handles extendscript #includes\n    resulting_string = this.__patterns.include.read();\n\n    if (resulting_string) {\n      return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\\n');\n    }\n\n    c = this._input.next();\n\n    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.\n    var sharp = '#';\n    if (this._input.hasNext() && this._input.testChar(digit)) {\n      do {\n        c = this._input.next();\n        sharp += c;\n      } while (this._input.hasNext() && c !== '#' && c !== '=');\n      if (c === '#') {\n        //\n      } else if (this._input.peek() === '[' && this._input.peek(1) === ']') {\n        sharp += '[]';\n        this._input.next();\n        this._input.next();\n      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {\n        sharp += '{}';\n        this._input.next();\n        this._input.next();\n      }\n      return this._create_token(TOKEN.WORD, sharp);\n    }\n\n    this._input.back();\n\n  } else if (c === '<' && this._is_first_token()) {\n    resulting_string = this.__patterns.html_comment_start.read();\n    if (resulting_string) {\n      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {\n        resulting_string += this._input.next();\n      }\n      in_html_comment = true;\n      return this._create_token(TOKEN.COMMENT, resulting_string);\n    }\n  } else if (in_html_comment && c === '-') {\n    resulting_string = this.__patterns.html_comment_end.read();\n    if (resulting_string) {\n      in_html_comment = false;\n      return this._create_token(TOKEN.COMMENT, resulting_string);\n    }\n  }\n\n  return null;\n};\n\nTokenizer.prototype._read_comment = function(c) {\n  var token = null;\n  if (c === '/') {\n    var comment = '';\n    if (this._input.peek(1) === '*') {\n      // peek for comment /* ... */\n      comment = this.__patterns.block_comment.read();\n      var directives = directives_core.get_directives(comment);\n      if (directives && directives.ignore === 'start') {\n        comment += directives_core.readIgnored(this._input);\n      }\n      comment = comment.replace(acorn.allLineBreaks, '\\n');\n      token = this._create_token(TOKEN.BLOCK_COMMENT, comment);\n      token.directives = directives;\n    } else if (this._input.peek(1) === '/') {\n      // peek for comment // ...\n      comment = this.__patterns.comment.read();\n      token = this._create_token(TOKEN.COMMENT, comment);\n    }\n  }\n  return token;\n};\n\nTokenizer.prototype._read_string = function(c) {\n  if (c === '`' || c === \"'\" || c === '\"') {\n    var resulting_string = this._input.next();\n    this.has_char_escapes = false;\n\n    if (c === '`') {\n      resulting_string += this._read_string_recursive('`', true, '${');\n    } else {\n      resulting_string += this._read_string_recursive(c);\n    }\n\n    if (this.has_char_escapes && this._options.unescape_strings) {\n      resulting_string = unescape_string(resulting_string);\n    }\n\n    if (this._input.peek() === c) {\n      resulting_string += this._input.next();\n    }\n\n    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\\n');\n\n    return this._create_token(TOKEN.STRING, resulting_string);\n  }\n\n  return null;\n};\n\nTokenizer.prototype._allow_regexp_or_xml = function(previous_token) {\n  // regex and xml can only appear in specific locations during parsing\n  return (previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\n    (previous_token.type === TOKEN.END_EXPR && previous_token.text === ')' &&\n      previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||\n    (in_array(previous_token.type, [TOKEN.COMMENT, TOKEN.START_EXPR, TOKEN.START_BLOCK, TOKEN.START,\n      TOKEN.END_BLOCK, TOKEN.OPERATOR, TOKEN.EQUALS, TOKEN.EOF, TOKEN.SEMICOLON, TOKEN.COMMA\n    ]));\n};\n\nTokenizer.prototype._read_regexp = function(c, previous_token) {\n\n  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {\n    // handle regexp\n    //\n    var resulting_string = this._input.next();\n    var esc = false;\n\n    var in_char_class = false;\n    while (this._input.hasNext() &&\n      ((esc || in_char_class || this._input.peek() !== c) &&\n        !this._input.testChar(acorn.newline))) {\n      resulting_string += this._input.peek();\n      if (!esc) {\n        esc = this._input.peek() === '\\\\';\n        if (this._input.peek() === '[') {\n          in_char_class = true;\n        } else if (this._input.peek() === ']') {\n          in_char_class = false;\n        }\n      } else {\n        esc = false;\n      }\n      this._input.next();\n    }\n\n    if (this._input.peek() === c) {\n      resulting_string += this._input.next();\n\n      // regexps may have modifiers /regexp/MOD , so fetch those, too\n      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n      resulting_string += this._input.read(acorn.identifier);\n    }\n    return this._create_token(TOKEN.STRING, resulting_string);\n  }\n  return null;\n};\n\nTokenizer.prototype._read_xml = function(c, previous_token) {\n\n  if (this._options.e4x && c === \"<\" && this._allow_regexp_or_xml(previous_token)) {\n    var xmlStr = '';\n    var match = this.__patterns.xml.read_match();\n    // handle e4x xml literals\n    //\n    if (match) {\n      // Trim root tag to attempt to\n      var rootTag = match[2].replace(/^{\\s+/, '{').replace(/\\s+}$/, '}');\n      var isCurlyRoot = rootTag.indexOf('{') === 0;\n      var depth = 0;\n      while (match) {\n        var isEndTag = !!match[1];\n        var tagName = match[2];\n        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === \"![CDATA[\");\n        if (!isSingletonTag &&\n          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\\s+/, '{').replace(/\\s+}$/, '}')))) {\n          if (isEndTag) {\n            --depth;\n          } else {\n            ++depth;\n          }\n        }\n        xmlStr += match[0];\n        if (depth <= 0) {\n          break;\n        }\n        match = this.__patterns.xml.read_match();\n      }\n      // if we didn't close correctly, keep unformatted.\n      if (!match) {\n        xmlStr += this._input.match(/[\\s\\S]*/g)[0];\n      }\n      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\\n');\n      return this._create_token(TOKEN.STRING, xmlStr);\n    }\n  }\n\n  return null;\n};\n\nfunction unescape_string(s) {\n  // You think that a regex would work for this\n  // return s.replace(/\\\\x([0-9a-f]{2})/gi, function(match, val) {\n  //         return String.fromCharCode(parseInt(val, 16));\n  //     })\n  // However, dealing with '\\xff', '\\\\xff', '\\\\\\xff' makes this more fun.\n  var out = '',\n    escaped = 0;\n\n  var input_scan = new InputScanner(s);\n  var matched = null;\n\n  while (input_scan.hasNext()) {\n    // Keep any whitespace, non-slash characters\n    // also keep slash pairs.\n    matched = input_scan.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g);\n\n    if (matched) {\n      out += matched[0];\n    }\n\n    if (input_scan.peek() === '\\\\') {\n      input_scan.next();\n      if (input_scan.peek() === 'x') {\n        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);\n      } else if (input_scan.peek() === 'u') {\n        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);\n      } else {\n        out += '\\\\';\n        if (input_scan.hasNext()) {\n          out += input_scan.next();\n        }\n        continue;\n      }\n\n      // If there's some error decoding, return the original string\n      if (!matched) {\n        return s;\n      }\n\n      escaped = parseInt(matched[1], 16);\n\n      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {\n        // we bail out on \\x7f..\\xff,\n        // leaving whole string escaped,\n        // as it's probably completely binary\n        return s;\n      } else if (escaped >= 0x00 && escaped < 0x20) {\n        // leave 0x00...0x1f escaped\n        out += '\\\\' + matched[0];\n        continue;\n      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n        // single-quote, apostrophe, backslash - escape these\n        out += '\\\\' + String.fromCharCode(escaped);\n      } else {\n        out += String.fromCharCode(escaped);\n      }\n    }\n  }\n\n  return out;\n}\n\n// handle string\n//\nTokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {\n  var current_char;\n  var pattern;\n  if (delimiter === '\\'') {\n    pattern = this.__patterns.single_quote;\n  } else if (delimiter === '\"') {\n    pattern = this.__patterns.double_quote;\n  } else if (delimiter === '`') {\n    pattern = this.__patterns.template_text;\n  } else if (delimiter === '}') {\n    pattern = this.__patterns.template_expression;\n  }\n\n  var resulting_string = pattern.read();\n  var next = '';\n  while (this._input.hasNext()) {\n    next = this._input.next();\n    if (next === delimiter ||\n      (!allow_unescaped_newlines && acorn.newline.test(next))) {\n      this._input.back();\n      break;\n    } else if (next === '\\\\' && this._input.hasNext()) {\n      current_char = this._input.peek();\n\n      if (current_char === 'x' || current_char === 'u') {\n        this.has_char_escapes = true;\n      } else if (current_char === '\\r' && this._input.peek(1) === '\\n') {\n        this._input.next();\n      }\n      next += this._input.next();\n    } else if (start_sub) {\n      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {\n        next += this._input.next();\n      }\n\n      if (start_sub === next) {\n        if (delimiter === '`') {\n          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');\n        } else {\n          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');\n        }\n        if (this._input.hasNext()) {\n          next += this._input.next();\n        }\n      }\n    }\n    next += pattern.read();\n    resulting_string += next;\n  }\n\n  return resulting_string;\n};\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\nmodule.exports.positionable_operators = positionable_operators.slice();\nmodule.exports.line_starters = line_starters.slice();\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');\n\nfunction InputScanner(input_string) {\n  this.__input = input_string || '';\n  this.__input_length = this.__input.length;\n  this.__position = 0;\n}\n\nInputScanner.prototype.restart = function() {\n  this.__position = 0;\n};\n\nInputScanner.prototype.back = function() {\n  if (this.__position > 0) {\n    this.__position -= 1;\n  }\n};\n\nInputScanner.prototype.hasNext = function() {\n  return this.__position < this.__input_length;\n};\n\nInputScanner.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__input.charAt(this.__position);\n    this.__position += 1;\n  }\n  return val;\n};\n\nInputScanner.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__input_length) {\n    val = this.__input.charAt(index);\n  }\n  return val;\n};\n\n// This is a JavaScript only helper function (not in python)\n// Javascript doesn't have a match method\n// and not all implementation support \"sticky\" flag.\n// If they do not support sticky then both this.match() and this.test() method\n// must get the match and check the index of the match.\n// If sticky is supported and set, this method will use it.\n// Otherwise it will check that global is set, and fall back to the slower method.\nInputScanner.prototype.__match = function(pattern, index) {\n  pattern.lastIndex = index;\n  var pattern_match = pattern.exec(this.__input);\n\n  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n    if (pattern_match.index !== index) {\n      pattern_match = null;\n    }\n  }\n\n  return pattern_match;\n};\n\nInputScanner.prototype.test = function(pattern, index) {\n  index = index || 0;\n  index += this.__position;\n\n  if (index >= 0 && index < this.__input_length) {\n    return !!this.__match(pattern, index);\n  } else {\n    return false;\n  }\n};\n\nInputScanner.prototype.testChar = function(pattern, index) {\n  // test one character regex match\n  var val = this.peek(index);\n  pattern.lastIndex = 0;\n  return val !== null && pattern.test(val);\n};\n\nInputScanner.prototype.match = function(pattern) {\n  var pattern_match = this.__match(pattern, this.__position);\n  if (pattern_match) {\n    this.__position += pattern_match[0].length;\n  } else {\n    pattern_match = null;\n  }\n  return pattern_match;\n};\n\nInputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n  var val = '';\n  var match;\n  if (starting_pattern) {\n    match = this.match(starting_pattern);\n    if (match) {\n      val += match[0];\n    }\n  }\n  if (until_pattern && (match || !starting_pattern)) {\n    val += this.readUntil(until_pattern, until_after);\n  }\n  return val;\n};\n\nInputScanner.prototype.readUntil = function(pattern, until_after) {\n  var val = '';\n  var match_index = this.__position;\n  pattern.lastIndex = this.__position;\n  var pattern_match = pattern.exec(this.__input);\n  if (pattern_match) {\n    match_index = pattern_match.index;\n    if (until_after) {\n      match_index += pattern_match[0].length;\n    }\n  } else {\n    match_index = this.__input_length;\n  }\n\n  val = this.__input.substring(this.__position, match_index);\n  this.__position = match_index;\n  return val;\n};\n\nInputScanner.prototype.readUntilAfter = function(pattern) {\n  return this.readUntil(pattern, true);\n};\n\nInputScanner.prototype.get_regexp = function(pattern, match_from) {\n  var result = null;\n  var flags = 'g';\n  if (match_from && regexp_has_sticky) {\n    flags = 'y';\n  }\n  // strings are converted to regexp\n  if (typeof pattern === \"string\" && pattern !== '') {\n    // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n    result = new RegExp(pattern, flags);\n  } else if (pattern) {\n    result = new RegExp(pattern.source, flags);\n  }\n  return result;\n};\n\nInputScanner.prototype.get_literal_regexp = function(literal_string) {\n  return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n};\n\n/* css beautifier legacy helpers */\nInputScanner.prototype.peekUntilAfter = function(pattern) {\n  var start = this.__position;\n  var val = this.readUntilAfter(pattern);\n  this.__position = start;\n  return val;\n};\n\nInputScanner.prototype.lookBack = function(testVal) {\n  var start = this.__position - 1;\n  return start >= testVal.length && this.__input.substring(start - testVal.length, start)\n    .toLowerCase() === testVal;\n};\n\nmodule.exports.InputScanner = InputScanner;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar Token = __webpack_require__(3).Token;\nvar TokenStream = __webpack_require__(10).TokenStream;\nvar WhitespacePattern = __webpack_require__(11).WhitespacePattern;\n\nvar TOKEN = {\n  START: 'TK_START',\n  RAW: 'TK_RAW',\n  EOF: 'TK_EOF'\n};\n\nvar Tokenizer = function(input_string, options) {\n  this._input = new InputScanner(input_string);\n  this._options = options || {};\n  this.__tokens = null;\n\n  this._patterns = {};\n  this._patterns.whitespace = new WhitespacePattern(this._input);\n};\n\nTokenizer.prototype.tokenize = function() {\n  this._input.restart();\n  this.__tokens = new TokenStream();\n\n  this._reset();\n\n  var current;\n  var previous = new Token(TOKEN.START, '');\n  var open_token = null;\n  var open_stack = [];\n  var comments = new TokenStream();\n\n  while (previous.type !== TOKEN.EOF) {\n    current = this._get_next_token(previous, open_token);\n    while (this._is_comment(current)) {\n      comments.add(current);\n      current = this._get_next_token(previous, open_token);\n    }\n\n    if (!comments.isEmpty()) {\n      current.comments_before = comments;\n      comments = new TokenStream();\n    }\n\n    current.parent = open_token;\n\n    if (this._is_opening(current)) {\n      open_stack.push(open_token);\n      open_token = current;\n    } else if (open_token && this._is_closing(current, open_token)) {\n      current.opened = open_token;\n      open_token.closed = current;\n      open_token = open_stack.pop();\n      current.parent = open_token;\n    }\n\n    current.previous = previous;\n    previous.next = current;\n\n    this.__tokens.add(current);\n    previous = current;\n  }\n\n  return this.__tokens;\n};\n\n\nTokenizer.prototype._is_first_token = function() {\n  return this.__tokens.isEmpty();\n};\n\nTokenizer.prototype._reset = function() {};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  this._readWhitespace();\n  var resulting_string = this._input.read(/.+/g);\n  if (resulting_string) {\n    return this._create_token(TOKEN.RAW, resulting_string);\n  } else {\n    return this._create_token(TOKEN.EOF, '');\n  }\n};\n\nTokenizer.prototype._is_comment = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_opening = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._create_token = function(type, text) {\n  var token = new Token(type, text,\n    this._patterns.whitespace.newline_count,\n    this._patterns.whitespace.whitespace_before_token);\n  return token;\n};\n\nTokenizer.prototype._readWhitespace = function() {\n  return this._patterns.whitespace.read();\n};\n\n\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction TokenStream(parent_token) {\n  // private\n  this.__tokens = [];\n  this.__tokens_length = this.__tokens.length;\n  this.__position = 0;\n  this.__parent_token = parent_token;\n}\n\nTokenStream.prototype.restart = function() {\n  this.__position = 0;\n};\n\nTokenStream.prototype.isEmpty = function() {\n  return this.__tokens_length === 0;\n};\n\nTokenStream.prototype.hasNext = function() {\n  return this.__position < this.__tokens_length;\n};\n\nTokenStream.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__tokens[this.__position];\n    this.__position += 1;\n  }\n  return val;\n};\n\nTokenStream.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__tokens_length) {\n    val = this.__tokens[index];\n  }\n  return val;\n};\n\nTokenStream.prototype.add = function(token) {\n  if (this.__parent_token) {\n    token.parent = this.__parent_token;\n  }\n  this.__tokens.push(token);\n  this.__tokens_length += 1;\n};\n\nmodule.exports.TokenStream = TokenStream;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\nfunction WhitespacePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  if (parent) {\n    this._line_regexp = this._input.get_regexp(parent._line_regexp);\n  } else {\n    this.__set_whitespace_patterns('', '');\n  }\n\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n}\nWhitespacePattern.prototype = new Pattern();\n\nWhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n  whitespace_chars += '\\\\t ';\n  newline_chars += '\\\\n\\\\r';\n\n  this._match_pattern = this._input.get_regexp(\n    '[' + whitespace_chars + newline_chars + ']+', true);\n  this._newline_regexp = this._input.get_regexp(\n    '\\\\r\\\\n|[' + newline_chars + ']');\n};\n\nWhitespacePattern.prototype.read = function() {\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n\n  var resulting_string = this._input.read(this._match_pattern);\n  if (resulting_string === ' ') {\n    this.whitespace_before_token = ' ';\n  } else if (resulting_string) {\n    var matches = this.__split(this._newline_regexp, resulting_string);\n    this.newline_count = matches.length - 1;\n    this.whitespace_before_token = matches[this.newline_count];\n  }\n\n  return resulting_string;\n};\n\nWhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n  var result = this._create();\n  result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n  result._update();\n  return result;\n};\n\nWhitespacePattern.prototype._create = function() {\n  return new WhitespacePattern(this._input, this);\n};\n\nWhitespacePattern.prototype.__split = function(regexp, input_string) {\n  regexp.lastIndex = 0;\n  var start_index = 0;\n  var result = [];\n  var next_match = regexp.exec(input_string);\n  while (next_match) {\n    result.push(input_string.substring(start_index, next_match.index));\n    start_index = next_match.index + next_match[0].length;\n    next_match = regexp.exec(input_string);\n  }\n\n  if (start_index < input_string.length) {\n    result.push(input_string.substring(start_index, input_string.length));\n  } else {\n    result.push('');\n  }\n\n  return result;\n};\n\n\n\nmodule.exports.WhitespacePattern = WhitespacePattern;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Pattern(input_scanner, parent) {\n  this._input = input_scanner;\n  this._starting_pattern = null;\n  this._match_pattern = null;\n  this._until_pattern = null;\n  this._until_after = false;\n\n  if (parent) {\n    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n    this._until_pattern = this._input.get_regexp(parent._until_pattern);\n    this._until_after = parent._until_after;\n  }\n}\n\nPattern.prototype.read = function() {\n  var result = this._input.read(this._starting_pattern);\n  if (!this._starting_pattern || result) {\n    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n  }\n  return result;\n};\n\nPattern.prototype.read_match = function() {\n  return this._input.match(this._match_pattern);\n};\n\nPattern.prototype.until_after = function(pattern) {\n  var result = this._create();\n  result._until_after = true;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.until = function(pattern) {\n  var result = this._create();\n  result._until_after = false;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.starting_with = function(pattern) {\n  var result = this._create();\n  result._starting_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype.matching = function(pattern) {\n  var result = this._create();\n  result._match_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype._create = function() {\n  return new Pattern(this._input, this);\n};\n\nPattern.prototype._update = function() {};\n\nmodule.exports.Pattern = Pattern;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Directives(start_block_pattern, end_block_pattern) {\n  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;\n  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;\n  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, 'g');\n  this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n\n  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, 'g');\n}\n\nDirectives.prototype.get_directives = function(text) {\n  if (!text.match(this.__directives_block_pattern)) {\n    return null;\n  }\n\n  var directives = {};\n  this.__directive_pattern.lastIndex = 0;\n  var directive_match = this.__directive_pattern.exec(text);\n\n  while (directive_match) {\n    directives[directive_match[1]] = directive_match[2];\n    directive_match = this.__directive_pattern.exec(text);\n  }\n\n  return directives;\n};\n\nDirectives.prototype.readIgnored = function(input) {\n  return input.readUntilAfter(this.__directives_end_ignore_pattern);\n};\n\n\nmodule.exports.Directives = Directives;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\n\nvar template_names = {\n  django: false,\n  erb: false,\n  handlebars: false,\n  php: false\n};\n\n// This lets templates appear anywhere we would do a readUntil\n// The cost is higher but it is pay to play.\nfunction TemplatablePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  this.__template_pattern = null;\n  this._disabled = Object.assign({}, template_names);\n  this._excluded = Object.assign({}, template_names);\n\n  if (parent) {\n    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n    this._excluded = Object.assign(this._excluded, parent._excluded);\n    this._disabled = Object.assign(this._disabled, parent._disabled);\n  }\n  var pattern = new Pattern(input_scanner);\n  this.__patterns = {\n    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n    handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n    php: pattern.starting_with(/<\\?(?:[=]|php)/).until_after(/\\?>/),\n    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n    // django coflicts with handlebars a bit.\n    django: pattern.starting_with(/{%/).until_after(/%}/),\n    django_value: pattern.starting_with(/{{/).until_after(/}}/),\n    django_comment: pattern.starting_with(/{#/).until_after(/#}/)\n  };\n}\nTemplatablePattern.prototype = new Pattern();\n\nTemplatablePattern.prototype._create = function() {\n  return new TemplatablePattern(this._input, this);\n};\n\nTemplatablePattern.prototype._update = function() {\n  this.__set_templated_pattern();\n};\n\nTemplatablePattern.prototype.disable = function(language) {\n  var result = this._create();\n  result._disabled[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read_options = function(options) {\n  var result = this._create();\n  for (var language in template_names) {\n    result._disabled[language] = options.templating.indexOf(language) === -1;\n  }\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.exclude = function(language) {\n  var result = this._create();\n  result._excluded[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read = function() {\n  var result = '';\n  if (this._match_pattern) {\n    result = this._input.read(this._starting_pattern);\n  } else {\n    result = this._input.read(this._starting_pattern, this.__template_pattern);\n  }\n  var next = this._read_template();\n  while (next) {\n    if (this._match_pattern) {\n      next += this._input.read(this._match_pattern);\n    } else {\n      next += this._input.readUntil(this.__template_pattern);\n    }\n    result += next;\n    next = this._read_template();\n  }\n\n  if (this._until_after) {\n    result += this._input.readUntilAfter(this._until_pattern);\n  }\n  return result;\n};\n\nTemplatablePattern.prototype.__set_templated_pattern = function() {\n  var items = [];\n\n  if (!this._disabled.php) {\n    items.push(this.__patterns.php._starting_pattern.source);\n  }\n  if (!this._disabled.handlebars) {\n    items.push(this.__patterns.handlebars._starting_pattern.source);\n  }\n  if (!this._disabled.erb) {\n    items.push(this.__patterns.erb._starting_pattern.source);\n  }\n  if (!this._disabled.django) {\n    items.push(this.__patterns.django._starting_pattern.source);\n    items.push(this.__patterns.django_value._starting_pattern.source);\n    items.push(this.__patterns.django_comment._starting_pattern.source);\n  }\n\n  if (this._until_pattern) {\n    items.push(this._until_pattern.source);\n  }\n  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');\n};\n\nTemplatablePattern.prototype._read_template = function() {\n  var resulting_string = '';\n  var c = this._input.peek();\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    //if we're in a comment, do something special\n    // We treat all comments as literals, even more than preformatted tags\n    // we just look for the appropriate close tag\n    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {\n      resulting_string = resulting_string ||\n        this.__patterns.php.read();\n    }\n    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {\n      resulting_string = resulting_string ||\n        this.__patterns.erb.read();\n    }\n  } else if (c === '{') {\n    if (!this._disabled.handlebars && !this._excluded.handlebars) {\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_comment.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_unescaped.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars.read();\n    }\n    if (!this._disabled.django) {\n      // django coflicts with handlebars a bit.\n      if (!this._excluded.django && !this._excluded.handlebars) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_value.read();\n      }\n      if (!this._excluded.django) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_comment.read();\n        resulting_string = resulting_string ||\n          this.__patterns.django.read();\n      }\n    }\n  }\n  return resulting_string;\n};\n\n\nmodule.exports.TemplatablePattern = TemplatablePattern;\n\n\n/***/ })\n/******/ ]);\nvar js_beautify = legacy_beautify_js;\n/* Footer */\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return { js_beautify: js_beautify };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LmpzP2U5NDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEIsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNB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Q0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0IsUUFBUSxlQUFlO0FBQzNDLG9CQUFvQixVQUFVLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDO0FBQ3hDLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsMEVBQTBFO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3RELGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcseUlBQXlJO0FBQzVJLHlCQUF5QixLQUFLO0FBQzlCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx5Q0FBeUMsdUNBQXVDO0FBQ2hGLFVBQVUsS0FBSztBQUNmLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7O0FBRzlCLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxFQUFFO0FBQzdDLDJDQUEyQyxFQUFFOztBQUU3QztBQUNBO0FBQ0EsMERBQTBELEVBQUU7O0FBRTVELCtFQUErRTs7QUFFL0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRywyREFBMkQ7QUFDOUQ7QUFDQSxHQUFHLDhEQUE4RDtBQUNqRTtBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUEsa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QyxFQUFFO0FBQy9FOzs7QUFHQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLDhDQUE4QztBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBUztBQUNULGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RSxvREFBb0QsbUJBQW1CO0FBQ3ZFLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RCwyQ0FBMkMsa0JBQWtCO0FBQzdELDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtCQUFrQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUEwQztBQUM5QztBQUNBLElBQUksaUNBQU8sRUFBRSxtQ0FBRTtBQUNmLGdCQUFnQjtBQUNoQixLQUFLO0FBQUEsb0dBQUM7QUFDTixDQUFDLE1BQU0sRUFVTjs7QUFFRCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cbiBKUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuXG4gIFdyaXR0ZW4gYnkgRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAYmVhdXRpZmllci5pbz5cbiAgICAgIGh0dHBzOi8vYmVhdXRpZmllci5pby9cblxuICBPcmlnaW5hbGx5IGNvbnZlcnRlZCB0byBqYXZhc2NyaXB0IGJ5IFZpdGFsLCA8dml0YWw3NkBnbWFpbC5jb20+XG4gIFwiRW5kIGJyYWNlcyBvbiBvd24gbGluZVwiIGFkZGVkIGJ5IENocmlzIEouIFNodWxsLCA8Y2hyaXNqc2h1bGxAZ21haWwuY29tPlxuICBQYXJzaW5nIGltcHJvdmVtZW50cyBmb3IgYnJhY2UtbGVzcyBzdGF0ZW1lbnRzIGJ5IExpYW0gTmV3bWFuIDxiaXR3aXNlbWFuQGJlYXV0aWZpZXIuaW8+XG5cblxuICBVc2FnZTpcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCk7XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICAtIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAgLSBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQsXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rLFxuXG4gICAganNsaW50X2hhcHB5IChkZWZhdWx0IGZhbHNlKSAtIGlmIHRydWUsIHRoZW4ganNsaW50LXN0cmljdGVyIG1vZGUgaXMgZW5mb3JjZWQuXG5cbiAgICAgICAgICAgIGpzbGludF9oYXBweSAgICAgICAgIWpzbGludF9oYXBweVxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSAgICAgICAgIGZ1bmN0aW9uKClcblxuICAgICAgICAgICAgc3dpdGNoICgpIHsgICAgICAgICBzd2l0Y2goKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIH1cblxuICAgIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gKGRlZmF1bHQgZmFsc2UpIC0gc2hvdWxkIHRoZSBzcGFjZSBiZWZvcmUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uJ3MgcGFyZW5zIGJlIGFkZGVkLCBcImZ1bmN0aW9uKClcIiB2cyBcImZ1bmN0aW9uICgpXCIsXG4gICAgICAgICAgTk9URTogVGhpcyBvcHRpb24gaXMgb3ZlcnJpZGVuIGJ5IGpzbGludF9oYXBweSAoaS5lLiBpZiBqc2xpbnRfaGFwcHkgaXMgdHJ1ZSwgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiBpcyB0cnVlIGJ5IGRlc2lnbilcblxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIiB8IGFueSBvZiB0aGUgZm9ybWVyICsgXCIscHJlc2VydmUtaW5saW5lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgICAgICAgICBwcmVzZXJ2ZS1pbmxpbmUgd2lsbCB0cnkgdG8gcHJlc2VydmUgaW5saW5lIGJsb2NrcyBvZiBjdXJseSBicmFjZXNcblxuICAgIHNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCAoZGVmYXVsdCB0cnVlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBiZSBhZGRlZCwgXCJpZih0cnVlKVwiIHZzIFwiaWYgKHRydWUpXCIsXG5cbiAgICB1bmVzY2FwZV9zdHJpbmdzIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCBwcmludGFibGUgY2hhcmFjdGVycyBpbiBzdHJpbmdzIGVuY29kZWQgaW4gXFx4Tk4gbm90YXRpb24gYmUgdW5lc2NhcGVkLCBcImV4YW1wbGVcIiB2cyBcIlxceDY1XFx4NzhcXHg2MVxceDZkXFx4NzBcXHg2Y1xceDY1XCJcblxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgdW5saW1pdGVkKSAtIGxpbmVzIHNob3VsZCB3cmFwIGF0IG5leHQgb3Bwb3J0dW5pdHkgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICBOT1RFOiBUaGlzIGlzIG5vdCBhIGhhcmQgbGltaXQuIExpbmVzIHdpbGwgY29udGludWUgdW50aWwgYSBwb2ludCB3aGVyZSBhIG5ld2xpbmUgd291bGRcbiAgICAgICAgICAgICAgICBiZSBwcmVzZXJ2ZWQgaWYgaXQgd2VyZSBwcmVzZW50LlxuXG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZGVmYXVsdCBmYWxzZSkgIC0gZW5kIG91dHB1dCB3aXRoIGEgbmV3bGluZVxuXG5cbiAgICBlLmdcblxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCdcbiAgICB9KTtcblxuKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4vKiBHRU5FUkFURURfQlVJTERfT1VUUFVUICovXG52YXIgbGVnYWN5X2JlYXV0aWZ5X2pzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmVhdXRpZmllciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQmVhdXRpZmllcixcbiAgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuT3B0aW9ucztcblxuZnVuY3Rpb24ganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5PdXRwdXQ7XG52YXIgVG9rZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLlRva2VuO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5PcHRpb25zO1xudmFyIFRva2VuaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oNykuVG9rZW5pemVyO1xudmFyIGxpbmVfc3RhcnRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLmxpbmVfc3RhcnRlcnM7XG52YXIgcG9zaXRpb25hYmxlX29wZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNykucG9zaXRpb25hYmxlX29wZXJhdG9ycztcbnZhciBUT0tFTiA9IF9fd2VicGFja19yZXF1aXJlX18oNykuVE9LRU47XG5cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih3aGF0KSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGx0cmltKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXlxccysvZywgJycpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGxpc3QubGVuZ3RoOyB4KyspIHtcbiAgICAvLyBtYWtlIHRoZSBtYXBwZWQgbmFtZXMgdW5kZXJzY29yZWQgaW5zdGVhZCBvZiBkYXNoXG4gICAgcmVzdWx0W2xpc3RbeF0ucmVwbGFjZSgvLS9nLCAnXycpXSA9IGxpc3RbeF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVzZXJ2ZWRfd29yZCh0b2tlbiwgd29yZCkge1xuICByZXR1cm4gdG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgdG9rZW4udGV4dCA9PT0gd29yZDtcbn1cblxuZnVuY3Rpb24gcmVzZXJ2ZWRfYXJyYXkodG9rZW4sIHdvcmRzKSB7XG4gIHJldHVybiB0b2tlbiAmJiB0b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheSh0b2tlbi50ZXh0LCB3b3Jkcyk7XG59XG4vLyBVbnN1cmUgb2Ygd2hhdCB0aGV5IG1lYW4sIGJ1dCB0aGV5IHdvcmsuIFdvcnRoIGNsZWFuaW5nIHVwIGluIGZ1dHVyZS5cbnZhciBzcGVjaWFsX3dvcmRzID0gWydjYXNlJywgJ3JldHVybicsICdkbycsICdpZicsICd0aHJvdycsICdlbHNlJywgJ2F3YWl0JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2FzeW5jJ107XG5cbnZhciB2YWxpZFBvc2l0aW9uVmFsdWVzID0gWydiZWZvcmUtbmV3bGluZScsICdhZnRlci1uZXdsaW5lJywgJ3ByZXNlcnZlLW5ld2xpbmUnXTtcblxuLy8gR2VuZXJhdGUgbWFwIGZyb20gYXJyYXlcbnZhciBPUEVSQVRPUl9QT1NJVElPTiA9IGdlbmVyYXRlTWFwRnJvbVN0cmluZ3ModmFsaWRQb3NpdGlvblZhbHVlcyk7XG5cbnZhciBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUgPSBbT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmUsIE9QRVJBVE9SX1BPU0lUSU9OLnByZXNlcnZlX25ld2xpbmVdO1xuXG52YXIgTU9ERSA9IHtcbiAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsIC8vICdCTE9DSydcbiAgU3RhdGVtZW50OiAnU3RhdGVtZW50JywgLy8gJ1NUQVRFTUVOVCdcbiAgT2JqZWN0TGl0ZXJhbDogJ09iamVjdExpdGVyYWwnLCAvLyAnT0JKRUNUJyxcbiAgQXJyYXlMaXRlcmFsOiAnQXJyYXlMaXRlcmFsJywgLy8nW0VYUFJFU1NJT05dJyxcbiAgRm9ySW5pdGlhbGl6ZXI6ICdGb3JJbml0aWFsaXplcicsIC8vJyhGT1ItRVhQUkVTU0lPTiknLFxuICBDb25kaXRpb25hbDogJ0NvbmRpdGlvbmFsJywgLy8nKENPTkQtRVhQUkVTU0lPTiknLFxuICBFeHByZXNzaW9uOiAnRXhwcmVzc2lvbicgLy8nKEVYUFJFU1NJT04pJ1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbihvdXRwdXQsIGZyYW1lKSB7XG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZWZmZWN0aXZlIGJ1dCBoYXMgc29tZSBpc3N1ZXM6XG4gIC8vICAgICAtIGNhbiBjYXVzZSBsaW5lIHdyYXAgdG8gaGFwcGVuIHRvbyBzb29uIGR1ZSB0byBpbmRlbnQgcmVtb3ZhbFxuICAvLyAgICAgICAgICAgYWZ0ZXIgd3JhcCBwb2ludHMgYXJlIGNhbGN1bGF0ZWRcbiAgLy8gVGhlc2UgaXNzdWVzIGFyZSBtaW5vciBjb21wYXJlZCB0byB1Z2x5IGluZGVudGF0aW9uLlxuXG4gIGlmIChmcmFtZS5tdWx0aWxpbmVfZnJhbWUgfHxcbiAgICBmcmFtZS5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8XG4gICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHJlbW92ZSBvbmUgaW5kZW50IGZyb20gZWFjaCBsaW5lIGluc2lkZSB0aGlzIHNlY3Rpb25cbiAgb3V0cHV0LnJlbW92ZV9pbmRlbnQoZnJhbWUuc3RhcnRfbGluZV9pbmRleCk7XG59XG5cbi8vIHdlIGNvdWxkIHVzZSBqdXN0IHN0cmluZy5zcGxpdCwgYnV0XG4vLyBJRSBkb2Vzbid0IGxpa2UgcmV0dXJuaW5nIGVtcHR5IHN0cmluZ3NcbmZ1bmN0aW9uIHNwbGl0X2xpbmVicmVha3Mocykge1xuICAvL3JldHVybiBzLnNwbGl0KC9cXHgwZFxceDBhfFxceDBhLyk7XG5cbiAgcyA9IHMucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gIHZhciBvdXQgPSBbXSxcbiAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gIHdoaWxlIChpZHggIT09IC0xKSB7XG4gICAgb3V0LnB1c2gocy5zdWJzdHJpbmcoMCwgaWR4KSk7XG4gICAgcyA9IHMuc3Vic3RyaW5nKGlkeCArIDEpO1xuICAgIGlkeCA9IHMuaW5kZXhPZihcIlxcblwiKTtcbiAgfVxuICBpZiAocy5sZW5ndGgpIHtcbiAgICBvdXQucHVzaChzKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBpc19hcnJheShtb2RlKSB7XG4gIHJldHVybiBtb2RlID09PSBNT0RFLkFycmF5TGl0ZXJhbDtcbn1cblxuZnVuY3Rpb24gaXNfZXhwcmVzc2lvbihtb2RlKSB7XG4gIHJldHVybiBpbl9hcnJheShtb2RlLCBbTU9ERS5FeHByZXNzaW9uLCBNT0RFLkZvckluaXRpYWxpemVyLCBNT0RFLkNvbmRpdGlvbmFsXSk7XG59XG5cbmZ1bmN0aW9uIGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLCBjKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICBpZiAobGluZS5jaGFyQXQoMCkgIT09IGMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgaW5kZW50KSB7XG4gIHZhciBpID0gMCxcbiAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXG4gICAgbGluZTtcbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAvLyBhbGxvdyBlbXB0eSBsaW5lcyB0byBwYXNzIHRocm91Z2hcbiAgICBpZiAobGluZSAmJiBsaW5lLmluZGV4T2YoaW5kZW50KSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9zb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0IHx8ICcnO1xuXG4gIHRoaXMuX291dHB1dCA9IG51bGw7XG4gIHRoaXMuX3Rva2VucyA9IG51bGw7XG4gIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c19mbGFncyA9IG51bGw7XG5cbiAgdGhpcy5fZmxhZ19zdG9yZSA9IG51bGw7XG4gIHRoaXMuX29wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zKTtcbn1cblxuQmVhdXRpZmllci5wcm90b3R5cGUuY3JlYXRlX2ZsYWdzID0gZnVuY3Rpb24oZmxhZ3NfYmFzZSwgbW9kZSkge1xuICB2YXIgbmV4dF9pbmRlbnRfbGV2ZWwgPSAwO1xuICBpZiAoZmxhZ3NfYmFzZSkge1xuICAgIG5leHRfaW5kZW50X2xldmVsID0gZmxhZ3NfYmFzZS5pbmRlbnRhdGlvbl9sZXZlbDtcbiAgICBpZiAoIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJlxuICAgICAgZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA+IG5leHRfaW5kZW50X2xldmVsKSB7XG4gICAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRfZmxhZ3MgPSB7XG4gICAgbW9kZTogbW9kZSxcbiAgICBwYXJlbnQ6IGZsYWdzX2Jhc2UsXG4gICAgbGFzdF90b2tlbjogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGFzdF90b2tlbiA6IG5ldyBUb2tlbihUT0tFTi5TVEFSVF9CTE9DSywgJycpLCAvLyBsYXN0IHRva2VuIHRleHRcbiAgICBsYXN0X3dvcmQ6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3Rfd29yZCA6ICcnLCAvLyBsYXN0IFRPS0VOLldPUkQgcGFzc2VkXG4gICAgZGVjbGFyYXRpb25fc3RhdGVtZW50OiBmYWxzZSxcbiAgICBkZWNsYXJhdGlvbl9hc3NpZ25tZW50OiBmYWxzZSxcbiAgICBtdWx0aWxpbmVfZnJhbWU6IGZhbHNlLFxuICAgIGlubGluZV9mcmFtZTogZmFsc2UsXG4gICAgaWZfYmxvY2s6IGZhbHNlLFxuICAgIGVsc2VfYmxvY2s6IGZhbHNlLFxuICAgIGRvX2Jsb2NrOiBmYWxzZSxcbiAgICBkb193aGlsZTogZmFsc2UsXG4gICAgaW1wb3J0X2Jsb2NrOiBmYWxzZSxcbiAgICBpbl9jYXNlX3N0YXRlbWVudDogZmFsc2UsIC8vIHN3aXRjaCguLil7IElOU0lERSBIRVJFIH1cbiAgICBpbl9jYXNlOiBmYWxzZSwgLy8gd2UncmUgb24gdGhlIGV4YWN0IGxpbmUgd2l0aCBcImNhc2UgMDpcIlxuICAgIGNhc2VfYm9keTogZmFsc2UsIC8vIHRoZSBpbmRlbnRlZCBjYXNlLWFjdGlvbiBibG9ja1xuICAgIGluZGVudGF0aW9uX2xldmVsOiBuZXh0X2luZGVudF9sZXZlbCxcbiAgICBhbGlnbm1lbnQ6IDAsXG4gICAgbGluZV9pbmRlbnRfbGV2ZWw6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsIDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgc3RhcnRfbGluZV9pbmRleDogdGhpcy5fb3V0cHV0LmdldF9saW5lX251bWJlcigpLFxuICAgIHRlcm5hcnlfZGVwdGg6IDBcbiAgfTtcbiAgcmV0dXJuIG5leHRfZmxhZ3M7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbihzb3VyY2VfdGV4dCkge1xuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID0gJyc7IC8vIHByZS1sYXN0IHRva2VuIHRleHRcbiAgdGhpcy5fb3V0cHV0ID0gbmV3IE91dHB1dCh0aGlzLl9vcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcblxuICAvLyBJZiB0ZXN0aW5nIHRoZSBpZ25vcmUgZGlyZWN0aXZlLCBzdGFydCB3aXRoIG91dHB1dCBkaXNhYmxlIHNldCB0byB0cnVlXG4gIHRoaXMuX291dHB1dC5yYXcgPSB0aGlzLl9vcHRpb25zLnRlc3Rfb3V0cHV0X3JhdztcblxuXG4gIC8vIFN0YWNrIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBzdGF0ZXMsIGluY2x1ZGluZyBNT0RFLlxuICAvLyBXZSB0b2tlbml6ZSwgcGFyc2UsIGFuZCBvdXRwdXQgaW4gYW4gYWxtb3N0IHB1cmVseSBhIGZvcndhcmQtb25seSBzdHJlYW0gb2YgdG9rZW4gaW5wdXRcbiAgLy8gYW5kIGZvcm1hdHRlZCBvdXRwdXQuICBUaGlzIG1ha2VzIHRoZSBiZWF1dGlmaWVyIGxlc3MgYWNjdXJhdGUgdGhhbiBmdWxsIHBhcnNlcnNcbiAgLy8gYnV0IGFsc28gZmFyIG1vcmUgdG9sZXJhbnQgb2Ygc3ludGF4IGVycm9ycy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IG1vZGUgaXMgTU9ERS5CbG9ja1N0YXRlbWVudC4gSWYgd2Ugc2VlIGEgJ3snIHdlIHB1c2ggYSBuZXcgZnJhbWUgb2YgdHlwZVxuICAvLyBNT0RFLkJsb2NrU3RhdGVtZW50IG9uIHRoZSB0aGUgc3RhY2ssIGV2ZW4gdGhvdWdoIGl0IGNvdWxkIGJlIG9iamVjdCBsaXRlcmFsLiAgSWYgd2UgbGF0ZXJcbiAgLy8gZW5jb3VudGVyIGEgXCI6XCIsIHdlJ2xsIHN3aXRjaCB0byB0byBNT0RFLk9iamVjdExpdGVyYWwuICBJZiB3ZSB0aGVuIHNlZSBhIFwiO1wiLFxuICAvLyBtb3N0IGZ1bGwgcGFyc2VycyB3b3VsZCBkaWUsIGJ1dCB0aGUgYmVhdXRpZmllciBncmFjZWZ1bGx5IGZhbGxzIGJhY2sgdG9cbiAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBhbmQgY29udGludWVzIG9uLlxuICB0aGlzLl9mbGFnX3N0b3JlID0gW107XG4gIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIHZhciB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHNvdXJjZV90ZXh0LCB0aGlzLl9vcHRpb25zKTtcbiAgdGhpcy5fdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKCk7XG4gIHJldHVybiBzb3VyY2VfdGV4dDtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGlmIGRpc2FibGVkLCByZXR1cm4gdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZTtcbiAgdmFyIHNvdXJjZV90ZXh0ID0gdGhpcy5fcmVzZXQodGhpcy5fc291cmNlX3RleHQpO1xuXG4gIHZhciBlb2wgPSB0aGlzLl9vcHRpb25zLmVvbDtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgYWNvcm4ubGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChhY29ybi5saW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50X3Rva2VuID0gdGhpcy5fdG9rZW5zLm5leHQoKTtcbiAgd2hpbGUgKGN1cnJlbnRfdG9rZW4pIHtcbiAgICB0aGlzLmhhbmRsZV90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0O1xuICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4gPSBjdXJyZW50X3Rva2VuO1xuXG4gICAgY3VycmVudF90b2tlbiA9IHRoaXMuX3Rva2Vucy5uZXh0KCk7XG4gIH1cblxuICBzd2VldF9jb2RlID0gdGhpcy5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfdG9rZW4gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgIHRoaXMuaGFuZGxlX3N0YXJ0X2V4cHIoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuaGFuZGxlX2VuZF9leHByKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICB0aGlzLmhhbmRsZV9zdGFydF9ibG9jayhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSykge1xuICAgIHRoaXMuaGFuZGxlX2VuZF9ibG9jayhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICB0aGlzLmhhbmRsZV93b3JkKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICB0aGlzLmhhbmRsZV93b3JkKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU0VNSUNPTE9OKSB7XG4gICAgdGhpcy5oYW5kbGVfc2VtaWNvbG9uKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RSSU5HKSB7XG4gICAgdGhpcy5oYW5kbGVfc3RyaW5nKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7XG4gICAgdGhpcy5oYW5kbGVfZXF1YWxzKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICB0aGlzLmhhbmRsZV9vcGVyYXRvcihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSB7XG4gICAgdGhpcy5oYW5kbGVfY29tbWEoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5CTE9DS19DT01NRU5UKSB7XG4gICAgdGhpcy5oYW5kbGVfYmxvY2tfY29tbWVudChjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCkge1xuICAgIHRoaXMuaGFuZGxlX2NvbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkRPVCkge1xuICAgIHRoaXMuaGFuZGxlX2RvdChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVPRikge1xuICAgIHRoaXMuaGFuZGxlX2VvZihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlVOS05PV04pIHtcbiAgICB0aGlzLmhhbmRsZV91bmtub3duKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfdW5rbm93bihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgdmFyIG5ld2xpbmVzID0gY3VycmVudF90b2tlbi5uZXdsaW5lcztcbiAgdmFyIGtlZXBfd2hpdGVzcGFjZSA9IHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJiBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKTtcblxuICBpZiAoY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpIHtcbiAgICB2YXIgY29tbWVudF90b2tlbiA9IGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLm5leHQoKTtcbiAgICB3aGlsZSAoY29tbWVudF90b2tlbikge1xuICAgICAgLy8gVGhlIGNsZWFuZXN0IGhhbmRsaW5nIG9mIGlubGluZSBjb21tZW50cyBpcyB0byB0cmVhdCB0aGVtIGFzIHRob3VnaCB0aGV5IGFyZW4ndCB0aGVyZS5cbiAgICAgIC8vIEp1c3QgY29udGludWUgZm9ybWF0dGluZyBhbmQgdGhlIGJlaGF2aW9yIHNob3VsZCBiZSBsb2dpY2FsLlxuICAgICAgLy8gQWxzbyBpZ25vcmUgdW5rbm93biB0b2tlbnMuICBBZ2FpbiwgdGhpcyBzaG91bGQgcmVzdWx0IGluIGJldHRlciBiZWhhdmlvci5cbiAgICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGNvbW1lbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICB0aGlzLmhhbmRsZV90b2tlbihjb21tZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgY29tbWVudF90b2tlbiA9IGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2VlcF93aGl0ZXNwYWNlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdsaW5lczsgaSArPSAxKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoaSA+IDAsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBuZXdsaW5lcyA+IHRoaXMuX29wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICBuZXdsaW5lcyA9IHRoaXMuX29wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICBpZiAobmV3bGluZXMgPiAxKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBuZXdsaW5lczsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKHRydWUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxudmFyIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMgPSBbJ2FzeW5jJywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ3JldHVybicsICd0aHJvdycsICd5aWVsZCddO1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgZm9yY2VfbGluZXdyYXApIHtcbiAgZm9yY2VfbGluZXdyYXAgPSAoZm9yY2VfbGluZXdyYXAgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGZvcmNlX2xpbmV3cmFwO1xuXG4gIC8vIE5ldmVyIHdyYXAgdGhlIGZpcnN0IHRva2VuIG9uIGEgbGluZVxuICBpZiAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNob3VsZFByZXNlcnZlT3JGb3JjZSA9ICh0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpIHx8IGZvcmNlX2xpbmV3cmFwO1xuICB2YXIgb3BlcmF0b3JMb2dpY0FwcGxpZXMgPSBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpIHx8XG4gICAgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcblxuICBpZiAob3BlcmF0b3JMb2dpY0FwcGxpZXMpIHtcbiAgICB2YXIgc2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmUgPSAoXG4gICAgICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycykgJiZcbiAgICAgICAgaW5fYXJyYXkodGhpcy5fb3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKVxuICAgICAgKSB8fFxuICAgICAgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcbiAgICBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgJiYgc2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmU7XG4gIH1cblxuICBpZiAoc2hvdWxkUHJlc2VydmVPckZvcmNlKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykpIHtcbiAgICAgIC8vIFRoZXNlIHRva2VucyBzaG91bGQgbmV2ZXIgaGF2ZSBhIG5ld2xpbmUgaW5zZXJ0ZWRcbiAgICAgIC8vIGJldHdlZW4gdGhlbSBhbmQgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vdXRwdXQuc2V0X3dyYXBfcG9pbnQoKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfbmV3bGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICBpZiAoIXByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICc7JyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcsJyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICc9JyAmJiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICctLScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKysnKSkge1xuICAgICAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICAgICAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgICAgICEodGhpcy5fZmxhZ3MuaWZfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChuZXh0X3Rva2VuLCAnZWxzZScpKSAmJlxuICAgICAgICAhdGhpcy5fZmxhZ3MuZG9fYmxvY2spIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZShmb3JjZV9uZXdsaW5lKSkge1xuICAgIHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRydWU7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uICYmXG4gICAgICBjdXJyZW50X3Rva2VuLm5ld2xpbmVzICYmXG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnWycgfHwgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkpKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5wdXNoKGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCkpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmxpbmVfaW5kZW50X2xldmVsID0gdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgfVxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF90b2tlbiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuX291dHB1dC5yYXcpIHtcbiAgICB0aGlzLl9vdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fb3B0aW9ucy5jb21tYV9maXJzdCAmJiBjdXJyZW50X3Rva2VuLnByZXZpb3VzICYmIGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uQ09NTUEgJiZcbiAgICB0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUubGFzdCgpID09PSAnLCcpIHtcbiAgICAgIHZhciBwb3BwZWQgPSB0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5wb3AoKTtcbiAgICAgIC8vIGlmIHRoZSBjb21tYSB3YXMgYWxyZWFkeSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUsXG4gICAgICAvLyBwdWxsIGJhY2sgb250byB0aGF0IGxpbmUgYW5kIHJlcHJpbnQgdGhlIGluZGVudGF0aW9uXG4gICAgICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5wdXNoKHBvcHBlZCk7XG4gICAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnBvcCgpO1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIGNvbW1hIGluIGZyb250IG9mIHRoZSBuZXh0IHRva2VuXG4gICAgICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKCcsJyk7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5ub25fYnJlYWtpbmdfc3BhY2UgPSB0cnVlO1xuICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGN1cnJlbnRfdG9rZW4udGV4dCk7XG4gIGlmICh0aGlzLl9vdXRwdXQucHJldmlvdXNfdG9rZW5fd3JhcHBlZCkge1xuICAgIHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRydWU7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCArPSAxO1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmRlaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IDAgJiZcbiAgICAoKCF0aGlzLl9mbGFncy5wYXJlbnQpIHx8IHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsID4gdGhpcy5fZmxhZ3MucGFyZW50LmluZGVudGF0aW9uX2xldmVsKSkge1xuICAgIHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsIC09IDE7XG4gICAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnNldF9tb2RlID0gZnVuY3Rpb24obW9kZSkge1xuICBpZiAodGhpcy5fZmxhZ3MpIHtcbiAgICB0aGlzLl9mbGFnX3N0b3JlLnB1c2godGhpcy5fZmxhZ3MpO1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gdGhpcy5fZmxhZ3M7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSB0aGlzLmNyZWF0ZV9mbGFncyhudWxsLCBtb2RlKTtcbiAgfVxuXG4gIHRoaXMuX2ZsYWdzID0gdGhpcy5jcmVhdGVfZmxhZ3ModGhpcy5fcHJldmlvdXNfZmxhZ3MsIG1vZGUpO1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbn07XG5cblxuQmVhdXRpZmllci5wcm90b3R5cGUucmVzdG9yZV9tb2RlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mbGFnX3N0b3JlLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncyA9IHRoaXMuX2ZsYWdzO1xuICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ19zdG9yZS5wb3AoKTtcbiAgICBpZiAodGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24odGhpcy5fb3V0cHV0LCB0aGlzLl9wcmV2aW91c19mbGFncyk7XG4gICAgfVxuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2ZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgKFxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB8fCAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0J10pKSk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zdGFydF9vZl9zdGF0ZW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHZhciBzdGFydCA9IGZhbHNlO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQ7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgcmVzZXJ2ZWRfd29yZCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCAnZG8nKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAoISh0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSkgJiYgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykgJiYgIWN1cnJlbnRfdG9rZW4ubmV3bGluZXM7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgcmVzZXJ2ZWRfd29yZCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCAnZWxzZScpICYmXG4gICAgIShyZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdpZicpICYmICFjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZSk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgJiYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuRm9ySW5pdGlhbGl6ZXIgfHwgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJlxuICAgICF0aGlzLl9mbGFncy5pbl9jYXNlICYmXG4gICAgIShjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSAmJlxuICAgIHRoaXMuX2xhc3RfbGFzdF90ZXh0ICE9PSAnZnVuY3Rpb24nICYmXG4gICAgY3VycmVudF90b2tlbi50eXBlICE9PSBUT0tFTi5XT1JEICYmIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gVE9LRU4uUkVTRVJWRUQpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgKFxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB8fCByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ2dldCcsICdzZXQnXSkpKTtcblxuICBpZiAoc3RhcnQpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuU3RhdGVtZW50KTtcbiAgICB0aGlzLmluZGVudCgpO1xuXG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgICAvLyBJc3N1ZSAjMjc2OlxuICAgIC8vIElmIHN0YXJ0aW5nIGEgbmV3IHN0YXRlbWVudCB3aXRoIFtpZiwgZm9yLCB3aGlsZSwgZG9dLCBwdXNoIHRvIGEgbmV3IGxpbmUuXG4gICAgLy8gaWYgKGEpIGlmIChiKSBpZihjKSBkKCk7IGVsc2UgZSgpOyBlbHNlIGYoKTtcbiAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLFxuICAgICAgICByZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2RvJywgJ2ZvcicsICdpZicsICd3aGlsZSddKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zdGFydF9leHByID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIGlmICghdGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIHZhciBuZXh0X21vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdbJykge1xuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcpJykge1xuICAgICAgLy8gdGhpcyBpcyBhcnJheSBpbmRleCBzcGVjaWZpZXIsIGJyZWFrIGltbWVkaWF0ZWx5XG4gICAgICAvLyBhW3hdLCBmbigpW3hdXG4gICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbGluZV9zdGFydGVycykpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgdGhpcy5zZXRfbW9kZShuZXh0X21vZGUpO1xuICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRfbW9kZSA9IE1PREUuQXJyYXlMaXRlcmFsO1xuICAgIGlmIChpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ1snIHx8XG4gICAgICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcsJyAmJiAodGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICddJyB8fCB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ30nKSkpIHtcbiAgICAgICAgLy8gXSwgWyBnb2VzIHRvIG5ldyBsaW5lXG4gICAgICAgIC8vIH0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5FTkRfRVhQUiwgVE9LRU4uV09SRCwgVE9LRU4uT1BFUkFUT1JdKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZm9yJykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw7XG4gICAgICAgIG5leHRfbW9kZSA9IE1PREUuRm9ySW5pdGlhbGl6ZXI7XG4gICAgICB9IGVsc2UgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWydpZicsICd3aGlsZSddKSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw7XG4gICAgICAgIG5leHRfbW9kZSA9IE1PREUuQ29uZGl0aW9uYWw7XG4gICAgICB9IGVsc2UgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCwgWydhd2FpdCcsICdhc3luYyddKSkge1xuICAgICAgICAvLyBTaG91bGQgYmUgYSBzcGFjZSBiZXR3ZWVuIGF3YWl0IGFuZCBhbiBJSUZFLCBvciBhc3luYyBhbmQgYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcgJiYgY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9PT0gJycpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIGxpbmVfc3RhcnRlcnMpIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2NhdGNoJykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICAgIC8vIFN1cHBvcnQgb2YgdGhpcyBraW5kIG9mIG5ld2xpbmUgcHJlc2VydmF0aW9uLlxuICAgICAgLy8gYSA9IChiICYmXG4gICAgICAvLyAgICAgKGMgfHwgZCkpO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuXG4gICAgICAvLyBmdW5jdGlvbiBuYW1lKCkgdnMgZnVuY3Rpb24gbmFtZSAoKVxuICAgICAgLy8gZnVuY3Rpb24qIG5hbWUoKSB2cyBmdW5jdGlvbiogbmFtZSAoKVxuICAgICAgLy8gYXN5bmMgbmFtZSgpIHZzIGFzeW5jIG5hbWUgKClcbiAgICAgIC8vIEluIEVTNiwgeW91IGNhbiBhbHNvIGRlZmluZSB0aGUgbWV0aG9kIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG4gICAgICAvLyB2YXIgb2JqID0ge2E6IGZ1bmN0aW9uKCkge319XG4gICAgICAvLyBJdCBjYW4gYmUgYWJicmV2aWF0ZWRcbiAgICAgIC8vIHZhciBvYmogPSB7YSgpIHt9fVxuICAgICAgLy8gdmFyIG9iaiA9IHsgYSgpIHt9fSB2cyB2YXIgb2JqID0geyBhICgpIHt9fVxuICAgICAgLy8gdmFyIG9iaiA9IHsgKiBhKCkge319IHZzIHZhciBvYmogPSB7ICogYSAoKSB7fX1cbiAgICAgIHZhciBwZWVrX2JhY2tfdHdvID0gdGhpcy5fdG9rZW5zLnBlZWsoLTMpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfYWZ0ZXJfbmFtZWRfZnVuY3Rpb24gJiYgcGVla19iYWNrX3R3bykge1xuICAgICAgICAvLyBwZWVrIHN0YXJ0cyBhdCBuZXh0IGNoYXJhY3RlciBzbyAtMSBpcyBjdXJyZW50IHRva2VuXG4gICAgICAgIHZhciBwZWVrX2JhY2tfdGhyZWUgPSB0aGlzLl90b2tlbnMucGVlaygtNCk7XG4gICAgICAgIGlmIChyZXNlcnZlZF9hcnJheShwZWVrX2JhY2tfdHdvLCBbJ2FzeW5jJywgJ2Z1bmN0aW9uJ10pIHx8XG4gICAgICAgICAgKHBlZWtfYmFja190d28udGV4dCA9PT0gJyonICYmIHJlc2VydmVkX2FycmF5KHBlZWtfYmFja190aHJlZSwgWydhc3luYycsICdmdW5jdGlvbiddKSkpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoKHBlZWtfYmFja190d28udGV4dCA9PT0gJ3snIHx8IHBlZWtfYmFja190d28udGV4dCA9PT0gJywnKSB8fFxuICAgICAgICAgICAgKHBlZWtfYmFja190d28udGV4dCA9PT0gJyonICYmIChwZWVrX2JhY2tfdGhyZWUudGV4dCA9PT0gJ3snIHx8IHBlZWtfYmFja190aHJlZS50ZXh0ID09PSAnLCcpKSkge1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgcHJlc2VydmluZyB3cmFwcGVkIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25zXG4gICAgICAvLyBhLmIoJ2MnLFxuICAgICAgLy8gICAgICgpID0+IGQuZVxuICAgICAgLy8gKVxuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uKCkgdnMgZnVuY3Rpb24gKClcbiAgICAvLyB5aWVsZCooKSB2cyB5aWVsZCogKClcbiAgICAvLyBmdW5jdGlvbiooKSB2cyBmdW5jdGlvbiogKClcbiAgICBpZiAoKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgKHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyB8fCB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICd0eXBlb2YnKSkgfHxcbiAgICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgICAgICAoaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkgfHxcbiAgICAgICAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbjtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOycgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJy4nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEpIHtcbiAgICAvLyBkbyBub3RoaW5nIG9uICgoIGFuZCApKCBhbmQgXVsgYW5kIF0oIGFuZCAuKFxuICAgIC8vIFRPRE86IENvbnNpZGVyIHdoZXRoZXIgZm9yY2luZyB0aGlzIGlzIHJlcXVpcmVkLiAgUmV2aWV3IGZhaWxpbmcgdGVzdHMgd2hlbiByZW1vdmVkLlxuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLCBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKTtcbiAgfVxuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEluIGFsbCBjYXNlcywgaWYgd2UgbmV3bGluZSB3aGlsZSBpbnNpZGUgYW4gZXhwcmVzc2lvbiBpdCBzaG91bGQgYmUgaW5kZW50ZWQuXG4gIHRoaXMuaW5kZW50KCk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZW5kX2V4cHIgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIC8vIHN0YXRlbWVudHMgaW5zaWRlIGV4cHJlc3Npb25zIGFyZSBub3QgdmFsaWQgc3ludGF4LCBidXQuLi5cbiAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICBpZiAodGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lKSB7XG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sXG4gICAgICBjdXJyZW50X3Rva2VuLnRleHQgPT09ICddJyAmJiBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSAmJiAhdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiAmJiAhdGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9lbXB0eV9wYXJlbikge1xuICAgICAgLy8gKCkgW10gbm8gaW5uZXIgc3BhY2UgaW4gZW1wdHkgcGFyZW5zIGxpa2UgdGhlc2UsIGV2ZXIsIHJlZiAjMzIwXG4gICAgICB0aGlzLl9vdXRwdXQudHJpbSgpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdGhpcy5kZWluZGVudCgpO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuXG4gIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24odGhpcy5fb3V0cHV0LCB0aGlzLl9wcmV2aW91c19mbGFncyk7XG5cbiAgLy8gZG8ge30gd2hpbGUgKCkgLy8gbm8gc3RhdGVtZW50IHJlcXVpcmVkIGFmdGVyXG4gIGlmICh0aGlzLl9mbGFncy5kb193aGlsZSAmJiB0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgICB0aGlzLl9mbGFncy5kb19ibG9jayA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsYWdzLmRvX3doaWxlID0gZmFsc2U7XG5cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3N0YXJ0X2Jsb2NrID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgT2JqZWN0TGl0ZXJhbFxuICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gIHZhciBzZWNvbmRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygxKTtcbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9PT0gJ3N3aXRjaCcgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZV9zdGF0ZW1lbnQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmNhc2VfYm9keSkge1xuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIH0gZWxzZSBpZiAoc2Vjb25kX3Rva2VuICYmIChcbiAgICAgIChpbl9hcnJheShzZWNvbmRfdG9rZW4udGV4dCwgWyc6JywgJywnXSkgJiYgaW5fYXJyYXkobmV4dF90b2tlbi50eXBlLCBbVE9LRU4uU1RSSU5HLCBUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pKSB8fFxuICAgICAgKGluX2FycmF5KG5leHRfdG9rZW4udGV4dCwgWydnZXQnLCAnc2V0JywgJy4uLiddKSAmJiBpbl9hcnJheShzZWNvbmRfdG9rZW4udHlwZSwgW1RPS0VOLldPUkQsIFRPS0VOLlJFU0VSVkVEXSkpXG4gICAgKSkge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgVHlwZVNjcmlwdCxidXQgd2UgZGlkbid0IGJyZWFrIGl0IGZvciBhIHZlcnkgbG9uZyB0aW1lLlxuICAgIC8vIFdlJ2xsIHRyeSB0byBrZWVwIG5vdCBicmVha2luZyBpdC5cbiAgICBpZiAoIWluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2NsYXNzJywgJ2ludGVyZmFjZSddKSkge1xuICAgICAgdGhpcy5zZXRfbW9kZShNT0RFLk9iamVjdExpdGVyYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJz0+Jykge1xuICAgIC8vIGFycm93IGZ1bmN0aW9uOiAocGFyYW0xLCBwYXJhbU4pID0+IHsgc3RhdGVtZW50cyB9XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5FUVVBTFMsIFRPS0VOLlNUQVJUX0VYUFIsIFRPS0VOLkNPTU1BLCBUT0tFTi5PUEVSQVRPUl0pIHx8XG4gICAgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydyZXR1cm4nLCAndGhyb3cnLCAnaW1wb3J0JywgJ2RlZmF1bHQnXSlcbiAgKSB7XG4gICAgLy8gRGV0ZWN0aW5nIHNob3J0aGFuZCBmdW5jdGlvbiBzeW50YXggaXMgZGlmZmljdWx0IGJ5IHNjYW5uaW5nIGZvcndhcmQsXG4gICAgLy8gICAgIHNvIGNoZWNrIHRoZSBzdXJyb3VuZGluZyBjb250ZXh0LlxuICAgIC8vIElmIHRoZSBibG9jayBpcyBiZWluZyByZXR1cm5lZCwgaW1wb3J0ZWQsIGV4cG9ydCBkZWZhdWx0LCBwYXNzZWQgYXMgYXJnLFxuICAgIC8vICAgICBhc3NpZ25lZCB3aXRoID0gb3IgYXNzaWduZWQgaW4gYSBuZXN0ZWQgb2JqZWN0LCB0cmVhdCBhcyBhbiBPYmplY3RMaXRlcmFsLlxuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB9XG5cbiAgdmFyIGVtcHR5X2JyYWNlcyA9ICFuZXh0X3Rva2VuLmNvbW1lbnRzX2JlZm9yZSAmJiBuZXh0X3Rva2VuLnRleHQgPT09ICd9JztcbiAgdmFyIGVtcHR5X2Fub255bW91c19mdW5jdGlvbiA9IGVtcHR5X2JyYWNlcyAmJiB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLmJyYWNlX3ByZXNlcnZlX2lubGluZSkgLy8gY2hlY2sgZm9yIGlubGluZSwgc2V0IGlubGluZV9mcmFtZSBpZiBzb1xuICB7XG4gICAgLy8gc2VhcmNoIGZvcndhcmQgZm9yIGEgbmV3bGluZSB3YW50ZWQgaW5zaWRlIHRoaXMgYmxvY2tcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjaGVja190b2tlbiA9IG51bGw7XG4gICAgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lID0gdHJ1ZTtcbiAgICBkbyB7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgY2hlY2tfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlayhpbmRleCAtIDEpO1xuICAgICAgaWYgKGNoZWNrX3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGVja190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiZcbiAgICAgICEoY2hlY2tfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLICYmIGNoZWNrX3Rva2VuLm9wZW5lZCA9PT0gY3VycmVudF90b2tlbikpO1xuICB9XG5cbiAgaWYgKCh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcykpICYmXG4gICAgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SICYmXG4gICAgICAoZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uIHx8XG4gICAgICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8XG4gICAgICAgIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICdlbHNlJykpKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIGNvbGxhcHNlIHx8IGlubGluZV9mcmFtZVxuICAgIGlmIChpc19hcnJheSh0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlKSAmJiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEpKSB7XG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCB0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSICYmIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkpIHtcbiAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9wcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0aGlzLl9wcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWUgfHwgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lO1xuICAgICAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5TVEFSVF9FWFBSKSB7XG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSyAmJiAhdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuaW5kZW50KCk7XG5cbiAgLy8gRXhjZXB0IGZvciBzcGVjaWZpYyBjYXNlcywgb3BlbiBicmFjZXMgYXJlIGZvbGxvd2VkIGJ5IGEgbmV3IGxpbmUuXG4gIGlmICghZW1wdHlfYnJhY2VzICYmICEodGhpcy5fb3B0aW9ucy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgJiYgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZW5kX2Jsb2NrID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuXG4gIHZhciBlbXB0eV9icmFjZXMgPSB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLO1xuXG4gIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgJiYgIWVtcHR5X2JyYWNlcykgeyAvLyB0cnkgaW5saW5lX2ZyYW1lIChvbmx5IHNldCBpZiB0aGlzLl9vcHRpb25zLmJyYWNlcy1wcmVzZXJ2ZS1pbmxpbmUpIGZpcnN0XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIikge1xuICAgIGlmICghZW1wdHlfYnJhY2VzKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gc2tpcCB7fVxuICAgIGlmICghZW1wdHlfYnJhY2VzKSB7XG4gICAgICBpZiAoaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uKSB7XG4gICAgICAgIC8vIHdlIFJFQUxMWSBuZWVkIGEgbmV3bGluZSBoZXJlLCBidXQgbmV3bGluZXIgd291bGQgc2tpcCB0aGF0XG4gICAgICAgIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfd29yZCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ3NldCcsICdnZXQnXSkgJiYgdGhpcy5fZmxhZ3MubW9kZSAhPT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaW1wb3J0JyAmJiB0aGlzLl90b2tlbnMucGVlaygpLnRleHQgPT09ICcoJykge1xuICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydhcycsICdmcm9tJ10pICYmICF0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgICAgIGlmIChuZXh0X3Rva2VuLnRleHQgPT09ICc6Jykge1xuICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJiAhaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSAmJlxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SIHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICctLScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKysnKSkgJiZcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVRVUFMUyAmJlxuICAgICh0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzIHx8ICFyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnLCAnc2V0JywgJ2dldCddKSkpIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5kb19ibG9jayAmJiAhdGhpcy5fZmxhZ3MuZG9fd2hpbGUpIHtcbiAgICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnd2hpbGUnKSkge1xuICAgICAgLy8gZG8ge30gIyMgd2hpbGUgKClcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5fZmxhZ3MuZG9fd2hpbGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyB7fSBzaG91bGQgYWx3YXlzIGhhdmUgd2hpbGUgYXMgdGhlIG5leHQgd29yZC5cbiAgICAgIC8vIGlmIHdlIGRvbid0IHNlZSB0aGUgZXhwZWN0ZWQgd2hpbGUsIHJlY292ZXJcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgdGhpcy5fZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBtYXkgYmUgZm9sbG93ZWQgYnkgZWxzZSwgb3Igbm90XG4gIC8vIEJhcmUvaW5saW5lIGlmcyBhcmUgdHJpY2t5XG4gIC8vIE5lZWQgdG8gdW53aW5kIHRoZSBtb2RlcyBjb3JyZWN0bHk6IGlmIChhKSBpZiAoYikgYygpOyBlbHNlIGQoKTsgZWxzZSBlKCk7XG4gIGlmICh0aGlzLl9mbGFncy5pZl9ibG9jaykge1xuICAgIGlmICghdGhpcy5fZmxhZ3MuZWxzZV9ibG9jayAmJiByZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdlbHNlJykpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmVsc2VfYmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZsYWdzLmlmX2Jsb2NrID0gZmFsc2U7XG4gICAgICB0aGlzLl9mbGFncy5lbHNlX2Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50ICYmIHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnY2FzZScsICdkZWZhdWx0J10pKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU5EX0JMT0NLICYmICh0aGlzLl9mbGFncy5jYXNlX2JvZHkgfHwgdGhpcy5fb3B0aW9ucy5qc2xpbnRfaGFwcHkpKSB7XG4gICAgICAvLyBzd2l0Y2ggY2FzZXMgZm9sbG93aW5nIG9uZSBhbm90aGVyXG4gICAgICB0aGlzLmRlaW5kZW50KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZsYWdzLmNhc2VfYm9keSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLl9mbGFncy5pbl9jYXNlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikge1xuICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWyd9JywgJzsnXSkgfHxcbiAgICAgICh0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiYgIShpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnKCcsICdbJywgJ3snLCAnOicsICc9JywgJywnXSkgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikpKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgYSBuaWNlIGNsZWFuIHNwYWNlIG9mIGF0IGxlYXN0IG9uZSBibGFuayBsaW5lXG4gICAgICAvLyBiZWZvcmUgYSBuZXcgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgaWYgKCF0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9ibGFua2xpbmUoKSAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0JywgJ25ldycsICdleHBvcnQnXSkgfHxcbiAgICAgICAgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2RlZmF1bHQnKSAmJiB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2RlY2xhcmUnKSB7XG4gICAgICAgIC8vIGFjY29tb2RhdGVzIFR5cGVzY3JpcHQgZGVjbGFyZSBmdW5jdGlvbiBmb3JtYXR0aW5nXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJz0nKSB7XG4gICAgICAvLyBmb28gPSBmdW5jdGlvblxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lICYmIChpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpIHx8IGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpKSkge1xuICAgICAgLy8gKGZ1bmN0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cblxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fZmxhZ3MubGFzdF93b3JkID0gY3VycmVudF90b2tlbi50ZXh0O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmVmaXggPSAnTk9ORSc7XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLKSB7XG5cbiAgICBpZiAodGhpcy5fcHJldmlvdXNfZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgIH0gZWxzZSBpZiAoIXJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5JywgJ2Zyb20nXSkpIHtcbiAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSB7XG4gICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTiAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgZm9yIFNUQVRFTUVOVCBhcyB3ZWxsP1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTiAmJiBpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpKSB7XG4gICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUUklORykge1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fFxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgICAgKGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsneycsICcsJ10pKSkpKSB7XG4gICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIGxpbmVfc3RhcnRlcnMpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJyknKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdlbHNlJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgfVxuXG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydlbHNlJywgJ2NhdGNoJywgJ2ZpbmFsbHknXSkpIHtcbiAgICBpZiAoKCEodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgJiYgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICB0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImVuZC1leHBhbmRcIiB8fFxuICAgICAgICAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcykpICYmXG4gICAgICAhdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmU7XG4gICAgICAvLyBJZiB3ZSB0cmltbWVkIGFuZCB0aGVyZSdzIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgY2xvc2UgYmxvY2sgYmVmb3JlIHVzXG4gICAgICAvLyBwdXQgYSBuZXdsaW5lIGJhY2sgaW4uICBIYW5kbGVzICd9IC8vIGNvbW1lbnQnIHNjZW5hcmlvLlxuICAgICAgaWYgKGxpbmUubGFzdCgpICE9PSAnfScpIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJlZml4ID09PSAnTkVXTElORScpIHtcbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykpIHtcbiAgICAgIC8vIG5vIG5ld2xpbmUgYmV0d2VlbiAncmV0dXJuIG5ubidcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZGVjbGFyZScgJiYgcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pKSB7XG4gICAgICAvLyBhY2NvbW9kYXRlcyBUeXBlc2NyaXB0IGRlY2xhcmUgZm9ybWF0dGluZ1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgICBpZiAoKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uU1RBUlRfRVhQUiB8fCAhcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICc6Jykge1xuICAgICAgICAvLyBubyBuZWVkIHRvIGZvcmNlIG5ld2xpbmUgb24gJ3Zhcic6IGZvciAodmFyIHggPSAwLi4uKVxuICAgICAgICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnaWYnKSAmJiByZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMsICdlbHNlJykpIHtcbiAgICAgICAgICAvLyBubyBuZXdsaW5lIGZvciB9IGVsc2UgaWYge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBsaW5lX3N0YXJ0ZXJzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcpJykge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcsJyAmJiB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ30nKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7IC8vIH0sIGluIGxpc3RzIGdldCBhIG5ld2xpbmUgdHJlYXRtZW50XG4gIH0gZWxzZSBpZiAocHJlZml4ID09PSAnU1BBQ0UnKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cbiAgaWYgKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMgJiYgKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uV09SRCB8fCBjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcblxuICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdkbycpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJykge1xuICAgICAgdGhpcy5fZmxhZ3MuaWZfYmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaW1wb3J0Jykge1xuICAgICAgdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayAmJiByZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdmcm9tJykpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3NlbWljb2xvbiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgIC8vIFNlbWljb2xvbiBjYW4gYmUgdGhlIHN0YXJ0IChhbmQgZW5kKSBvZiBhIHN0YXRlbWVudFxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgISh0aGlzLl9mbGFncy5pZl9ibG9jayAmJiByZXNlcnZlZF93b3JkKG5leHRfdG9rZW4sICdlbHNlJykpICYmXG4gICAgIXRoaXMuX2ZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuXG4gIC8vIGhhY2t5IGJ1dCBlZmZlY3RpdmUgZm9yIHRoZSBtb21lbnRcbiAgaWYgKHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jaykge1xuICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IGZhbHNlO1xuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc3RyaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgLy8gT25lIGRpZmZlcmVuY2UgLSBzdHJpbmdzIHdhbnQgYXQgbGVhc3QgYSBzcGFjZSBiZWZvcmVcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VxdWFscyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCkge1xuICAgIC8vIGp1c3QgZ290IGFuICc9JyBpbiBhIHZhci1saW5lLCBkaWZmZXJlbnQgZm9ybWF0dGluZy9saW5lLWJyZWFraW5nLCBldGMgd2lsbCBub3cgYmUgZG9uZVxuICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSB0cnVlO1xuICB9XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9jb21tYSA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICBpZiAoaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5wYXJlbnQubW9kZSkpIHtcbiAgICAgIC8vIGRvIG5vdCBicmVhayBvbiBjb21tYSwgZm9yKHZhciBhID0gMSwgYiA9IDIpXG4gICAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNvbW1hX2ZpcnN0KSB7XG4gICAgICAvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCB8fFxuICAgICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiB0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSkge1xuICAgIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY29tbWFfZmlyc3QpIHtcbiAgICAvLyBFWFBSIG9yIERPX0JMT0NLXG4gICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgLy8gdG8gdHVybiBpbnRvIGEgbmV3bGluZSBhZnRlciB0aGUgY29tbWEsIHdoaWNoIHdlIHdpbGwgZml4dXAgbGF0ZXJcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9vcGVyYXRvciA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdmFyIGlzR2VuZXJhdG9yQXN0ZXJpc2sgPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLkNPTU1BLCBUT0tFTi5FTkRfQkxPQ0ssIFRPS0VOLlNFTUlDT0xPTl0pKVxuICAgICk7XG4gIHZhciBpc1VuYXJ5ID0gaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0nLCAnKyddKSAmJiAoXG4gICAgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLlNUQVJUX0VYUFIsIFRPS0VOLkVRVUFMUywgVE9LRU4uT1BFUkFUT1JdKSB8fFxuICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgbGluZV9zdGFydGVycykgfHxcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcsJ1xuICApO1xuXG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzID0gIWlzR2VuZXJhdG9yQXN0ZXJpc2s7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSkge1xuICAgIC8vIFwicmV0dXJuXCIgaGFkIGEgc3BlY2lhbCBoYW5kbGluZyBpbiBUS19XT1JELiBOb3cgd2UgbmVlZCB0byByZXR1cm4gdGhlIGZhdm9yXG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYWNrIGZvciBhY3Rpb25zY3JpcHQncyBpbXBvcnQgLio7XG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkRPVCkge1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzo6Jykge1xuICAgIC8vIG5vIHNwYWNlcyBhcm91bmQgZXhvdGljIG5hbWVzcGFjaW5nIHN5bnRheCBvcGVyYXRvclxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWxsb3cgbGluZSB3cmFwcGluZyBiZXR3ZWVuIG9wZXJhdG9ycyB3aGVuIG9wZXJhdG9yX3Bvc2l0aW9uIGlzXG4gIC8vICAgc2V0IHRvIGJlZm9yZSBvciBwcmVzZXJ2ZVxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiAmJiBpbl9hcnJheSh0aGlzLl9vcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uLCBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpKSB7XG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonICYmIHRoaXMuX2ZsYWdzLmluX2Nhc2UpIHtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZSA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsYWdzLmNhc2VfYm9keSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3Rva2Vucy5wZWVrKCkudHlwZSAhPT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICB2YXIgc3BhY2VfYWZ0ZXIgPSB0cnVlO1xuICB2YXIgaW5fdGVybmFyeSA9IGZhbHNlO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkge1xuICAgICAgLy8gQ29sb24gaXMgaW52YWxpZCBqYXZhc2NyaXB0IG91dHNpZGUgb2YgdGVybmFyeSBhbmQgb2JqZWN0LCBidXQgZG8gb3VyIGJlc3QgdG8gZ3Vlc3Mgd2hhdCB3YXMgbWVhbnQuXG4gICAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCAtPSAxO1xuICAgICAgaW5fdGVybmFyeSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJz8nKSB7XG4gICAgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCArPSAxO1xuICB9XG5cbiAgLy8gbGV0J3MgaGFuZGxlIHRoZSBvcGVyYXRvcl9wb3NpdGlvbiBvcHRpb24gcHJpb3IgdG8gYW55IGNvbmZsaWN0aW5nIGxvZ2ljXG4gIGlmICghaXNVbmFyeSAmJiAhaXNHZW5lcmF0b3JBc3RlcmlzayAmJiB0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycykpIHtcbiAgICB2YXIgaXNDb2xvbiA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonO1xuICAgIHZhciBpc1Rlcm5hcnlDb2xvbiA9IChpc0NvbG9uICYmIGluX3Rlcm5hcnkpO1xuICAgIHZhciBpc090aGVyQ29sb24gPSAoaXNDb2xvbiAmJiAhaW5fdGVybmFyeSk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24pIHtcbiAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU6XG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSAhaXNPdGhlckNvbG9uO1xuXG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5hZnRlcl9uZXdsaW5lOlxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyBhbnl0aGluZyBidXQgY29sb24sIG9yICh2aWEgZGVkdWN0aW9uKSBpdCdzIGEgY29sb24gYW5kIGluIGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgIC8vICAgdGhlbiBwcmludCBhIG5ld2xpbmUuXG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3Rva2Vucy5wZWVrKCkubmV3bGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLnByZXNlcnZlX25ld2xpbmU6XG4gICAgICAgIGlmICghaXNPdGhlckNvbG9uKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UganVzdCBhZGRlZCBhIG5ld2xpbmUsIG9yIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgIC8vICAgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgIHNwYWNlX2JlZm9yZSA9ICEodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpIHx8IGlzT3RoZXJDb2xvbik7XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2JlZm9yZTtcbiAgICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNHZW5lcmF0b3JBc3Rlcmlzaykge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gICAgc3BhY2VfYWZ0ZXIgPSBuZXh0X3Rva2VuICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgW1RPS0VOLldPUkQsIFRPS0VOLlJFU0VSVkVEXSk7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLi4uJykge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICBzcGFjZV9iZWZvcmUgPSB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLO1xuICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0tJywgJysrJywgJyEnLCAnfiddKSB8fCBpc1VuYXJ5KSB7XG4gICAgLy8gdW5hcnkgb3BlcmF0b3JzIChhbmQgYmluYXJ5ICsvLSBwcmV0ZW5kaW5nIHRvIGJlIHVuYXJ5KSBzcGVjaWFsIGNhc2VzXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSKSB7XG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgfVxuXG4gICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgc3BhY2VfYWZ0ZXIgPSBmYWxzZTtcblxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjkuMVxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbmV3bGluZSBiZXR3ZWVuIC0tIG9yICsrIGFuZCBhbnl0aGluZyBlbHNlIHdlIHNob3VsZCBwcmVzZXJ2ZSBpdC5cbiAgICBpZiAoY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnICYmIGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkpIHtcbiAgICAgIC8vIGZvciAoOzsgKytpKVxuICAgICAgLy8gICAgICAgIF5eXlxuICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICAgIHNwYWNlX2JlZm9yZSA9ICEodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnXScgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICAgIC8vIGErKyArICsrYjtcbiAgICAgIC8vIGEgLSAtYlxuICAgICAgc3BhY2VfYmVmb3JlID0gaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKSAmJiBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnLS0nLCAnLScsICcrKycsICcrJ10pO1xuICAgICAgLy8gKyBhbmQgLSBhcmUgbm90IHVuYXJ5IHdoZW4gcHJlY2VlZGVkIGJ5IC0tIG9yICsrIG9wZXJhdG9yXG4gICAgICAvLyBhLS0gKyBiXG4gICAgICAvLyBhICogK2JcbiAgICAgIC8vIGEgLSAtYlxuICAgICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWycrJywgJy0nXSkgJiYgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJy0tJywgJysrJ10pKSB7XG4gICAgICAgIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICgoKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiYgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkgfHwgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpICYmXG4gICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAneycgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOycpKSB7XG4gICAgICAvLyB7IGZvbzsgLS1pIH1cbiAgICAgIC8vIGZvbygpOyAtLWJhcjtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuIHx8IHNwYWNlX2JlZm9yZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2FmdGVyO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2Jsb2NrX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKHRoaXMuX291dHB1dC5yYXcpIHtcbiAgICB0aGlzLl9vdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzICYmIGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZSA9PT0gJ2VuZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHRlc3RpbmcgdGhlIHJhdyBvdXRwdXQgYmVoYXZpb3IsIGRvIG5vdCBhbGxvdyBhIGRpcmVjdGl2ZSB0byB0dXJuIGl0IG9mZi5cbiAgICAgIHRoaXMuX291dHB1dC5yYXcgPSB0aGlzLl9vcHRpb25zLnRlc3Rfb3V0cHV0X3JhdztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMuX291dHB1dC5yYXcgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlubGluZSBibG9ja1xuICBpZiAoIWFjb3JuLm5ld2xpbmUudGVzdChjdXJyZW50X3Rva2VuLnRleHQpICYmICFjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludF9ibG9ja19jb21tbWVudChjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF9ibG9ja19jb21tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICB2YXIgbGluZXMgPSBzcGxpdF9saW5lYnJlYWtzKGN1cnJlbnRfdG9rZW4udGV4dCk7XG4gIHZhciBqOyAvLyBpdGVyYXRvciBmb3IgdGhpcyBjYXNlXG4gIHZhciBqYXZhZG9jID0gZmFsc2U7XG4gIHZhciBzdGFybGVzcyA9IGZhbHNlO1xuICB2YXIgbGFzdEluZGVudCA9IGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmU7XG4gIHZhciBsYXN0SW5kZW50TGVuZ3RoID0gbGFzdEluZGVudC5sZW5ndGg7XG5cbiAgLy8gYmxvY2sgY29tbWVudCBzdGFydHMgd2l0aCBhIG5ldyBsaW5lXG4gIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcblxuICAvLyBmaXJzdCBsaW5lIGFsd2F5cyBpbmRlbnRlZFxuICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obGluZXNbMF0pO1xuICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG5cblxuICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgIGxpbmVzID0gbGluZXMuc2xpY2UoMSk7XG4gICAgamF2YWRvYyA9IGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLCAnKicpO1xuICAgIHN0YXJsZXNzID0gZWFjaF9saW5lX21hdGNoZXNfaW5kZW50KGxpbmVzLCBsYXN0SW5kZW50KTtcblxuICAgIGlmIChqYXZhZG9jKSB7XG4gICAgICB0aGlzLl9mbGFncy5hbGlnbm1lbnQgPSAxO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGphdmFkb2MpIHtcbiAgICAgICAgLy8gamF2YWRvYzogcmVmb3JtYXQgYW5kIHJlLWluZGVudFxuICAgICAgICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obHRyaW0obGluZXNbal0pKTtcbiAgICAgIH0gZWxzZSBpZiAoc3Rhcmxlc3MgJiYgbGluZXNbal0pIHtcbiAgICAgICAgLy8gc3Rhcmxlc3M6IHJlLWluZGVudCBub24tZW1wdHkgY29udGVudCwgYXZvaWRpbmcgdHJpbVxuICAgICAgICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obGluZXNbal0uc3Vic3RyaW5nKGxhc3RJbmRlbnRMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vcm1hbCBjb21tZW50cyBvdXRwdXQgcmF3XG4gICAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obGluZXNbal0pO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3IgY29tbWVudHMgb24gdGhlaXIgb3duIGxpbmUgb3IgIG1vcmUgdGhhbiBvbmUgbGluZSwgbWFrZSBzdXJlIHRoZXJlJ3MgYSBuZXcgbGluZSBhZnRlclxuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZsYWdzLmFsaWdubWVudCA9IDA7XG4gIH1cbn07XG5cblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gIH1cblxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2RvdCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbG93IHByZXNlcnZlZCBuZXdsaW5lcyBiZWZvcmUgZG90cyBpbiBnZW5lcmFsXG4gICAgLy8gZm9yY2UgbmV3bGluZXMgb24gZG90cyBhZnRlciBjbG9zZSBwYXJlbiB3aGVuIGJyZWFrX2NoYWluZWQgLSBmb3IgYmFyKCkuYmF6KClcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbixcbiAgICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJyknICYmIHRoaXMuX29wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzKTtcbiAgfVxuXG4gIC8vIE9ubHkgdW5pbmRlbnQgY2hhaW5lZCBtZXRob2QgZG90IGlmIHRoaXMgZG90IHN0YXJ0cyBhIG5ldyBsaW5lLlxuICAvLyBPdGhlcndpc2UgdGhlIGF1dG9tYXRpYyBleHRyYSBpbmRlbnRhdGlvbiByZW1vdmFsIHdpbGwgaGFuZGxlIHRoZSBvdmVyIGluZGVudFxuICBpZiAodGhpcy5fb3B0aW9ucy51bmluZGVudF9jaGFpbmVkX21ldGhvZHMgJiYgdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgdGhpcy5kZWluZGVudCgpO1xuICB9XG5cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV91bmtub3duID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dFtjdXJyZW50X3Rva2VuLnRleHQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZW9mID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBVbndpbmQgYW55IG9wZW4gc3RhdGVtZW50c1xuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0ZXh0LCBuZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmUpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAvLyBjb21tZW50c19iZWZvcmUgYXJlXG4gIC8vIGNvbW1lbnRzIHRoYXQgaGF2ZSBhIG5ldyBsaW5lIGJlZm9yZSB0aGVtXG4gIC8vIGFuZCBtYXkgb3IgbWF5IG5vdCBoYXZlIGEgbmV3bGluZSBhZnRlclxuICAvLyB0aGlzIGlzIGEgc2V0IG9mIGNvbW1lbnRzIGJlZm9yZVxuICB0aGlzLmNvbW1lbnRzX2JlZm9yZSA9IG51bGw7IC8qIGlubGluZSBjb21tZW50Ki9cblxuXG4gIC8vIHRoaXMuY29tbWVudHNfYWZ0ZXIgPSAgbmV3IFRva2VuU3RyZWFtKCk7IC8vIG5vIG5ldyBsaW5lIGJlZm9yZSBhbmQgbmV3bGluZSBhZnRlclxuICB0aGlzLm5ld2xpbmVzID0gbmV3bGluZXMgfHwgMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZSA9IHdoaXRlc3BhY2VfYmVmb3JlIHx8ICcnO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICB0aGlzLm9wZW5lZCA9IG51bGw7XG4gIHRoaXMuY2xvc2VkID0gbnVsbDtcbiAgdGhpcy5kaXJlY3RpdmVzID0gbnVsbDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGpzaGludCBub2RlOiB0cnVlLCBjdXJseTogZmFsc2UgKi9cbi8vIFBhcnRzIG9mIHRoaXMgc2VjdGlvbiBvZiBjb2RlIGlzIHRha2VuIGZyb20gYWNvcm4uXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBUaGUgVW5pY29kZSByZWdleHBzIChmb3IgaWRlbnRpZmllcnMgYW5kIHdoaXRlc3BhY2UpIHdlcmVcbi8vIHRha2VuIGZyb20gW0VzcHJpbWFdKGh0dHA6Ly9lc3ByaW1hLm9yZykgYnkgQXJpeWEgSGlkYXlhdC5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cblxuXG5cbi8vIGFjb3JuIHVzZWQgY2hhciBjb2RlcyB0byBzcXVlZXplIHRoZSBsYXN0IGJpdCBvZiBwZXJmb3JtYW5jZSBvdXRcbi8vIEJlYXV0aWZpZXIgaXMgb2theSB3aXRob3V0IHRoYXQsIHNvIHdlJ3JlIHVzaW5nIHJlZ2V4XG4vLyBwZXJtaXQgJCAoMzYpIGFuZCBAICg2NCkuIEAgaXMgdXNlZCBpbiBFUzcgZGVjb3JhdG9ycy5cbi8vIDY1IHRocm91Z2ggOTEgYXJlIHVwcGVyY2FzZSBsZXR0ZXJzLlxuLy8gcGVybWl0IF8gKDk1KS5cbi8vIDk3IHRocm91Z2ggMTIzIGFyZSBsb3dlcmNhc2UgbGV0dGVycy5cbnZhciBiYXNlQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFxcXHgyNFxcXFx4NDBcXFxceDQxLVxcXFx4NWFcXFxceDVmXFxcXHg2MS1cXFxceDdhXCI7XG5cbi8vIGluc2lkZSBhbiBpZGVudGlmaWVyIEAgaXMgbm90IGFsbG93ZWQgYnV0IDAtOSBhcmUuXG52YXIgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXFxceDI0XFxcXHgzMC1cXFxceDM5XFxcXHg0MS1cXFxceDVhXFxcXHg1ZlxcXFx4NjEtXFxcXHg3YVwiO1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXFxceGFhXFxcXHhiNVxcXFx4YmFcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZjZcXFxceGY4LVxcXFx1MDJjMVxcXFx1MDJjNi1cXFxcdTAyZDFcXFxcdTAyZTAtXFxcXHUwMmU0XFxcXHUwMmVjXFxcXHUwMmVlXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3YS1cXFxcdTAzN2RcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhhXFxcXHUwMzhjXFxcXHUwMzhlLVxcXFx1MDNhMVxcXFx1MDNhMy1cXFxcdTAzZjVcXFxcdTAzZjctXFxcXHUwNDgxXFxcXHUwNDhhLVxcXFx1MDUyN1xcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNWQwLVxcXFx1MDVlYVxcXFx1MDVmMC1cXFxcdTA1ZjJcXFxcdTA2MjAtXFxcXHUwNjRhXFxcXHUwNjZlXFxcXHUwNjZmXFxcXHUwNjcxLVxcXFx1MDZkM1xcXFx1MDZkNVxcXFx1MDZlNVxcXFx1MDZlNlxcXFx1MDZlZVxcXFx1MDZlZlxcXFx1MDZmYS1cXFxcdTA2ZmNcXFxcdTA2ZmZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJmXFxcXHUwNzRkLVxcXFx1MDdhNVxcXFx1MDdiMVxcXFx1MDdjYS1cXFxcdTA3ZWFcXFxcdTA3ZjRcXFxcdTA3ZjVcXFxcdTA3ZmFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFhXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhhMFxcXFx1MDhhMi1cXFxcdTA4YWNcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNkXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5NzdcXFxcdTA5NzktXFxcXHUwOTdmXFxcXHUwOTg1LVxcXFx1MDk4Y1xcXFx1MDk4ZlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5YThcXFxcdTA5YWEtXFxcXHUwOWIwXFxcXHUwOWIyXFxcXHUwOWI2LVxcXFx1MDliOVxcXFx1MDliZFxcXFx1MDljZVxcXFx1MDlkY1xcXFx1MDlkZFxcXFx1MDlkZi1cXFxcdTA5ZTFcXFxcdTA5ZjBcXFxcdTA5ZjFcXFxcdTBhMDUtXFxcXHUwYTBhXFxcXHUwYTBmXFxcXHUwYTEwXFxcXHUwYTEzLVxcXFx1MGEyOFxcXFx1MGEyYS1cXFxcdTBhMzBcXFxcdTBhMzJcXFxcdTBhMzNcXFxcdTBhMzVcXFxcdTBhMzZcXFxcdTBhMzhcXFxcdTBhMzlcXFxcdTBhNTktXFxcXHUwYTVjXFxcXHUwYTVlXFxcXHUwYTcyLVxcXFx1MGE3NFxcXFx1MGE4NS1cXFxcdTBhOGRcXFxcdTBhOGYtXFxcXHUwYTkxXFxcXHUwYTkzLVxcXFx1MGFhOFxcXFx1MGFhYS1cXFxcdTBhYjBcXFxcdTBhYjJcXFxcdTBhYjNcXFxcdTBhYjUtXFxcXHUwYWI5XFxcXHUwYWJkXFxcXHUwYWQwXFxcXHUwYWUwXFxcXHUwYWUxXFxcXHUwYjA1LVxcXFx1MGIwY1xcXFx1MGIwZlxcXFx1MGIxMFxcXFx1MGIxMy1cXFxcdTBiMjhcXFxcdTBiMmEtXFxcXHUwYjMwXFxcXHUwYjMyXFxcXHUwYjMzXFxcXHUwYjM1LVxcXFx1MGIzOVxcXFx1MGIzZFxcXFx1MGI1Y1xcXFx1MGI1ZFxcXFx1MGI1Zi1cXFxcdTBiNjFcXFxcdTBiNzFcXFxcdTBiODNcXFxcdTBiODUtXFxcXHUwYjhhXFxcXHUwYjhlLVxcXFx1MGI5MFxcXFx1MGI5Mi1cXFxcdTBiOTVcXFxcdTBiOTlcXFxcdTBiOWFcXFxcdTBiOWNcXFxcdTBiOWVcXFxcdTBiOWZcXFxcdTBiYTNcXFxcdTBiYTRcXFxcdTBiYTgtXFxcXHUwYmFhXFxcXHUwYmFlLVxcXFx1MGJiOVxcXFx1MGJkMFxcXFx1MGMwNS1cXFxcdTBjMGNcXFxcdTBjMGUtXFxcXHUwYzEwXFxcXHUwYzEyLVxcXFx1MGMyOFxcXFx1MGMyYS1cXFxcdTBjMzNcXFxcdTBjMzUtXFxcXHUwYzM5XFxcXHUwYzNkXFxcXHUwYzU4XFxcXHUwYzU5XFxcXHUwYzYwXFxcXHUwYzYxXFxcXHUwYzg1LVxcXFx1MGM4Y1xcXFx1MGM4ZS1cXFxcdTBjOTBcXFxcdTBjOTItXFxcXHUwY2E4XFxcXHUwY2FhLVxcXFx1MGNiM1xcXFx1MGNiNS1cXFxcdTBjYjlcXFxcdTBjYmRcXFxcdTBjZGVcXFxcdTBjZTBcXFxcdTBjZTFcXFxcdTBjZjFcXFxcdTBjZjJcXFxcdTBkMDUtXFxcXHUwZDBjXFxcXHUwZDBlLVxcXFx1MGQxMFxcXFx1MGQxMi1cXFxcdTBkM2FcXFxcdTBkM2RcXFxcdTBkNGVcXFxcdTBkNjBcXFxcdTBkNjFcXFxcdTBkN2EtXFxcXHUwZDdmXFxcXHUwZDg1LVxcXFx1MGQ5NlxcXFx1MGQ5YS1cXFxcdTBkYjFcXFxcdTBkYjMtXFxcXHUwZGJiXFxcXHUwZGJkXFxcXHUwZGMwLVxcXFx1MGRjNlxcXFx1MGUwMS1cXFxcdTBlMzBcXFxcdTBlMzJcXFxcdTBlMzNcXFxcdTBlNDAtXFxcXHUwZTQ2XFxcXHUwZTgxXFxcXHUwZTgyXFxcXHUwZTg0XFxcXHUwZTg3XFxcXHUwZTg4XFxcXHUwZThhXFxcXHUwZThkXFxcXHUwZTk0LVxcXFx1MGU5N1xcXFx1MGU5OS1cXFxcdTBlOWZcXFxcdTBlYTEtXFxcXHUwZWEzXFxcXHUwZWE1XFxcXHUwZWE3XFxcXHUwZWFhXFxcXHUwZWFiXFxcXHUwZWFkLVxcXFx1MGViMFxcXFx1MGViMlxcXFx1MGViM1xcXFx1MGViZFxcXFx1MGVjMC1cXFxcdTBlYzRcXFxcdTBlYzZcXFxcdTBlZGMtXFxcXHUwZWRmXFxcXHUwZjAwXFxcXHUwZjQwLVxcXFx1MGY0N1xcXFx1MGY0OS1cXFxcdTBmNmNcXFxcdTBmODgtXFxcXHUwZjhjXFxcXHUxMDAwLVxcXFx1MTAyYVxcXFx1MTAzZlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNWEtXFxcXHUxMDVkXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZlLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOGVcXFxcdTEwYTAtXFxcXHUxMGM1XFxcXHUxMGM3XFxcXHUxMGNkXFxcXHUxMGQwLVxcXFx1MTBmYVxcXFx1MTBmYy1cXFxcdTEyNDhcXFxcdTEyNGEtXFxcXHUxMjRkXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1YS1cXFxcdTEyNWRcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhhLVxcXFx1MTI4ZFxcXFx1MTI5MC1cXFxcdTEyYjBcXFxcdTEyYjItXFxcXHUxMmI1XFxcXHUxMmI4LVxcXFx1MTJiZVxcXFx1MTJjMFxcXFx1MTJjMi1cXFxcdTEyYzVcXFxcdTEyYzgtXFxcXHUxMmQ2XFxcXHUxMmQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVhXFxcXHUxMzgwLVxcXFx1MTM4ZlxcXFx1MTNhMC1cXFxcdTEzZjRcXFxcdTE0MDEtXFxcXHUxNjZjXFxcXHUxNjZmLVxcXFx1MTY3ZlxcXFx1MTY4MS1cXFxcdTE2OWFcXFxcdTE2YTAtXFxcXHUxNmVhXFxcXHUxNmVlLVxcXFx1MTZmMFxcXFx1MTcwMC1cXFxcdTE3MGNcXFxcdTE3MGUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZjXFxcXHUxNzZlLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3YjNcXFxcdTE3ZDdcXFxcdTE3ZGNcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThhOFxcXFx1MThhYVxcXFx1MThiMC1cXFxcdTE4ZjVcXFxcdTE5MDAtXFxcXHUxOTFjXFxcXHUxOTUwLVxcXFx1MTk2ZFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOWFiXFxcXHUxOWMxLVxcXFx1MTljN1xcXFx1MWEwMC1cXFxcdTFhMTZcXFxcdTFhMjAtXFxcXHUxYTU0XFxcXHUxYWE3XFxcXHUxYjA1LVxcXFx1MWIzM1xcXFx1MWI0NS1cXFxcdTFiNGJcXFxcdTFiODMtXFxcXHUxYmEwXFxcXHUxYmFlXFxcXHUxYmFmXFxcXHUxYmJhLVxcXFx1MWJlNVxcXFx1MWMwMC1cXFxcdTFjMjNcXFxcdTFjNGQtXFxcXHUxYzRmXFxcXHUxYzVhLVxcXFx1MWM3ZFxcXFx1MWNlOS1cXFxcdTFjZWNcXFxcdTFjZWUtXFxcXHUxY2YxXFxcXHUxY2Y1XFxcXHUxY2Y2XFxcXHUxZDAwLVxcXFx1MWRiZlxcXFx1MWUwMC1cXFxcdTFmMTVcXFxcdTFmMTgtXFxcXHUxZjFkXFxcXHUxZjIwLVxcXFx1MWY0NVxcXFx1MWY0OC1cXFxcdTFmNGRcXFxcdTFmNTAtXFxcXHUxZjU3XFxcXHUxZjU5XFxcXHUxZjViXFxcXHUxZjVkXFxcXHUxZjVmLVxcXFx1MWY3ZFxcXFx1MWY4MC1cXFxcdTFmYjRcXFxcdTFmYjYtXFxcXHUxZmJjXFxcXHUxZmJlXFxcXHUxZmMyLVxcXFx1MWZjNFxcXFx1MWZjNi1cXFxcdTFmY2NcXFxcdTFmZDAtXFxcXHUxZmQzXFxcXHUxZmQ2LVxcXFx1MWZkYlxcXFx1MWZlMC1cXFxcdTFmZWNcXFxcdTFmZjItXFxcXHUxZmY0XFxcXHUxZmY2LVxcXFx1MWZmY1xcXFx1MjA3MVxcXFx1MjA3ZlxcXFx1MjA5MC1cXFxcdTIwOWNcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMGEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExZFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyYS1cXFxcdTIxMmRcXFxcdTIxMmYtXFxcXHUyMTM5XFxcXHUyMTNjLVxcXFx1MjEzZlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNGVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyYzAwLVxcXFx1MmMyZVxcXFx1MmMzMC1cXFxcdTJjNWVcXFxcdTJjNjAtXFxcXHUyY2U0XFxcXHUyY2ViLVxcXFx1MmNlZVxcXFx1MmNmMlxcXFx1MmNmM1xcXFx1MmQwMC1cXFxcdTJkMjVcXFxcdTJkMjdcXFxcdTJkMmRcXFxcdTJkMzAtXFxcXHUyZDY3XFxcXHUyZDZmXFxcXHUyZDgwLVxcXFx1MmQ5NlxcXFx1MmRhMC1cXFxcdTJkYTZcXFxcdTJkYTgtXFxcXHUyZGFlXFxcXHUyZGIwLVxcXFx1MmRiNlxcXFx1MmRiOC1cXFxcdTJkYmVcXFxcdTJkYzAtXFxcXHUyZGM2XFxcXHUyZGM4LVxcXFx1MmRjZVxcXFx1MmRkMC1cXFxcdTJkZDZcXFxcdTJkZDgtXFxcXHUyZGRlXFxcXHUyZTJmXFxcXHUzMDA1LVxcXFx1MzAwN1xcXFx1MzAyMS1cXFxcdTMwMjlcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDM4LVxcXFx1MzAzY1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOWQtXFxcXHUzMDlmXFxcXHUzMGExLVxcXFx1MzBmYVxcXFx1MzBmYy1cXFxcdTMwZmZcXFxcdTMxMDUtXFxcXHUzMTJkXFxcXHUzMTMxLVxcXFx1MzE4ZVxcXFx1MzFhMC1cXFxcdTMxYmFcXFxcdTMxZjAtXFxcXHUzMWZmXFxcXHUzNDAwLVxcXFx1NGRiNVxcXFx1NGUwMC1cXFxcdTlmY2NcXFxcdWEwMDAtXFxcXHVhNDhjXFxcXHVhNGQwLVxcXFx1YTRmZFxcXFx1YTUwMC1cXFxcdWE2MGNcXFxcdWE2MTAtXFxcXHVhNjFmXFxcXHVhNjJhXFxcXHVhNjJiXFxcXHVhNjQwLVxcXFx1YTY2ZVxcXFx1YTY3Zi1cXFxcdWE2OTdcXFxcdWE2YTAtXFxcXHVhNmVmXFxcXHVhNzE3LVxcXFx1YTcxZlxcXFx1YTcyMi1cXFxcdWE3ODhcXFxcdWE3OGItXFxcXHVhNzhlXFxcXHVhNzkwLVxcXFx1YTc5M1xcXFx1YTdhMC1cXFxcdWE3YWFcXFxcdWE3ZjgtXFxcXHVhODAxXFxcXHVhODAzLVxcXFx1YTgwNVxcXFx1YTgwNy1cXFxcdWE4MGFcXFxcdWE4MGMtXFxcXHVhODIyXFxcXHVhODQwLVxcXFx1YTg3M1xcXFx1YTg4Mi1cXFxcdWE4YjNcXFxcdWE4ZjItXFxcXHVhOGY3XFxcXHVhOGZiXFxcXHVhOTBhLVxcXFx1YTkyNVxcXFx1YTkzMC1cXFxcdWE5NDZcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhOTg0LVxcXFx1YTliMlxcXFx1YTljZlxcXFx1YWEwMC1cXFxcdWFhMjhcXFxcdWFhNDAtXFxcXHVhYTQyXFxcXHVhYTQ0LVxcXFx1YWE0YlxcXFx1YWE2MC1cXFxcdWFhNzZcXFxcdWFhN2FcXFxcdWFhODAtXFxcXHVhYWFmXFxcXHVhYWIxXFxcXHVhYWI1XFxcXHVhYWI2XFxcXHVhYWI5LVxcXFx1YWFiZFxcXFx1YWFjMFxcXFx1YWFjMlxcXFx1YWFkYi1cXFxcdWFhZGRcXFxcdWFhZTAtXFxcXHVhYWVhXFxcXHVhYWYyLVxcXFx1YWFmNFxcXFx1YWIwMS1cXFxcdWFiMDZcXFxcdWFiMDktXFxcXHVhYjBlXFxcXHVhYjExLVxcXFx1YWIxNlxcXFx1YWIyMC1cXFxcdWFiMjZcXFxcdWFiMjgtXFxcXHVhYjJlXFxcXHVhYmMwLVxcXFx1YWJlMlxcXFx1YWMwMC1cXFxcdWQ3YTNcXFxcdWQ3YjAtXFxcXHVkN2M2XFxcXHVkN2NiLVxcXFx1ZDdmYlxcXFx1ZjkwMC1cXFxcdWZhNmRcXFxcdWZhNzAtXFxcXHVmYWQ5XFxcXHVmYjAwLVxcXFx1ZmIwNlxcXFx1ZmIxMy1cXFxcdWZiMTdcXFxcdWZiMWRcXFxcdWZiMWYtXFxcXHVmYjI4XFxcXHVmYjJhLVxcXFx1ZmIzNlxcXFx1ZmIzOC1cXFxcdWZiM2NcXFxcdWZiM2VcXFxcdWZiNDBcXFxcdWZiNDFcXFxcdWZiNDNcXFxcdWZiNDRcXFxcdWZiNDYtXFxcXHVmYmIxXFxcXHVmYmQzLVxcXFx1ZmQzZFxcXFx1ZmQ1MC1cXFxcdWZkOGZcXFxcdWZkOTItXFxcXHVmZGM3XFxcXHVmZGYwLVxcXFx1ZmRmYlxcXFx1ZmU3MC1cXFxcdWZlNzRcXFxcdWZlNzYtXFxcXHVmZWZjXFxcXHVmZjIxLVxcXFx1ZmYzYVxcXFx1ZmY0MS1cXFxcdWZmNWFcXFxcdWZmNjYtXFxcXHVmZmJlXFxcXHVmZmMyLVxcXFx1ZmZjN1xcXFx1ZmZjYS1cXFxcdWZmY2ZcXFxcdWZmZDItXFxcXHVmZmQ3XFxcXHVmZmRhLVxcXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDU5MS1cXFxcdTA1YmRcXFxcdTA1YmZcXFxcdTA1YzFcXFxcdTA1YzJcXFxcdTA1YzRcXFxcdTA1YzVcXFxcdTA1YzdcXFxcdTA2MTAtXFxcXHUwNjFhXFxcXHUwNjIwLVxcXFx1MDY0OVxcXFx1MDY3Mi1cXFxcdTA2ZDNcXFxcdTA2ZTctXFxcXHUwNmU4XFxcXHUwNmZiLVxcXFx1MDZmY1xcXFx1MDczMC1cXFxcdTA3NGFcXFxcdTA4MDAtXFxcXHUwODE0XFxcXHUwODFiLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJkXFxcXHUwODQwLVxcXFx1MDg1N1xcXFx1MDhlNC1cXFxcdTA4ZmVcXFxcdTA5MDAtXFxcXHUwOTAzXFxcXHUwOTNhLVxcXFx1MDkzY1xcXFx1MDkzZS1cXFxcdTA5NGZcXFxcdTA5NTEtXFxcXHUwOTU3XFxcXHUwOTYyLVxcXFx1MDk2M1xcXFx1MDk2Ni1cXFxcdTA5NmZcXFxcdTA5ODEtXFxcXHUwOTgzXFxcXHUwOWJjXFxcXHUwOWJlLVxcXFx1MDljNFxcXFx1MDljN1xcXFx1MDljOFxcXFx1MDlkN1xcXFx1MDlkZi1cXFxcdTA5ZTBcXFxcdTBhMDEtXFxcXHUwYTAzXFxcXHUwYTNjXFxcXHUwYTNlLVxcXFx1MGE0MlxcXFx1MGE0N1xcXFx1MGE0OFxcXFx1MGE0Yi1cXFxcdTBhNGRcXFxcdTBhNTFcXFxcdTBhNjYtXFxcXHUwYTcxXFxcXHUwYTc1XFxcXHUwYTgxLVxcXFx1MGE4M1xcXFx1MGFiY1xcXFx1MGFiZS1cXFxcdTBhYzVcXFxcdTBhYzctXFxcXHUwYWM5XFxcXHUwYWNiLVxcXFx1MGFjZFxcXFx1MGFlMi1cXFxcdTBhZTNcXFxcdTBhZTYtXFxcXHUwYWVmXFxcXHUwYjAxLVxcXFx1MGIwM1xcXFx1MGIzY1xcXFx1MGIzZS1cXFxcdTBiNDRcXFxcdTBiNDdcXFxcdTBiNDhcXFxcdTBiNGItXFxcXHUwYjRkXFxcXHUwYjU2XFxcXHUwYjU3XFxcXHUwYjVmLVxcXFx1MGI2MFxcXFx1MGI2Ni1cXFxcdTBiNmZcXFxcdTBiODJcXFxcdTBiYmUtXFxcXHUwYmMyXFxcXHUwYmM2LVxcXFx1MGJjOFxcXFx1MGJjYS1cXFxcdTBiY2RcXFxcdTBiZDdcXFxcdTBiZTYtXFxcXHUwYmVmXFxcXHUwYzAxLVxcXFx1MGMwM1xcXFx1MGM0Ni1cXFxcdTBjNDhcXFxcdTBjNGEtXFxcXHUwYzRkXFxcXHUwYzU1XFxcXHUwYzU2XFxcXHUwYzYyLVxcXFx1MGM2M1xcXFx1MGM2Ni1cXFxcdTBjNmZcXFxcdTBjODJcXFxcdTBjODNcXFxcdTBjYmNcXFxcdTBjYmUtXFxcXHUwY2M0XFxcXHUwY2M2LVxcXFx1MGNjOFxcXFx1MGNjYS1cXFxcdTBjY2RcXFxcdTBjZDVcXFxcdTBjZDZcXFxcdTBjZTItXFxcXHUwY2UzXFxcXHUwY2U2LVxcXFx1MGNlZlxcXFx1MGQwMlxcXFx1MGQwM1xcXFx1MGQ0Ni1cXFxcdTBkNDhcXFxcdTBkNTdcXFxcdTBkNjItXFxcXHUwZDYzXFxcXHUwZDY2LVxcXFx1MGQ2ZlxcXFx1MGQ4MlxcXFx1MGQ4M1xcXFx1MGRjYVxcXFx1MGRjZi1cXFxcdTBkZDRcXFxcdTBkZDZcXFxcdTBkZDgtXFxcXHUwZGRmXFxcXHUwZGYyXFxcXHUwZGYzXFxcXHUwZTM0LVxcXFx1MGUzYVxcXFx1MGU0MC1cXFxcdTBlNDVcXFxcdTBlNTAtXFxcXHUwZTU5XFxcXHUwZWI0LVxcXFx1MGViOVxcXFx1MGVjOC1cXFxcdTBlY2RcXFxcdTBlZDAtXFxcXHUwZWQ5XFxcXHUwZjE4XFxcXHUwZjE5XFxcXHUwZjIwLVxcXFx1MGYyOVxcXFx1MGYzNVxcXFx1MGYzN1xcXFx1MGYzOVxcXFx1MGY0MS1cXFxcdTBmNDdcXFxcdTBmNzEtXFxcXHUwZjg0XFxcXHUwZjg2LVxcXFx1MGY4N1xcXFx1MGY4ZC1cXFxcdTBmOTdcXFxcdTBmOTktXFxcXHUwZmJjXFxcXHUwZmM2XFxcXHUxMDAwLVxcXFx1MTAyOVxcXFx1MTA0MC1cXFxcdTEwNDlcXFxcdTEwNjctXFxcXHUxMDZkXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4Mi1cXFxcdTEwOGRcXFxcdTEwOGYtXFxcXHUxMDlkXFxcXHUxMzVkLVxcXFx1MTM1ZlxcXFx1MTcwZS1cXFxcdTE3MTBcXFxcdTE3MjAtXFxcXHUxNzMwXFxcXHUxNzQwLVxcXFx1MTc1MFxcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTc4MC1cXFxcdTE3YjJcXFxcdTE3ZGRcXFxcdTE3ZTAtXFxcXHUxN2U5XFxcXHUxODBiLVxcXFx1MTgwZFxcXFx1MTgxMC1cXFxcdTE4MTlcXFxcdTE5MjAtXFxcXHUxOTJiXFxcXHUxOTMwLVxcXFx1MTkzYlxcXFx1MTk1MS1cXFxcdTE5NmRcXFxcdTE5YjAtXFxcXHUxOWMwXFxcXHUxOWM4LVxcXFx1MTljOVxcXFx1MTlkMC1cXFxcdTE5ZDlcXFxcdTFhMDAtXFxcXHUxYTE1XFxcXHUxYTIwLVxcXFx1MWE1M1xcXFx1MWE2MC1cXFxcdTFhN2NcXFxcdTFhN2YtXFxcXHUxYTg5XFxcXHUxYTkwLVxcXFx1MWE5OVxcXFx1MWI0Ni1cXFxcdTFiNGJcXFxcdTFiNTAtXFxcXHUxYjU5XFxcXHUxYjZiLVxcXFx1MWI3M1xcXFx1MWJiMC1cXFxcdTFiYjlcXFxcdTFiZTYtXFxcXHUxYmYzXFxcXHUxYzAwLVxcXFx1MWMyMlxcXFx1MWM0MC1cXFxcdTFjNDlcXFxcdTFjNWItXFxcXHUxYzdkXFxcXHUxY2QwLVxcXFx1MWNkMlxcXFx1MWQwMC1cXFxcdTFkYmVcXFxcdTFlMDEtXFxcXHUxZjE1XFxcXHUyMDBjXFxcXHUyMDBkXFxcXHUyMDNmXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMGQwLVxcXFx1MjBkY1xcXFx1MjBlMVxcXFx1MjBlNS1cXFxcdTIwZjBcXFxcdTJkODEtXFxcXHUyZDk2XFxcXHUyZGUwLVxcXFx1MmRmZlxcXFx1MzAyMS1cXFxcdTMwMjhcXFxcdTMwOTlcXFxcdTMwOWFcXFxcdWE2NDAtXFxcXHVhNjZkXFxcXHVhNjc0LVxcXFx1YTY3ZFxcXFx1YTY5ZlxcXFx1YTZmMC1cXFxcdWE2ZjFcXFxcdWE3ZjgtXFxcXHVhODAwXFxcXHVhODA2XFxcXHVhODBiXFxcXHVhODIzLVxcXFx1YTgyN1xcXFx1YTg4MC1cXFxcdWE4ODFcXFxcdWE4YjQtXFxcXHVhOGM0XFxcXHVhOGQwLVxcXFx1YThkOVxcXFx1YThmMy1cXFxcdWE4ZjdcXFxcdWE5MDAtXFxcXHVhOTA5XFxcXHVhOTI2LVxcXFx1YTkyZFxcXFx1YTkzMC1cXFxcdWE5NDVcXFxcdWE5ODAtXFxcXHVhOTgzXFxcXHVhOWIzLVxcXFx1YTljMFxcXFx1YWEwMC1cXFxcdWFhMjdcXFxcdWFhNDAtXFxcXHVhYTQxXFxcXHVhYTRjLVxcXFx1YWE0ZFxcXFx1YWE1MC1cXFxcdWFhNTlcXFxcdWFhN2JcXFxcdWFhZTAtXFxcXHVhYWU5XFxcXHVhYWYyLVxcXFx1YWFmM1xcXFx1YWJjMC1cXFxcdWFiZTFcXFxcdWFiZWNcXFxcdWFiZWRcXFxcdWFiZjAtXFxcXHVhYmY5XFxcXHVmYjIwLVxcXFx1ZmIyOFxcXFx1ZmUwMC1cXFxcdWZlMGZcXFxcdWZlMjAtXFxcXHVmZTI2XFxcXHVmZTMzXFxcXHVmZTM0XFxcXHVmZTRkLVxcXFx1ZmU0ZlxcXFx1ZmYxMC1cXFxcdWZmMTlcXFxcdWZmM2ZcIjtcbi8vdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4vL3ZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG52YXIgaWRlbnRpZmllclN0YXJ0ID0gXCIoPzpcXFxcXFxcXHVbMC05YS1mQS1GXXs0fXxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl0pXCI7XG52YXIgaWRlbnRpZmllckNoYXJzID0gXCIoPzpcXFxcXFxcXHVbMC05YS1mQS1GXXs0fXxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl0pKlwiO1xuXG5leHBvcnRzLmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKGlkZW50aWZpZXJTdGFydCArIGlkZW50aWZpZXJDaGFycywgJ2cnKTtcbmV4cG9ydHMuaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChpZGVudGlmaWVyU3RhcnQpO1xuZXhwb3J0cy5pZGVudGlmaWVyTWF0Y2ggPSBuZXcgUmVnRXhwKFwiKD86XFxcXFxcXFx1WzAtOWEtZkEtRl17NH18W1wiICsgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdKStcIik7XG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuT3B0aW9ucztcblxudmFyIHZhbGlkUG9zaXRpb25WYWx1ZXMgPSBbJ2JlZm9yZS1uZXdsaW5lJywgJ2FmdGVyLW5ld2xpbmUnLCAncHJlc2VydmUtbmV3bGluZSddO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnanMnKTtcblxuICAvLyBjb21wYXRpYmlsaXR5LCByZVxuICB2YXIgcmF3X2JyYWNlX3N0eWxlID0gdGhpcy5yYXdfb3B0aW9ucy5icmFjZV9zdHlsZSB8fCBudWxsO1xuICBpZiAocmF3X2JyYWNlX3N0eWxlID09PSBcImV4cGFuZC1zdHJpY3RcIikgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgdGhpcy5yYXdfb3B0aW9ucy5icmFjZV9zdHlsZSA9IFwiZXhwYW5kXCI7XG4gIH0gZWxzZSBpZiAocmF3X2JyYWNlX3N0eWxlID09PSBcImNvbGxhcHNlLXByZXNlcnZlLWlubGluZVwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZSxwcmVzZXJ2ZS1pbmxpbmVcIjtcbiAgfSBlbHNlIGlmICh0aGlzLnJhd19vcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSAhPT0gdW5kZWZpbmVkKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gdGhpcy5yYXdfb3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUgPyBcImV4cGFuZFwiIDogXCJjb2xsYXBzZVwiO1xuICAgIC8vIH0gZWxzZSBpZiAoIXJhd19icmFjZV9zdHlsZSkgeyAvL05vdGhpbmcgZXhpc3RzIHRvIHNldCBpdFxuICAgIC8vICAgcmF3X2JyYWNlX3N0eWxlID0gXCJjb2xsYXBzZVwiO1xuICB9XG5cbiAgLy9wcmVzZXJ2ZS1pbmxpbmUgaW4gZGVsaW1pdGVkIHN0cmluZyB3aWxsIHRyaWdnZXIgYnJhY2VfcHJlc2VydmVfaW5saW5lLCBldmVyeXRoaW5nXG4gIC8vZWxzZSBpcyBjb25zaWRlcmVkIGEgYnJhY2Vfc3R5bGUgYW5kIHRoZSBsYXN0IG9uZSBvbmx5IHdpbGwgaGF2ZSBhbiBlZmZlY3RcblxuICB2YXIgYnJhY2Vfc3R5bGVfc3BsaXQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ2JyYWNlX3N0eWxlJywgWydjb2xsYXBzZScsICdleHBhbmQnLCAnZW5kLWV4cGFuZCcsICdub25lJywgJ3ByZXNlcnZlLWlubGluZSddKTtcblxuICB0aGlzLmJyYWNlX3ByZXNlcnZlX2lubGluZSA9IGZhbHNlOyAvL0RlZmF1bHRzIGluIGNhc2Ugb25lIG9yIG90aGVyIHdhcyBub3Qgc3BlY2lmaWVkIGluIG1ldGEtb3B0aW9uXG4gIHRoaXMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlXCI7XG5cbiAgZm9yICh2YXIgYnMgPSAwOyBicyA8IGJyYWNlX3N0eWxlX3NwbGl0Lmxlbmd0aDsgYnMrKykge1xuICAgIGlmIChicmFjZV9zdHlsZV9zcGxpdFtic10gPT09IFwicHJlc2VydmUtaW5saW5lXCIpIHtcbiAgICAgIHRoaXMuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5icmFjZV9zdHlsZSA9IGJyYWNlX3N0eWxlX3NwbGl0W2JzXTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcyA9IHRoaXMuX2dldF9ib29sZWFuKCd1bmluZGVudF9jaGFpbmVkX21ldGhvZHMnKTtcbiAgdGhpcy5icmVha19jaGFpbmVkX21ldGhvZHMgPSB0aGlzLl9nZXRfYm9vbGVhbignYnJlYWtfY2hhaW5lZF9tZXRob2RzJyk7XG4gIHRoaXMuc3BhY2VfaW5fcGFyZW4gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfaW5fcGFyZW4nKTtcbiAgdGhpcy5zcGFjZV9pbl9lbXB0eV9wYXJlbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9pbl9lbXB0eV9wYXJlbicpO1xuICB0aGlzLmpzbGludF9oYXBweSA9IHRoaXMuX2dldF9ib29sZWFuKCdqc2xpbnRfaGFwcHknKTtcbiAgdGhpcy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24nKTtcbiAgdGhpcy5zcGFjZV9hZnRlcl9uYW1lZF9mdW5jdGlvbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9hZnRlcl9uYW1lZF9mdW5jdGlvbicpO1xuICB0aGlzLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSB0aGlzLl9nZXRfYm9vbGVhbigna2VlcF9hcnJheV9pbmRlbnRhdGlvbicpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwnLCB0cnVlKTtcbiAgdGhpcy51bmVzY2FwZV9zdHJpbmdzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3VuZXNjYXBlX3N0cmluZ3MnKTtcbiAgdGhpcy5lNHggPSB0aGlzLl9nZXRfYm9vbGVhbignZTR4Jyk7XG4gIHRoaXMuY29tbWFfZmlyc3QgPSB0aGlzLl9nZXRfYm9vbGVhbignY29tbWFfZmlyc3QnKTtcbiAgdGhpcy5vcGVyYXRvcl9wb3NpdGlvbiA9IHRoaXMuX2dldF9zZWxlY3Rpb24oJ29wZXJhdG9yX3Bvc2l0aW9uJywgdmFsaWRQb3NpdGlvblZhbHVlcyk7XG5cbiAgLy8gRm9yIHRlc3Rpbmcgb2YgYmVhdXRpZnkgcHJlc2VydmU6c3RhcnQgZGlyZWN0aXZlXG4gIHRoaXMudGVzdF9vdXRwdXRfcmF3ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3Rlc3Rfb3V0cHV0X3JhdycpO1xuXG4gIC8vIGZvcmNlIHRoaXMuX29wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiB0byB0cnVlIGlmIHRoaXMuX29wdGlvbnMuanNsaW50X2hhcHB5XG4gIGlmICh0aGlzLmpzbGludF9oYXBweSkge1xuICAgIHRoaXMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiA9IHRydWU7XG4gIH1cblxufVxuT3B0aW9ucy5wcm90b3R5cGUgPSBuZXcgQmFzZU9wdGlvbnMoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCkge1xuICB0aGlzLnJhd19vcHRpb25zID0gX21lcmdlT3B0cyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCk7XG5cbiAgLy8gU3VwcG9ydCBwYXNzaW5nIHRoZSBzb3VyY2UgdGV4dCBiYWNrIHdpdGggbm8gY2hhbmdlXG4gIHRoaXMuZGlzYWJsZWQgPSB0aGlzLl9nZXRfYm9vbGVhbignZGlzYWJsZWQnKTtcblxuICB0aGlzLmVvbCA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdlb2wnLCAnYXV0bycpO1xuICB0aGlzLmVuZF93aXRoX25ld2xpbmUgPSB0aGlzLl9nZXRfYm9vbGVhbignZW5kX3dpdGhfbmV3bGluZScpO1xuICB0aGlzLmluZGVudF9zaXplID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X3NpemUnLCA0KTtcbiAgdGhpcy5pbmRlbnRfY2hhciA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdpbmRlbnRfY2hhcicsICcgJyk7XG4gIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X2xldmVsJyk7XG5cbiAgdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdwcmVzZXJ2ZV9uZXdsaW5lcycsIHRydWUpO1xuICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9udW1iZXIoJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcycsIDMyNzg2KTtcbiAgaWYgKCF0aGlzLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSAwO1xuICB9XG5cbiAgdGhpcy5pbmRlbnRfd2l0aF90YWJzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF93aXRoX3RhYnMnLCB0aGlzLmluZGVudF9jaGFyID09PSAnXFx0Jyk7XG4gIGlmICh0aGlzLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLmluZGVudF9jaGFyID0gJ1xcdCc7XG5cbiAgICAvLyBpbmRlbnRfc2l6ZSBiZWhhdmlvciBjaGFuZ2VkIGFmdGVyIDEuOC42XG4gICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IGluZGVudF9zaXplIHdvdWxkIGJlXG4gICAgLy8gc2V0IHRvIDEgZm9yIGluZGVudF93aXRoX3RhYnMuIFRoYXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhbmRcbiAgICAvLyBhY3R1YWxseSBkb2Vzbid0IG1ha2Ugc2Vuc2UgLSB3aHkgbm90IHVzZSBzcGFjZXM/IEZ1cnRoZXIsXG4gICAgLy8gdGhhdCBtaWdodCBwcm9kdWNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IgLSB0YWJzIGJlaW5nIHVzZWRcbiAgICAvLyBmb3Igc2luZ2xlLWNvbHVtbiBhbGlnbm1lbnQuIFNvLCB3aGVuIGluZGVudF93aXRoX3RhYnMgaXMgdHJ1ZVxuICAgIC8vIGFuZCBpbmRlbnRfc2l6ZSBpcyAxLCByZXNldCBpbmRlbnRfc2l6ZSB0byA0LlxuICAgIGlmICh0aGlzLmluZGVudF9zaXplID09PSAxKSB7XG4gICAgICB0aGlzLmluZGVudF9zaXplID0gNDtcbiAgICB9XG4gIH1cblxuICAvLyBCYWNrd2FyZHMgY29tcGF0IHdpdGggMS4zLnhcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9saW5lX2xlbmd0aCcsIHRoaXMuX2dldF9udW1iZXIoJ21heF9jaGFyJykpO1xuXG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9lbXB0eV9saW5lcycpO1xuXG4gIC8vIHZhbGlkIHRlbXBsYXRpbmcgbGFuZ3VhZ2VzIFsnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCddXG4gIC8vIEZvciBub3csICdhdXRvJyA9IGFsbCBvZmYgZm9yIGphdmFzY3JpcHQsIGFsbCBvbiBmb3IgaHRtbCAoYW5kIGlubGluZSBqYXZhc2NyaXB0KS5cbiAgLy8gb3RoZXIgdmFsdWVzIGlnbm9yZWRcbiAgdGhpcy50ZW1wbGF0aW5nID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCd0ZW1wbGF0aW5nJywgWydhdXRvJywgJ25vbmUnLCAnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCddLCBbJ2F1dG8nXSk7XG59XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYXJyYXkgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCBbXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdGlvbl92YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uX3ZhbHVlLmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLmNvbmNhdCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5zcGxpdCgvW15hLXpBLVowLTlfXFwvXFwtXSsvKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9ib29sZWFuID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbl92YWx1ZSA9PT0gdW5kZWZpbmVkID8gISFkZWZhdWx0X3ZhbHVlIDogISFvcHRpb25fdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2NoYXJhY3RlcnMgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCAnJztcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1xcXFx0LywgJ1xcdCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X251bWJlciA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIGRlZmF1bHRfdmFsdWUgPSBwYXJzZUludChkZWZhdWx0X3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihkZWZhdWx0X3ZhbHVlKSkge1xuICAgIGRlZmF1bHRfdmFsdWUgPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBwYXJzZUludChvcHRpb25fdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QobmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gb25seSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbl9saXN0ID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb25fbGlzdCB8fCBzZWxlY3Rpb25fbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3Rpb24gbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuICB9XG5cbiAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfdmFsdWUgfHwgW3NlbGVjdGlvbl9saXN0WzBdXTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24oZGVmYXVsdF92YWx1ZSwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEZWZhdWx0IFZhbHVlIVwiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfYXJyYXkobmFtZSwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBjb250YWluIG9ubHkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2lzX3ZhbGlkX3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpIHtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggJiYgc2VsZWN0aW9uX2xpc3QubGVuZ3RoICYmXG4gICAgIXJlc3VsdC5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHNlbGVjdGlvbl9saXN0LmluZGV4T2YoaXRlbSkgPT09IC0xOyB9KTtcbn07XG5cblxuLy8gbWVyZ2VzIGNoaWxkIG9wdGlvbnMgdXAgd2l0aCB0aGUgcGFyZW50IG9wdGlvbnMgb2JqZWN0XG4vLyBFeGFtcGxlOiBvYmogPSB7YTogMSwgYjoge2E6IDJ9fVxuLy8gICAgICAgICAgbWVyZ2VPcHRzKG9iaiwgJ2InKVxuLy9cbi8vICAgICAgICAgIFJldHVybnM6IHthOiAyfVxuZnVuY3Rpb24gX21lcmdlT3B0cyhhbGxPcHRpb25zLCBjaGlsZEZpZWxkTmFtZSkge1xuICB2YXIgZmluYWxPcHRzID0ge307XG4gIGFsbE9wdGlvbnMgPSBfbm9ybWFsaXplT3B0cyhhbGxPcHRpb25zKTtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSAhPT0gY2hpbGRGaWVsZE5hbWUpIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSBjaGlsZEZpZWxkTmFtZVxuICBpZiAoY2hpbGRGaWVsZE5hbWUgJiYgYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplT3B0cyhvcHRpb25zKSB7XG4gIHZhciBjb252ZXJ0ZWRPcHRzID0ge307XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgY29udmVydGVkT3B0c1tuZXdLZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZU9wdHMgPSBfbm9ybWFsaXplT3B0cztcbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IF9tZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgSW5wdXRTY2FubmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5JbnB1dFNjYW5uZXI7XG52YXIgQmFzZVRva2VuaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oOSkuVG9rZW5pemVyO1xudmFyIEJBU0VUT0tFTiA9IF9fd2VicGFja19yZXF1aXJlX18oOSkuVE9LRU47XG52YXIgRGlyZWN0aXZlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpLkRpcmVjdGl2ZXM7XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIFBhdHRlcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuO1xudmFyIFRlbXBsYXRhYmxlUGF0dGVybiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLlRlbXBsYXRhYmxlUGF0dGVybjtcblxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuXG52YXIgVE9LRU4gPSB7XG4gIFNUQVJUX0VYUFI6ICdUS19TVEFSVF9FWFBSJyxcbiAgRU5EX0VYUFI6ICdUS19FTkRfRVhQUicsXG4gIFNUQVJUX0JMT0NLOiAnVEtfU1RBUlRfQkxPQ0snLFxuICBFTkRfQkxPQ0s6ICdUS19FTkRfQkxPQ0snLFxuICBXT1JEOiAnVEtfV09SRCcsXG4gIFJFU0VSVkVEOiAnVEtfUkVTRVJWRUQnLFxuICBTRU1JQ09MT046ICdUS19TRU1JQ09MT04nLFxuICBTVFJJTkc6ICdUS19TVFJJTkcnLFxuICBFUVVBTFM6ICdUS19FUVVBTFMnLFxuICBPUEVSQVRPUjogJ1RLX09QRVJBVE9SJyxcbiAgQ09NTUE6ICdUS19DT01NQScsXG4gIEJMT0NLX0NPTU1FTlQ6ICdUS19CTE9DS19DT01NRU5UJyxcbiAgQ09NTUVOVDogJ1RLX0NPTU1FTlQnLFxuICBET1Q6ICdUS19ET1QnLFxuICBVTktOT1dOOiAnVEtfVU5LTk9XTicsXG4gIFNUQVJUOiBCQVNFVE9LRU4uU1RBUlQsXG4gIFJBVzogQkFTRVRPS0VOLlJBVyxcbiAgRU9GOiBCQVNFVE9LRU4uRU9GXG59O1xuXG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvXFwvXFwqLywgL1xcKlxcLy8pO1xuXG52YXIgbnVtYmVyX3BhdHRlcm4gPSAvMFt4WF1bMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRl0qfDBbb09dWzAxMjM0NTY3XSp8MFtiQl1bMDFdKnxcXGQrbnwoPzpcXC5cXGQrfFxcZCtcXC4/XFxkKikoPzpbZUVdWystXT9cXGQrKT8vO1xuXG52YXIgZGlnaXQgPSAvWzAtOV0vO1xuXG4vLyBEb3QgXCIuXCIgbXVzdCBiZSBkaXN0aW5ndWlzaGVkIGZyb20gXCIuLi5cIiBhbmQgZGVjaW1hbFxudmFyIGRvdF9wYXR0ZXJuID0gL1teXFxkXFwuXS87XG5cbnZhciBwb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gKFxuICBcIj4+PiA9PT0gIT09IFwiICtcbiAgXCI8PCAmJiA+PSAqKiAhPSA9PSA8PSA+PiB8fCBcIiArXG4gIFwiPCAvIC0gKyA+IDogJiAlID8gXiB8ICpcIikuc3BsaXQoJyAnKTtcblxuLy8gSU1QT1JUQU5UOiB0aGlzIG11c3QgYmUgc29ydGVkIGxvbmdlc3QgdG8gc2hvcnRlc3Qgb3IgdG9rZW5pemluZyBtYW55IG5vdCB3b3JrLlxuLy8gQWxzbywgeW91IG11c3QgdXBkYXRlIHBvc3NpdGlvbmFibGUgb3BlcmF0b3JzIHNlcGFyYXRlbHkgZnJvbSBwdW5jdFxudmFyIHB1bmN0ID1cbiAgXCI+Pj49IFwiICtcbiAgXCIuLi4gPj49IDw8PSA9PT0gPj4+ICE9PSAqKj0gXCIgK1xuICBcIj0+IF49IDo6IC89IDw8IDw9ID09ICYmIC09ID49ID4+ICE9IC0tICs9ICoqIHx8ICsrICU9ICY9ICo9IHw9IFwiICtcbiAgXCI9ICEgPyA+IDwgOiAvIF4gLSArICogJiAlIH4gfFwiO1xuXG5wdW5jdCA9IHB1bmN0LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXS9nLCBcIlxcXFwkJlwiKTtcbnB1bmN0ID0gcHVuY3QucmVwbGFjZSgvIC9nLCAnfCcpO1xuXG52YXIgcHVuY3RfcGF0dGVybiA9IG5ldyBSZWdFeHAocHVuY3QpO1xuXG4vLyB3b3JkcyB3aGljaCBzaG91bGQgYWx3YXlzIHN0YXJ0IG9uIG5ldyBsaW5lLlxudmFyIGxpbmVfc3RhcnRlcnMgPSAnY29udGludWUsdHJ5LHRocm93LHJldHVybix2YXIsbGV0LGNvbnN0LGlmLHN3aXRjaCxjYXNlLGRlZmF1bHQsZm9yLHdoaWxlLGJyZWFrLGZ1bmN0aW9uLGltcG9ydCxleHBvcnQnLnNwbGl0KCcsJyk7XG52YXIgcmVzZXJ2ZWRfd29yZHMgPSBsaW5lX3N0YXJ0ZXJzLmNvbmNhdChbJ2RvJywgJ2luJywgJ29mJywgJ2Vsc2UnLCAnZ2V0JywgJ3NldCcsICduZXcnLCAnY2F0Y2gnLCAnZmluYWxseScsICd0eXBlb2YnLCAneWllbGQnLCAnYXN5bmMnLCAnYXdhaXQnLCAnZnJvbScsICdhcyddKTtcbnZhciByZXNlcnZlZF93b3JkX3BhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKD86JyArIHJlc2VydmVkX3dvcmRzLmpvaW4oJ3wnKSArICcpJCcpO1xuXG4vLyB2YXIgdGVtcGxhdGVfcGF0dGVybiA9IC8oPzooPzo8XFw/cGhwfDxcXD89KVtcXHNcXFNdKj9cXD8+KXwoPzo8JVtcXHNcXFNdKj8lPikvZztcblxudmFyIGluX2h0bWxfY29tbWVudDtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICBCYXNlVG9rZW5pemVyLmNhbGwodGhpcywgaW5wdXRfc3RyaW5nLCBvcHRpb25zKTtcblxuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5tYXRjaGluZyhcbiAgICAvXFx1MDBBMFxcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZi8uc291cmNlLFxuICAgIC9cXHUyMDI4XFx1MjAyOS8uc291cmNlKTtcblxuICB2YXIgcGF0dGVybl9yZWFkZXIgPSBuZXcgUGF0dGVybih0aGlzLl9pbnB1dCk7XG4gIHZhciB0ZW1wbGF0YWJsZSA9IG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQpXG4gICAgLnJlYWRfb3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcblxuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgdGVtcGxhdGU6IHRlbXBsYXRhYmxlLFxuICAgIGlkZW50aWZpZXI6IHRlbXBsYXRhYmxlLnN0YXJ0aW5nX3dpdGgoYWNvcm4uaWRlbnRpZmllcikubWF0Y2hpbmcoYWNvcm4uaWRlbnRpZmllck1hdGNoKSxcbiAgICBudW1iZXI6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKG51bWJlcl9wYXR0ZXJuKSxcbiAgICBwdW5jdDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcocHVuY3RfcGF0dGVybiksXG4gICAgLy8gY29tbWVudCBlbmRzIGp1c3QgYmVmb3JlIG5lYXJlc3QgbGluZWZlZWQgb3IgZW5kIG9mIGZpbGVcbiAgICBjb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC9cXC9cXC8vKS51bnRpbCgvW1xcblxcclxcdTIwMjhcXHUyMDI5XS8pLFxuICAgIC8vICAvKiAuLi4gKi8gY29tbWVudCBlbmRzIHdpdGggbmVhcmVzdCAqLyBvciBlbmQgb2YgZmlsZVxuICAgIGJsb2NrX2NvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL1xcL1xcKi8pLnVudGlsX2FmdGVyKC9cXCpcXC8vKSxcbiAgICBodG1sX2NvbW1lbnRfc3RhcnQ6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC88IS0tLyksXG4gICAgaHRtbF9jb21tZW50X2VuZDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcoLy0tPi8pLFxuICAgIGluY2x1ZGU6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLyNpbmNsdWRlLykudW50aWxfYWZ0ZXIoYWNvcm4ubGluZUJyZWFrKSxcbiAgICBzaGViYW5nOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC8jIS8pLnVudGlsX2FmdGVyKGFjb3JuLmxpbmVCcmVhayksXG4gICAgeG1sOiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvW1xcc1xcU10qPzwoXFwvPykoWy1hLXpBLVo6MC05Xy5dK3x7W1xcc1xcU10rP318IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXSkoXFxzK3tbXFxzXFxTXSs/fXxcXHMrWy1hLXpBLVo6MC05Xy5dK3xcXHMrWy1hLXpBLVo6MC05Xy5dK1xccyo9XFxzKignW14nXSonfFwiW15cIl0qXCJ8e1tcXHNcXFNdKz99KSkqXFxzKihcXC8/KVxccyo+LyksXG4gICAgc2luZ2xlX3F1b3RlOiB0ZW1wbGF0YWJsZS51bnRpbCgvWydcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjldLyksXG4gICAgZG91YmxlX3F1b3RlOiB0ZW1wbGF0YWJsZS51bnRpbCgvW1wiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XS8pLFxuICAgIHRlbXBsYXRlX3RleHQ6IHRlbXBsYXRhYmxlLnVudGlsKC9bYFxcXFwkXS8pLFxuICAgIHRlbXBsYXRlX2V4cHJlc3Npb246IHRlbXBsYXRhYmxlLnVudGlsKC9bYH1cXFxcXS8pXG4gIH07XG5cbn07XG5Ub2tlbml6ZXIucHJvdG90eXBlID0gbmV3IEJhc2VUb2tlbml6ZXIoKTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgcmV0dXJuIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkJMT0NLX0NPTU1FTlQgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5VTktOT1dOO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgcmV0dXJuIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0sgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY2xvc2luZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIG9wZW5fdG9rZW4pIHtcbiAgcmV0dXJuIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSAmJlxuICAgIChvcGVuX3Rva2VuICYmIChcbiAgICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICddJyAmJiBvcGVuX3Rva2VuLnRleHQgPT09ICdbJykgfHxcbiAgICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcpJyAmJiBvcGVuX3Rva2VuLnRleHQgPT09ICcoJykgfHxcbiAgICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICd9JyAmJiBvcGVuX3Rva2VuLnRleHQgPT09ICd7JykpKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIGluX2h0bWxfY29tbWVudCA9IGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciBjID0gdGhpcy5faW5wdXQucGVlaygpO1xuXG4gIGlmIChjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FT0YsICcnKTtcbiAgfVxuXG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9zdHJpbmcoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF93b3JkKHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3NpbmdsZXMoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb21tZW50KGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcmVnZXhwKGMsIHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3htbChjLCBwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9ub25famF2YXNjcmlwdChjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3B1bmN0dWF0aW9uKCk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHRoaXMuX2lucHV0Lm5leHQoKSk7XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF93b3JkID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmc7XG4gIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaWRlbnRpZmllci5yZWFkKCk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nICE9PSAnJykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgIGlmICghKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLkRPVCB8fFxuICAgICAgICAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgKHByZXZpb3VzX3Rva2VuLnRleHQgPT09ICdzZXQnIHx8IHByZXZpb3VzX3Rva2VuLnRleHQgPT09ICdnZXQnKSkpICYmXG4gICAgICByZXNlcnZlZF93b3JkX3BhdHRlcm4udGVzdChyZXN1bHRpbmdfc3RyaW5nKSkge1xuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICdpbicgfHwgcmVzdWx0aW5nX3N0cmluZyA9PT0gJ29mJykgeyAvLyBoYWNrIGZvciAnaW4nIGFuZCAnb2YnIG9wZXJhdG9yc1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLk9QRVJBVE9SLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uUkVTRVJWRUQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG5cbiAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5udW1iZXIucmVhZCgpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZyAhPT0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3NpbmdsZXMgPSBmdW5jdGlvbihjKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChjID09PSAnKCcgfHwgYyA9PT0gJ1snKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RBUlRfRVhQUiwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJyknIHx8IGMgPT09ICddJykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVORF9FWFBSLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVEFSVF9CTE9DSywgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU5EX0JMT0NLLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnOycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TRU1JQ09MT04sIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICcuJyAmJiBkb3RfcGF0dGVybi50ZXN0KHRoaXMuX2lucHV0LnBlZWsoMSkpKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRE9ULCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnLCcpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NQSwgYyk7XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9wdW5jdHVhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5wdW5jdC5yZWFkKCk7XG5cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgIT09ICcnKSB7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICc9Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FUVVBTFMsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLk9QRVJBVE9SLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfbm9uX2phdmFzY3JpcHQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG5cbiAgaWYgKGMgPT09ICcjJykge1xuICAgIGlmICh0aGlzLl9pc19maXJzdF90b2tlbigpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLnNoZWJhbmcucmVhZCgpO1xuXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHJlc3VsdGluZ19zdHJpbmcudHJpbSgpICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZXMgZXh0ZW5kc2NyaXB0ICNpbmNsdWRlc1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaW5jbHVkZS5yZWFkKCk7XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCByZXN1bHRpbmdfc3RyaW5nLnRyaW0oKSArICdcXG4nKTtcbiAgICB9XG5cbiAgICBjID0gdGhpcy5faW5wdXQubmV4dCgpO1xuXG4gICAgLy8gU3BpZGVybW9ua2V5LXNwZWNpZmljIHNoYXJwIHZhcmlhYmxlcyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy4gQ29uc2lkZXJlZCBvYnNvbGV0ZS5cbiAgICB2YXIgc2hhcnAgPSAnIyc7XG4gICAgaWYgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiB0aGlzLl9pbnB1dC50ZXN0Q2hhcihkaWdpdCkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgYyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgc2hhcnAgKz0gYztcbiAgICAgIH0gd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiBjICE9PSAnIycgJiYgYyAhPT0gJz0nKTtcbiAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgLy9cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnWycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ10nKSB7XG4gICAgICAgIHNoYXJwICs9ICdbXSc7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnfScpIHtcbiAgICAgICAgc2hhcnAgKz0gJ3t9JztcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHNoYXJwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG5cbiAgfSBlbHNlIGlmIChjID09PSAnPCcgJiYgdGhpcy5faXNfZmlyc3RfdG9rZW4oKSkge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaHRtbF9jb21tZW50X3N0YXJ0LnJlYWQoKTtcbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiAhdGhpcy5faW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpbl9odG1sX2NvbW1lbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5faHRtbF9jb21tZW50ICYmIGMgPT09ICctJykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaHRtbF9jb21tZW50X2VuZC5yZWFkKCk7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIGluX2h0bWxfY29tbWVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29tbWVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKGMgPT09ICcvJykge1xuICAgIHZhciBjb21tZW50ID0gJyc7XG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICcqJykge1xuICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvKiAuLi4gKi9cbiAgICAgIGNvbW1lbnQgPSB0aGlzLl9fcGF0dGVybnMuYmxvY2tfY29tbWVudC5yZWFkKCk7XG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGNvbW1lbnQgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQkxPQ0tfQ09NTUVOVCwgY29tbWVudCk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICcvJykge1xuICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvLyAuLi5cbiAgICAgIGNvbW1lbnQgPSB0aGlzLl9fcGF0dGVybnMuY29tbWVudC5yZWFkKCk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCBjb21tZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9zdHJpbmcgPSBmdW5jdGlvbihjKSB7XG4gIGlmIChjID09PSAnYCcgfHwgYyA9PT0gXCInXCIgfHwgYyA9PT0gJ1wiJykge1xuICAgIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIHRoaXMuaGFzX2NoYXJfZXNjYXBlcyA9IGZhbHNlO1xuXG4gICAgaWYgKGMgPT09ICdgJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoJ2AnLCB0cnVlLCAnJHsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoYyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzX2NoYXJfZXNjYXBlcyAmJiB0aGlzLl9vcHRpb25zLnVuZXNjYXBlX3N0cmluZ3MpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB1bmVzY2FwZV9zdHJpbmcocmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gYykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfVxuXG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2FsbG93X3JlZ2V4cF9vcl94bWwgPSBmdW5jdGlvbihwcmV2aW91c190b2tlbikge1xuICAvLyByZWdleCBhbmQgeG1sIGNhbiBvbmx5IGFwcGVhciBpbiBzcGVjaWZpYyBsb2NhdGlvbnMgZHVyaW5nIHBhcnNpbmdcbiAgcmV0dXJuIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheShwcmV2aW91c190b2tlbi50ZXh0LCBbJ3JldHVybicsICdjYXNlJywgJ3Rocm93JywgJ2Vsc2UnLCAnZG8nLCAndHlwZW9mJywgJ3lpZWxkJ10pKSB8fFxuICAgIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUiAmJiBwcmV2aW91c190b2tlbi50ZXh0ID09PSAnKScgJiZcbiAgICAgIHByZXZpb3VzX3Rva2VuLm9wZW5lZC5wcmV2aW91cy50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheShwcmV2aW91c190b2tlbi5vcGVuZWQucHJldmlvdXMudGV4dCwgWydpZicsICd3aGlsZScsICdmb3InXSkpIHx8XG4gICAgKGluX2FycmF5KHByZXZpb3VzX3Rva2VuLnR5cGUsIFtUT0tFTi5DT01NRU5ULCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5TVEFSVF9CTE9DSywgVE9LRU4uU1RBUlQsXG4gICAgICBUT0tFTi5FTkRfQkxPQ0ssIFRPS0VOLk9QRVJBVE9SLCBUT0tFTi5FUVVBTFMsIFRPS0VOLkVPRiwgVE9LRU4uU0VNSUNPTE9OLCBUT0tFTi5DT01NQVxuICAgIF0pKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcmVnZXhwID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4pIHtcblxuICBpZiAoYyA9PT0gJy8nICYmIHRoaXMuX2FsbG93X3JlZ2V4cF9vcl94bWwocHJldmlvdXNfdG9rZW4pKSB7XG4gICAgLy8gaGFuZGxlIHJlZ2V4cFxuICAgIC8vXG4gICAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgdmFyIGVzYyA9IGZhbHNlO1xuXG4gICAgdmFyIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpICYmXG4gICAgICAoKGVzYyB8fCBpbl9jaGFyX2NsYXNzIHx8IHRoaXMuX2lucHV0LnBlZWsoKSAhPT0gYykgJiZcbiAgICAgICAgIXRoaXMuX2lucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gICAgICBpZiAoIWVzYykge1xuICAgICAgICBlc2MgPSB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdcXFxcJztcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1snKSB7XG4gICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnXScpIHtcbiAgICAgICAgICBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzYyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09IGMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuXG4gICAgICAvLyByZWdleHBzIG1heSBoYXZlIG1vZGlmaWVycyAvcmVnZXhwL01PRCAsIHNvIGZldGNoIHRob3NlLCB0b29cbiAgICAgIC8vIE9ubHkgW2dpbV0gYXJlIHZhbGlkLCBidXQgaWYgdGhlIHVzZXIgcHV0cyBpbiBnYXJiYWdlLCBkbyB3aGF0IHdlIGNhbiB0byB0YWtlIGl0LlxuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5yZWFkKGFjb3JuLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3htbCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuKSB7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZTR4ICYmIGMgPT09IFwiPFwiICYmIHRoaXMuX2FsbG93X3JlZ2V4cF9vcl94bWwocHJldmlvdXNfdG9rZW4pKSB7XG4gICAgdmFyIHhtbFN0ciA9ICcnO1xuICAgIHZhciBtYXRjaCA9IHRoaXMuX19wYXR0ZXJucy54bWwucmVhZF9tYXRjaCgpO1xuICAgIC8vIGhhbmRsZSBlNHggeG1sIGxpdGVyYWxzXG4gICAgLy9cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIC8vIFRyaW0gcm9vdCB0YWcgdG8gYXR0ZW1wdCB0b1xuICAgICAgdmFyIHJvb3RUYWcgPSBtYXRjaFsyXS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9Jyk7XG4gICAgICB2YXIgaXNDdXJseVJvb3QgPSByb290VGFnLmluZGV4T2YoJ3snKSA9PT0gMDtcbiAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGlzRW5kVGFnID0gISFtYXRjaFsxXTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaFsyXTtcbiAgICAgICAgdmFyIGlzU2luZ2xldG9uVGFnID0gKCEhbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pIHx8ICh0YWdOYW1lLnNsaWNlKDAsIDgpID09PSBcIiFbQ0RBVEFbXCIpO1xuICAgICAgICBpZiAoIWlzU2luZ2xldG9uVGFnICYmXG4gICAgICAgICAgKHRhZ05hbWUgPT09IHJvb3RUYWcgfHwgKGlzQ3VybHlSb290ICYmIHRhZ05hbWUucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpKSkpIHtcbiAgICAgICAgICBpZiAoaXNFbmRUYWcpIHtcbiAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhtbFN0ciArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHRoaXMuX19wYXR0ZXJucy54bWwucmVhZF9tYXRjaCgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNsb3NlIGNvcnJlY3RseSwga2VlcCB1bmZvcm1hdHRlZC5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgeG1sU3RyICs9IHRoaXMuX2lucHV0Lm1hdGNoKC9bXFxzXFxTXSovZylbMF07XG4gICAgICB9XG4gICAgICB4bWxTdHIgPSB4bWxTdHIucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgeG1sU3RyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVuZXNjYXBlX3N0cmluZyhzKSB7XG4gIC8vIFlvdSB0aGluayB0aGF0IGEgcmVnZXggd291bGQgd29yayBmb3IgdGhpc1xuICAvLyByZXR1cm4gcy5yZXBsYWNlKC9cXFxceChbMC05YS1mXXsyfSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCB2YWwpIHtcbiAgLy8gICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh2YWwsIDE2KSk7XG4gIC8vICAgICB9KVxuICAvLyBIb3dldmVyLCBkZWFsaW5nIHdpdGggJ1xceGZmJywgJ1xcXFx4ZmYnLCAnXFxcXFxceGZmJyBtYWtlcyB0aGlzIG1vcmUgZnVuLlxuICB2YXIgb3V0ID0gJycsXG4gICAgZXNjYXBlZCA9IDA7XG5cbiAgdmFyIGlucHV0X3NjYW4gPSBuZXcgSW5wdXRTY2FubmVyKHMpO1xuICB2YXIgbWF0Y2hlZCA9IG51bGw7XG5cbiAgd2hpbGUgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgLy8gS2VlcCBhbnkgd2hpdGVzcGFjZSwgbm9uLXNsYXNoIGNoYXJhY3RlcnNcbiAgICAvLyBhbHNvIGtlZXAgc2xhc2ggcGFpcnMuXG4gICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goLyhbXFxzXXxbXlxcXFxdfFxcXFxcXFxcKSsvZyk7XG5cbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgb3V0ICs9IG1hdGNoZWRbMF07XG4gICAgfVxuXG4gICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAnXFxcXCcpIHtcbiAgICAgIGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAneCcpIHtcbiAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3goWzAtOUEtRmEtZl17Mn0pL2cpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3UnKSB7XG4gICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC91KFswLTlBLUZhLWZdezR9KS9nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnXFxcXCc7XG4gICAgICAgIGlmIChpbnB1dF9zY2FuLmhhc05leHQoKSkge1xuICAgICAgICAgIG91dCArPSBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUncyBzb21lIGVycm9yIGRlY29kaW5nLCByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICBlc2NhcGVkID0gcGFyc2VJbnQobWF0Y2hlZFsxXSwgMTYpO1xuXG4gICAgICBpZiAoZXNjYXBlZCA+IDB4N2UgJiYgZXNjYXBlZCA8PSAweGZmICYmIG1hdGNoZWRbMF0uaW5kZXhPZigneCcpID09PSAwKSB7XG4gICAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIFxceDdmLi5cXHhmZixcbiAgICAgICAgLy8gbGVhdmluZyB3aG9sZSBzdHJpbmcgZXNjYXBlZCxcbiAgICAgICAgLy8gYXMgaXQncyBwcm9iYWJseSBjb21wbGV0ZWx5IGJpbmFyeVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA+PSAweDAwICYmIGVzY2FwZWQgPCAweDIwKSB7XG4gICAgICAgIC8vIGxlYXZlIDB4MDAuLi4weDFmIGVzY2FwZWRcbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIG1hdGNoZWRbMF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID09PSAweDIyIHx8IGVzY2FwZWQgPT09IDB4MjcgfHwgZXNjYXBlZCA9PT0gMHg1Yykge1xuICAgICAgICAvLyBzaW5nbGUtcXVvdGUsIGFwb3N0cm9waGUsIGJhY2tzbGFzaCAtIGVzY2FwZSB0aGVzZVxuICAgICAgICBvdXQgKz0gJ1xcXFwnICsgU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGhhbmRsZSBzdHJpbmdcbi8vXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUgPSBmdW5jdGlvbihkZWxpbWl0ZXIsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgc3RhcnRfc3ViKSB7XG4gIHZhciBjdXJyZW50X2NoYXI7XG4gIHZhciBwYXR0ZXJuO1xuICBpZiAoZGVsaW1pdGVyID09PSAnXFwnJykge1xuICAgIHBhdHRlcm4gPSB0aGlzLl9fcGF0dGVybnMuc2luZ2xlX3F1b3RlO1xuICB9IGVsc2UgaWYgKGRlbGltaXRlciA9PT0gJ1wiJykge1xuICAgIHBhdHRlcm4gPSB0aGlzLl9fcGF0dGVybnMuZG91YmxlX3F1b3RlO1xuICB9IGVsc2UgaWYgKGRlbGltaXRlciA9PT0gJ2AnKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy50ZW1wbGF0ZV90ZXh0O1xuICB9IGVsc2UgaWYgKGRlbGltaXRlciA9PT0gJ30nKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy50ZW1wbGF0ZV9leHByZXNzaW9uO1xuICB9XG5cbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBwYXR0ZXJuLnJlYWQoKTtcbiAgdmFyIG5leHQgPSAnJztcbiAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgIG5leHQgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKG5leHQgPT09IGRlbGltaXRlciB8fFxuICAgICAgKCFhbGxvd191bmVzY2FwZWRfbmV3bGluZXMgJiYgYWNvcm4ubmV3bGluZS50ZXN0KG5leHQpKSkge1xuICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSAnXFxcXCcgJiYgdGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICBjdXJyZW50X2NoYXIgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgICAgIGlmIChjdXJyZW50X2NoYXIgPT09ICd4JyB8fCBjdXJyZW50X2NoYXIgPT09ICd1Jykge1xuICAgICAgICB0aGlzLmhhc19jaGFyX2VzY2FwZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50X2NoYXIgPT09ICdcXHInICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICdcXG4nKSB7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRfc3ViKSB7XG4gICAgICBpZiAoc3RhcnRfc3ViID09PSAnJHsnICYmIG5leHQgPT09ICckJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7Jykge1xuICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0X3N1YiA9PT0gbmV4dCkge1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICAgICAgICBuZXh0ICs9IHRoaXMuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSgnfScsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJ2AnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ICs9IHRoaXMuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSgnYCcsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJyR7Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHQgKz0gcGF0dGVybi5yZWFkKCk7XG4gICAgcmVzdWx0aW5nX3N0cmluZyArPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdGluZ19zdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xubW9kdWxlLmV4cG9ydHMucG9zaXRpb25hYmxlX29wZXJhdG9ycyA9IHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMuc2xpY2UoKTtcbm1vZHVsZS5leHBvcnRzLmxpbmVfc3RhcnRlcnMgPSBsaW5lX3N0YXJ0ZXJzLnNsaWNlKCk7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgcmVnZXhwX2hhc19zdGlja3kgPSBSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzdGlja3knKTtcblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZykge1xuICB0aGlzLl9faW5wdXQgPSBpbnB1dF9zdHJpbmcgfHwgJyc7XG4gIHRoaXMuX19pbnB1dF9sZW5ndGggPSB0aGlzLl9faW5wdXQubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufVxuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3Bvc2l0aW9uID4gMCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiAtPSAxO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX19pbnB1dF9sZW5ndGg7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQodGhpcy5fX3Bvc2l0aW9uKTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyBhIEphdmFTY3JpcHQgb25seSBoZWxwZXIgZnVuY3Rpb24gKG5vdCBpbiBweXRob24pXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoIG1ldGhvZFxuLy8gYW5kIG5vdCBhbGwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCBcInN0aWNreVwiIGZsYWcuXG4vLyBJZiB0aGV5IGRvIG5vdCBzdXBwb3J0IHN0aWNreSB0aGVuIGJvdGggdGhpcy5tYXRjaCgpIGFuZCB0aGlzLnRlc3QoKSBtZXRob2Rcbi8vIG11c3QgZ2V0IHRoZSBtYXRjaCBhbmQgY2hlY2sgdGhlIGluZGV4IG9mIHRoZSBtYXRjaC5cbi8vIElmIHN0aWNreSBpcyBzdXBwb3J0ZWQgYW5kIHNldCwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBjaGVjayB0aGF0IGdsb2JhbCBpcyBzZXQsIGFuZCBmYWxsIGJhY2sgdG8gdGhlIHNsb3dlciBtZXRob2QuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLl9fbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IGluZGV4O1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuXG4gIGlmIChwYXR0ZXJuX21hdGNoICYmICEocmVnZXhwX2hhc19zdGlja3kgJiYgcGF0dGVybi5zdGlja3kpKSB7XG4gICAgaWYgKHBhdHRlcm5fbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuXG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHJldHVybiAhIXRoaXMuX19tYXRjaChwYXR0ZXJuLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgLy8gdGVzdCBvbmUgY2hhcmFjdGVyIHJlZ2V4IG1hdGNoXG4gIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHRoaXMuX19tYXRjaChwYXR0ZXJuLCB0aGlzLl9fcG9zaXRpb24pO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHN0YXJ0aW5nX3BhdHRlcm4sIHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoO1xuICBpZiAoc3RhcnRpbmdfcGF0dGVybikge1xuICAgIG1hdGNoID0gdGhpcy5tYXRjaChzdGFydGluZ19wYXR0ZXJuKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhbCArPSBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgaWYgKHVudGlsX3BhdHRlcm4gJiYgKG1hdGNoIHx8ICFzdGFydGluZ19wYXR0ZXJuKSkge1xuICAgIHZhbCArPSB0aGlzLnJlYWRVbnRpbCh1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsID0gZnVuY3Rpb24ocGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2hfaW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIG1hdGNoX2luZGV4ID0gcGF0dGVybl9tYXRjaC5pbmRleDtcbiAgICBpZiAodW50aWxfYWZ0ZXIpIHtcbiAgICAgIG1hdGNoX2luZGV4ICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRjaF9pbmRleCA9IHRoaXMuX19pbnB1dF9sZW5ndGg7XG4gIH1cblxuICB2YWwgPSB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHRoaXMuX19wb3NpdGlvbiwgbWF0Y2hfaW5kZXgpO1xuICB0aGlzLl9fcG9zaXRpb24gPSBtYXRjaF9pbmRleDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLnJlYWRVbnRpbChwYXR0ZXJuLCB0cnVlKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG1hdGNoX2Zyb20pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBmbGFncyA9ICdnJztcbiAgaWYgKG1hdGNoX2Zyb20gJiYgcmVnZXhwX2hhc19zdGlja3kpIHtcbiAgICBmbGFncyA9ICd5JztcbiAgfVxuICAvLyBzdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gcmVnZXhwXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICE9PSAnJykge1xuICAgIC8vIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSwgZmxhZ3MpO1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGVsc2UgaWYgKHBhdHRlcm4pIHtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X2xpdGVyYWxfcmVnZXhwID0gZnVuY3Rpb24obGl0ZXJhbF9zdHJpbmcpIHtcbiAgcmV0dXJuIFJlZ0V4cChsaXRlcmFsX3N0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSk7XG59O1xuXG4vKiBjc3MgYmVhdXRpZmllciBsZWdhY3kgaGVscGVycyAqL1xuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgdmFsID0gdGhpcy5yZWFkVW50aWxBZnRlcihwYXR0ZXJuKTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmxvb2tCYWNrID0gZnVuY3Rpb24odGVzdFZhbCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb24gLSAxO1xuICByZXR1cm4gc3RhcnQgPj0gdGVzdFZhbC5sZW5ndGggJiYgdGhpcy5fX2lucHV0LnN1YnN0cmluZyhzdGFydCAtIHRlc3RWYWwubGVuZ3RoLCBzdGFydClcbiAgICAudG9Mb3dlckNhc2UoKSA9PT0gdGVzdFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBJbnB1dFNjYW5uZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLklucHV0U2Nhbm5lcjtcbnZhciBUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMykuVG9rZW47XG52YXIgVG9rZW5TdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKS5Ub2tlblN0cmVhbTtcbnZhciBXaGl0ZXNwYWNlUGF0dGVybiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpLldoaXRlc3BhY2VQYXR0ZXJuO1xuXG52YXIgVE9LRU4gPSB7XG4gIFNUQVJUOiAnVEtfU1RBUlQnLFxuICBSQVc6ICdUS19SQVcnLFxuICBFT0Y6ICdUS19FT0YnXG59O1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIHRoaXMuX2lucHV0ID0gbmV3IElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpO1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fX3Rva2VucyA9IG51bGw7XG5cbiAgdGhpcy5fcGF0dGVybnMgPSB7fTtcbiAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZSA9IG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2lucHV0LnJlc3RhcnQoKTtcbiAgdGhpcy5fX3Rva2VucyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuXG4gIHRoaXMuX3Jlc2V0KCk7XG5cbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBwcmV2aW91cyA9IG5ldyBUb2tlbihUT0tFTi5TVEFSVCwgJycpO1xuICB2YXIgb3Blbl90b2tlbiA9IG51bGw7XG4gIHZhciBvcGVuX3N0YWNrID0gW107XG4gIHZhciBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuXG4gIHdoaWxlIChwcmV2aW91cy50eXBlICE9PSBUT0tFTi5FT0YpIHtcbiAgICBjdXJyZW50ID0gdGhpcy5fZ2V0X25leHRfdG9rZW4ocHJldmlvdXMsIG9wZW5fdG9rZW4pO1xuICAgIHdoaWxlICh0aGlzLl9pc19jb21tZW50KGN1cnJlbnQpKSB7XG4gICAgICBjb21tZW50cy5hZGQoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gdGhpcy5fZ2V0X25leHRfdG9rZW4ocHJldmlvdXMsIG9wZW5fdG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghY29tbWVudHMuaXNFbXB0eSgpKSB7XG4gICAgICBjdXJyZW50LmNvbW1lbnRzX2JlZm9yZSA9IGNvbW1lbnRzO1xuICAgICAgY29tbWVudHMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcbiAgICB9XG5cbiAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG5cbiAgICBpZiAodGhpcy5faXNfb3BlbmluZyhjdXJyZW50KSkge1xuICAgICAgb3Blbl9zdGFjay5wdXNoKG9wZW5fdG9rZW4pO1xuICAgICAgb3Blbl90b2tlbiA9IGN1cnJlbnQ7XG4gICAgfSBlbHNlIGlmIChvcGVuX3Rva2VuICYmIHRoaXMuX2lzX2Nsb3NpbmcoY3VycmVudCwgb3Blbl90b2tlbikpIHtcbiAgICAgIGN1cnJlbnQub3BlbmVkID0gb3Blbl90b2tlbjtcbiAgICAgIG9wZW5fdG9rZW4uY2xvc2VkID0gY3VycmVudDtcbiAgICAgIG9wZW5fdG9rZW4gPSBvcGVuX3N0YWNrLnBvcCgpO1xuICAgICAgY3VycmVudC5wYXJlbnQgPSBvcGVuX3Rva2VuO1xuICAgIH1cblxuICAgIGN1cnJlbnQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudDtcblxuICAgIHRoaXMuX190b2tlbnMuYWRkKGN1cnJlbnQpO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fdG9rZW5zO1xufTtcblxuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19maXJzdF90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vucy5pc0VtcHR5KCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge307XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWQoLy4rL2cpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uUkFXLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY2xvc2luZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVfdG9rZW4gPSBmdW5jdGlvbih0eXBlLCB0ZXh0KSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0ZXh0LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UubmV3bGluZV9jb3VudCxcbiAgICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFdoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UucmVhZCgpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW5TdHJlYW0ocGFyZW50X3Rva2VuKSB7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fX3Rva2VucyA9IFtdO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9IHRoaXMuX190b2tlbnMubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICB0aGlzLl9fcGFyZW50X3Rva2VuID0gcGFyZW50X3Rva2VuO1xufVxuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnNfbGVuZ3RoID09PSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX190b2tlbnNfbGVuZ3RoO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbdGhpcy5fX3Bvc2l0aW9uXTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX3Rva2Vuc19sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW2luZGV4XTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50X3Rva2VuKSB7XG4gICAgdG9rZW4ucGFyZW50ID0gdGhpcy5fX3BhcmVudF90b2tlbjtcbiAgfVxuICB0aGlzLl9fdG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCArPSAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5TdHJlYW0gPSBUb2tlblN0cmVhbTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgUGF0dGVybiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm47XG5cbmZ1bmN0aW9uIFdoaXRlc3BhY2VQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICBQYXR0ZXJuLmNhbGwodGhpcywgaW5wdXRfc2Nhbm5lciwgcGFyZW50KTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX2xpbmVfcmVnZXhwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMoJycsICcnKTtcbiAgfVxuXG4gIHRoaXMubmV3bGluZV9jb3VudCA9IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcbn1cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZSA9IG5ldyBQYXR0ZXJuKCk7XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB3aGl0ZXNwYWNlX2NoYXJzICs9ICdcXFxcdCAnO1xuICBuZXdsaW5lX2NoYXJzICs9ICdcXFxcblxcXFxyJztcblxuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnWycgKyB3aGl0ZXNwYWNlX2NoYXJzICsgbmV3bGluZV9jaGFycyArICddKycsIHRydWUpO1xuICB0aGlzLl9uZXdsaW5lX3JlZ2V4cCA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoXG4gICAgJ1xcXFxyXFxcXG58WycgKyBuZXdsaW5lX2NoYXJzICsgJ10nKTtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV3bGluZV9jb3VudCA9IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcblxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnICcpIHtcbiAgICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gJyAnO1xuICB9IGVsc2UgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuX19zcGxpdCh0aGlzLl9uZXdsaW5lX3JlZ2V4cCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgdGhpcy5uZXdsaW5lX2NvdW50ID0gbWF0Y2hlcy5sZW5ndGggLSAxO1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSBtYXRjaGVzW3RoaXMubmV3bGluZV9jb3VudF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5tYXRjaGluZyA9IGZ1bmN0aW9uKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucyh3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgV2hpdGVzcGFjZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc3BsaXQgPSBmdW5jdGlvbihyZWdleHAsIGlucHV0X3N0cmluZykge1xuICByZWdleHAubGFzdEluZGV4ID0gMDtcbiAgdmFyIHN0YXJ0X2luZGV4ID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIHdoaWxlIChuZXh0X21hdGNoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgbmV4dF9tYXRjaC5pbmRleCkpO1xuICAgIHN0YXJ0X2luZGV4ID0gbmV4dF9tYXRjaC5pbmRleCArIG5leHRfbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIG5leHRfbWF0Y2ggPSByZWdleHAuZXhlYyhpbnB1dF9zdHJpbmcpO1xuICB9XG5cbiAgaWYgKHN0YXJ0X2luZGV4IDwgaW5wdXRfc3RyaW5nLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKGlucHV0X3N0cmluZy5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIGlucHV0X3N0cmluZy5sZW5ndGgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLldoaXRlc3BhY2VQYXR0ZXJuID0gV2hpdGVzcGFjZVBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dF9zY2FubmVyO1xuICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl91bnRpbF9hZnRlciA9IGZhbHNlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3N0YXJ0aW5nX3BhdHRlcm4sIHRydWUpO1xuICAgIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbWF0Y2hfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll91bnRpbF9wYXR0ZXJuKTtcbiAgICB0aGlzLl91bnRpbF9hZnRlciA9IHBhcmVudC5fdW50aWxfYWZ0ZXI7XG4gIH1cbn1cblxuUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgaWYgKCF0aGlzLl9zdGFydGluZ19wYXR0ZXJuIHx8IHJlc3VsdCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4sIHRoaXMuX3VudGlsX3BhdHRlcm4sIHRoaXMuX3VudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUucmVhZF9tYXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW5wdXQubWF0Y2godGhpcy5fbWF0Y2hfcGF0dGVybik7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS51bnRpbF9hZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3VudGlsX2FmdGVyID0gdHJ1ZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSBmYWxzZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnN0YXJ0aW5nX3dpdGggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybiwgdHJ1ZSk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7fTtcblxubW9kdWxlLmV4cG9ydHMuUGF0dGVybiA9IFBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gRGlyZWN0aXZlcyhzdGFydF9ibG9ja19wYXR0ZXJuLCBlbmRfYmxvY2tfcGF0dGVybikge1xuICBzdGFydF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gc3RhcnRfYmxvY2tfcGF0dGVybiA6IHN0YXJ0X2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICBlbmRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBlbmRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBlbmRfYmxvY2tfcGF0dGVybiA6IGVuZF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgdGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC8gYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcblxuICB0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbn1cblxuRGlyZWN0aXZlcy5wcm90b3R5cGUuZ2V0X2RpcmVjdGl2ZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGV4dC5tYXRjaCh0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGl2ZXM7XG59O1xuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5yZWFkSWdub3JlZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5EaXJlY3RpdmVzID0gRGlyZWN0aXZlcztcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgUGF0dGVybiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm47XG5cblxudmFyIHRlbXBsYXRlX25hbWVzID0ge1xuICBkamFuZ286IGZhbHNlLFxuICBlcmI6IGZhbHNlLFxuICBoYW5kbGViYXJzOiBmYWxzZSxcbiAgcGhwOiBmYWxzZVxufTtcblxuLy8gVGhpcyBsZXRzIHRlbXBsYXRlcyBhcHBlYXIgYW55d2hlcmUgd2Ugd291bGQgZG8gYSByZWFkVW50aWxcbi8vIFRoZSBjb3N0IGlzIGhpZ2hlciBidXQgaXQgaXMgcGF5IHRvIHBsYXkuXG5mdW5jdGlvbiBUZW1wbGF0YWJsZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX2Rpc2FibGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuICB0aGlzLl9leGNsdWRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlX25hbWVzKTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICAgIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLl9leGNsdWRlZCwgcGFyZW50Ll9leGNsdWRlZCk7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2Rpc2FibGVkLCBwYXJlbnQuX2Rpc2FibGVkKTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKGlucHV0X3NjYW5uZXIpO1xuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgaGFuZGxlYmFyc19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7IS0tLykudW50aWxfYWZ0ZXIoLy0tfX0vKSxcbiAgICBoYW5kbGViYXJzX3VuZXNjYXBlZDogcGF0dGVybi5zdGFydGluZ193aXRoKC97e3svKS51bnRpbF9hZnRlcigvfX19LyksXG4gICAgaGFuZGxlYmFyczogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIHBocDogcGF0dGVybi5zdGFydGluZ193aXRoKC88XFw/KD86Wz1dfHBocCkvKS51bnRpbF9hZnRlcigvXFw/Pi8pLFxuICAgIGVyYjogcGF0dGVybi5zdGFydGluZ193aXRoKC88JVteJV0vKS51bnRpbF9hZnRlcigvW14lXSU+LyksXG4gICAgLy8gZGphbmdvIGNvZmxpY3RzIHdpdGggaGFuZGxlYmFycyBhIGJpdC5cbiAgICBkamFuZ286IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyUvKS51bnRpbF9hZnRlcigvJX0vKSxcbiAgICBkamFuZ29fdmFsdWU6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3svKS51bnRpbF9hZnRlcigvfX0vKSxcbiAgICBkamFuZ29fY29tbWVudDogcGF0dGVybi5zdGFydGluZ193aXRoKC97Iy8pLnVudGlsX2FmdGVyKC8jfS8pXG4gIH07XG59XG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fc2V0X3RlbXBsYXRlZF9wYXR0ZXJuKCk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZGlzYWJsZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZF9vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIGZvciAodmFyIGxhbmd1YWdlIGluIHRlbXBsYXRlX25hbWVzKSB7XG4gICAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSBvcHRpb25zLnRlbXBsYXRpbmcuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xO1xuICB9XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZXhjbHVkZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4sIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgfVxuICB2YXIgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgd2hpbGUgKG5leHQpIHtcbiAgICBpZiAodGhpcy5fbWF0Y2hfcGF0dGVybikge1xuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWRVbnRpbCh0aGlzLl9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgfVxuICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIG5leHQgPSB0aGlzLl9yZWFkX3RlbXBsYXRlKCk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfYWZ0ZXIpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fdW50aWxfcGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW107XG5cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHApIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5waHAuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5lcmIuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nby5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nb192YWx1ZS5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nb19jb21tZW50Ll9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfcGF0dGVybikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fdW50aWxfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cCgnKD86JyArIGl0ZW1zLmpvaW4oJ3wnKSArICcpJyk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9yZWFkX3RlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIHZhciBjID0gdGhpcy5faW5wdXQucGVlaygpO1xuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgLy8gd2UganVzdCBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2UgdGFnXG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHAgJiYgIXRoaXMuX2V4Y2x1ZGVkLnBocCAmJiBwZWVrMSA9PT0gJz8nKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMucGhwLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIgJiYgIXRoaXMuX2V4Y2x1ZGVkLmVyYiAmJiBwZWVrMSA9PT0gJyUnKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuZXJiLnJlYWQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ3snKSB7XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5oYW5kbGViYXJzICYmICF0aGlzLl9leGNsdWRlZC5oYW5kbGViYXJzKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19jb21tZW50LnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX3VuZXNjYXBlZC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFycy5yZWFkKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28gJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZXhjbHVkZWQuZGphbmdvKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nb19jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvLnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdGluZ19zdHJpbmc7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLlRlbXBsYXRhYmxlUGF0dGVybiA9IFRlbXBsYXRhYmxlUGF0dGVybjtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG52YXIganNfYmVhdXRpZnkgPSBsZWdhY3lfYmVhdXRpZnlfanM7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IGpzX2JlYXV0aWZ5OiBqc19iZWF1dGlmeSB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmpzX2JlYXV0aWZ5YC5cbiAgICBleHBvcnRzLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufVxuXG59KCkpO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/lib/beautify.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var indexOf = function (xs, item) {\n    if (xs.indexOf) return xs.indexOf(item);\n    else for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === item) return i;\n    }\n    return -1;\n};\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    if (context) {\n        forEach(Object_keys(ctx), function (key) {\n            context[key] = ctx[key];\n        });\n    }\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.isContext = function (context) {\n    return context instanceof Context;\n};\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdm0tYnJvd3NlcmlmeS9pbmRleC5qcz8wNzA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdm0tYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCBpdGVtKSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKGl0ZW0pO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xudmFyIE9iamVjdF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ18nLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG5cbnZhciBnbG9iYWxzID0gWydBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRXJyb3InLCAnRXZhbEVycm9yJywgJ0Z1bmN0aW9uJyxcbidJbmZpbml0eScsICdKU09OJywgJ01hdGgnLCAnTmFOJywgJ051bWJlcicsICdPYmplY3QnLCAnUmFuZ2VFcnJvcicsXG4nUmVmZXJlbmNlRXJyb3InLCAnUmVnRXhwJywgJ1N0cmluZycsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InLFxuJ2RlY29kZVVSSScsICdkZWNvZGVVUklDb21wb25lbnQnLCAnZW5jb2RlVVJJJywgJ2VuY29kZVVSSUNvbXBvbmVudCcsICdlc2NhcGUnLFxuJ2V2YWwnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLCAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICd1bmRlZmluZWQnLCAndW5lc2NhcGUnXTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5Db250ZXh0LnByb3RvdHlwZSA9IHt9O1xuXG52YXIgU2NyaXB0ID0gZXhwb3J0cy5TY3JpcHQgPSBmdW5jdGlvbiBOb2RlU2NyaXB0IChjb2RlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHJldHVybiBuZXcgU2NyaXB0KGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZWVkcyBhICdjb250ZXh0JyBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgd0V2YWwgPSB3aW4uZXZhbCwgd0V4ZWNTY3JpcHQgPSB3aW4uZXhlY1NjcmlwdDtcblxuICAgIGlmICghd0V2YWwgJiYgd0V4ZWNTY3JpcHQpIHtcbiAgICAgICAgLy8gd2luLmV2YWwoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXZhbCh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuaXNDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQ7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vm-browserify/index.js\n");

/***/ })

/******/ });